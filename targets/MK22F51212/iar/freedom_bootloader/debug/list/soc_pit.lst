###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:35
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\platform\soc\MK22F\soc_pit.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\platform\soc\MK22F\soc_pit.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\soc_pit.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\soc_pit.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\platform\soc\MK22F\soc_pit.c
      1          /**HEADER*********************************************************************
      2          *
      3          * Copyright (c) 2004-2010, 2013 - 2014 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          *
      7          ******************************************************************************
      8          *
      9          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
     10          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     11          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     12          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     13          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     14          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     15          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     16          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     17          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     18          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     19          * THE POSSIBILITY OF SUCH DAMAGE.
     20          *
     21          ******************************************************************************
     22          *
     23          * $FileName: soc_pit.c
     24          * $Version :
     25          * $Date    :
     26          *
     27          * Comments:
     28          *
     29          *  
     30          *
     31          *END*************************************************************************/
     32          #include "types.h"
     33          #include "user_config.h"
     34          #if (DELAY_ENABLE) || (MAX_TIMER_OBJECTS)
     35          #include "soc.h"
     36          #include "soc_pit.h"
     37          #include "adapter.h"
     38          #define ELEMENTS_OF(x) ( sizeof(x)/sizeof(x[0]) )

   \                                 In section .data, align 4
   \   00000000   0x40037000         DC32 40037000H
     39          static const void* pit_address[] =
     40          {
     41              (void*)PIT_BASE_PTR
     42          };
     43          

   \                                 In section .data, align 4
     44          uint32_t pit_vectors[] =
   \                     pit_vectors:
   \   00000000   0x00000030         DC32 48, 49, 50, 51
   \              0x00000031   
   \              0x00000032   
   \              0x00000033   
     45          {
     46          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
     47              INT_PIT0,
     48              INT_PIT1,
     49              INT_PIT2,
     50              INT_PIT3,
     51          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)
     52              PIT0_IRQn,
     53              PIT1_IRQn,
     54              PIT2_IRQn,
     55              PIT3_IRQn,
     56          #endif
     57          };
     58          
     59          /*GLOBAL FUNCTIONS*---------------------------------------------------------*/
     60          /*FUNCTION*-------------------------------------------------------------------
     61          *
     62          * Function Name    : pit_get_base_address
     63          * Returned Value   : Address upon success, NULL upon failure
     64          * Comments         :
     65          *    This function returns the base register address of the corresponding PIT
     66          *    module.
     67          *
     68          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     69          void* pit_get_base_address
     70          (
     71              /* [IN] PIT index */
     72              uint8_t dev_num
     73          )
     74          {
     75              if (dev_num < ELEMENTS_OF(pit_address)) 
   \                     pit_get_base_address: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF0C             ITE      EQ 
   \   00000004   0x....             LDREQ.N  R0,??DataTable3  ;; 0x40037000
   \   00000006   0x2000             MOVNE    R0,#+0
     76              {
     77                  return (void*)pit_address[dev_num];
     78              }
     79              return NULL;
   \   00000008   0x4770             BX       LR
     80          }
     81          
     82          /*FUNCTION*-------------------------------------------------------------------
     83          *
     84          * Function Name    : pit_get_vector
     85          * Returned Value   : Number of vectors associated with the peripheral
     86          * Comments         :
     87          *    This function returns desired interrupt vector for specified PIT module.
     88          *
     89          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     90          uint32_t pit_get_vector
     91          (
     92              /* [IN] PIT channel */
     93              uint8_t channel
     94          )
     95          {
     96              if (channel < ELEMENTS_OF(pit_vectors)) 
   \                     pit_get_vector: (+1)
   \   00000000   0x2804             CMP      R0,#+4
   \   00000002   0xBF3D             ITTTE    CC 
   \   00000004   0x....             LDRCC.N  R1,??DataTable3_1
   \   00000006   0xF851 0x0020      LDRCC    R0,[R1, R0, LSL #+2]
   \   0000000A   0x3010             ADDCC    R0,R0,#+16
   \   0000000C   0x2000             MOVCS    R0,#+0
     97              {
     98          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
     99                  return pit_vectors[channel];
    100          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)
    101                  return pit_vectors[channel] + 16;
    102          #endif
    103              } 
    104              else 
    105              {
    106                  return 0;
   \   0000000E   0x4770             BX       LR
    107              }
    108          }
    109          
    110          /*FUNCTION*-------------------------------------------------------------------
    111          *
    112          * Function Name    : pit_init_freq
    113          * Returned Value   : None
    114          * Comments         : This function initializes the PIT frequence
    115          *
    116          *
    117          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    118          int8_t pit_init_freq
    119          (
    120              /* [IN] PIT index */
    121              uint8_t timer,
    122              /* [IN] Timer channel */
    123              uint8_t channel,
    124              /* [IN] Ticks per second */
    125              uint32_t tickfreq,
    126              /* [IN] Clock speed in Hz */
    127              uint32_t clk,
    128              /* [IN] Unmask the timer after initializing */
    129              bool unmask_timer
    130          )
    131          {
   \                     pit_init_freq: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    132             PIT_MemMapPtr pit_ptr = pit_get_base_address(timer);
   \   00000002   0xB928             CBNZ.N   R0,??pit_init_freq_0
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xDA03             BGE.N    ??pit_init_freq_0
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2B00             CMPNE    R3,#+0
   \   0000000E   0xD102             BNE.N    ??pit_init_freq_1
    133              if ((NULL == pit_ptr)||(channel > PIT_CHANNEL_MAX)||(0 == tickfreq)||(0 == clk))
    134              {
    135                  return PIT_INVALID_PARAM;
   \                     ??pit_init_freq_0: (+1)
   \   00000010   0xF04F 0x30FF      MOV      R0,#-1
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}
    136              }  
    137              /* Enable PIT Module Clock */
    138              SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
   \                     ??pit_init_freq_1: (+1)
   \   00000016   0x....             LDR.N    R4,??DataTable3_2  ;; 0x4004803c
   \   00000018   0x6825             LDR      R5,[R4, #+0]
   \   0000001A   0xF445 0x0500      ORR      R5,R5,#0x800000
   \   0000001E   0x6025             STR      R5,[R4, #+0]
    139              /* Enable PIT module */
    140              pit_ptr->MCR &= ~(PIT_MCR_FRZ_MASK |PIT_MCR_MDIS_MASK);
    141              /* Set counter reload value and counter value */
    142              pit_ptr->CHANNEL[channel].LDVAL = (uint16_t)(clk/tickfreq);
   \   00000020   0xFBB3 0xF2F2      UDIV     R2,R3,R2
   \   00000024   0x....             LDR.N    R4,??DataTable3  ;; 0x40037000
   \   00000026   0x6825             LDR      R5,[R4, #+0]
   \   00000028   0x08AD             LSRS     R5,R5,#+2
   \   0000002A   0xEB04 0x1001      ADD      R0,R4,R1, LSL #+4
   \   0000002E   0x00AD             LSLS     R5,R5,#+2
   \   00000030   0xF500 0x7080      ADD      R0,R0,#+256
   \   00000034   0x6025             STR      R5,[R4, #+0]
   \   00000036   0xB292             UXTH     R2,R2
   \   00000038   0x6002             STR      R2,[R0, #+0]
    143              /* Clear interrupt flag */
    144              pit_ptr->CHANNEL[channel].TFLG |= PIT_TFLG_TIF_MASK;
   \   0000003A   0x68C2             LDR      R2,[R0, #+12]
   \   0000003C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000040   0x60C2             STR      R2,[R0, #+12]
    145              if (unmask_timer)
   \   00000042   0x9804             LDR      R0,[SP, #+16]
   \   00000044   0xB110             CBZ.N    R0,??pit_init_freq_2
    146              {
    147                  /* Enable Timer Interrupt */
    148                  pit_unmask_int(timer,channel);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      BL       pit_unmask_int
    149              }
    150              return PIT_OK;
   \                     ??pit_init_freq_2: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    151          }
    152          
    153          /*FUNCTION*-------------------------------------------------------------------
    154          *
    155          * Function Name    : pit_mask_int
    156          * Returned Value   : None
    157          * Comments         : This function mask interrupt of given timer
    158          *
    159          *
    160          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    161          void pit_mask_int
    162          (
    163              /* [IN] Timer to use */
    164              uint8_t timer,
    165              /* [IN] Timer channel */
    166              uint8_t channel
    167          )
    168          {
    169              PIT_MemMapPtr pit_ptr = pit_get_base_address(timer);
   \                     pit_mask_int: (+1)
   \   00000000   0xB980             CBNZ.N   R0,??pit_mask_int_0
    170              if (NULL != pit_ptr)
    171              {
    172                  /* Disable Timer Interrupt */
    173                  pit_ptr->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_TEN_MASK;
   \   00000002   0x0108             LSLS     R0,R1,#+4
   \   00000004   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000008   0xF500 0x305C      ADD      R0,R0,#+225280
   \   0000000C   0xF8D0 0x1108      LDR      R1,[R0, #+264]
   \   00000010   0x0849             LSRS     R1,R1,#+1
   \   00000012   0x0049             LSLS     R1,R1,#+1
   \   00000014   0xF8C0 0x1108      STR      R1,[R0, #+264]
    174                  pit_ptr->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_TIE_MASK;
   \   00000018   0xF8D0 0x1108      LDR      R1,[R0, #+264]
   \   0000001C   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000020   0xF8C0 0x1108      STR      R1,[R0, #+264]
    175              }
    176          }
   \                     ??pit_mask_int_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    177          
    178          /*FUNCTION*-------------------------------------------------------------------
    179          *
    180          * Function Name    : pit_unmask_int
    181          * Returned Value   : None
    182          * Comments         : This function unmask interrupt of given timer
    183          *
    184          *
    185          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    186          void pit_unmask_int
    187          (
    188              /* [IN] Timer to use */
    189              uint8_t timer,
    190              /* [IN] Timer channel */
    191              uint8_t channel
    192          )
    193          {
    194              PIT_SET_TCTRL(PIT, channel, PIT_TCTRL_TEN_MASK);
   \                     pit_unmask_int: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40037100
   \   00000002   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    195              PIT_SET_TCTRL(PIT, channel, PIT_TCTRL_TIE_MASK);
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000014   0x6081             STR      R1,[R0, #+8]
    196          }
   \   00000016   0x4770             BX       LR               ;; return
    197          
    198          /*FUNCTION*-------------------------------------------------------------------
    199          *
    200          * Function Name    : pit_check_int_flag
    201          * Returned Value   : TRUE or FALSE
    202          * Comments         : This function checks timer interrupt flag
    203          *
    204          *
    205          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    206          bool pit_check_int_flag
    207          (
    208              /* [IN] Timer to use */
    209              uint8_t timer,
    210              /* [IN] Timer channel */
    211              uint8_t channel
    212          )
    213          {
    214              /* Get SPI module address */
    215              PIT_MemMapPtr pit_ptr = pit_get_base_address(timer);
   \                     pit_check_int_flag: (+1)
   \   00000000   0xB948             CBNZ.N   R0,??pit_check_int_flag_0
    216              if (NULL == pit_ptr)
    217              {
    218                  return FALSE;
    219              }
    220              return (((uint32_t)(pit_ptr->CHANNEL[channel].TFLG & PIT_TFLG_TIF_MASK)) ? TRUE : FALSE);  
   \   00000002   0x0108             LSLS     R0,R1,#+4
   \   00000004   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000008   0xF500 0x305C      ADD      R0,R0,#+225280
   \   0000000C   0xF8D0 0x010C      LDR      R0,[R0, #+268]
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0x4770             BX       LR
   \                     ??pit_check_int_flag_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    221          }
    222          
    223          /*FUNCTION*-------------------------------------------------------------------
    224          *
    225          * Function Name    : pit_clear_int
    226          * Returned Value   : None
    227          * Comments         : This function clear flag interrupt
    228          *
    229          *
    230          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    231          void pit_clear_int
    232          (
    233              /* [IN] Timer to use */
    234              uint8_t timer,
    235              /* [IN] Timer channel */
    236              uint8_t channel
    237          )
    238          {
    239              /* Get SPI module address */
    240              PIT_MemMapPtr pit_ptr = pit_get_base_address(timer);
   \                     pit_clear_int: (+1)
   \   00000000   0xB950             CBNZ.N   R0,??pit_clear_int_0
    241              if (NULL == pit_ptr)
    242              {
    243                  return;
    244              }
    245              /* Clear RTC Interrupt */
    246              pit_ptr->CHANNEL[channel].TFLG |= PIT_TFLG_TIF_MASK;  
   \   00000002   0x0108             LSLS     R0,R1,#+4
   \   00000004   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000008   0xF500 0x305C      ADD      R0,R0,#+225280
   \   0000000C   0xF8D0 0x110C      LDR      R1,[R0, #+268]
   \   00000010   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000014   0xF8C0 0x110C      STR      R1,[R0, #+268]
    247          
    248          }
   \                     ??pit_clear_int_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40037000         DC32     0x40037000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     pit_vectors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40037100         DC32     0x40037100
    249          /* EOF */
    250          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pit_check_int_flag
       0   pit_clear_int
       0   pit_get_base_address
       0   pit_get_vector
      16   pit_init_freq
        16   -> pit_unmask_int
       0   pit_mask_int
       0   pit_unmask_int


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  pit_address
      26  pit_check_int_flag
      26  pit_clear_int
      10  pit_get_base_address
      16  pit_get_vector
      80  pit_init_freq
      38  pit_mask_int
      24  pit_unmask_int
      16  pit_vectors

 
  20 bytes in section .data
 236 bytes in section .text
 
 236 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
