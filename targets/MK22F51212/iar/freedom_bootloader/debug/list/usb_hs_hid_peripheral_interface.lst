###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\usb_hs_hid_peripheral_interface.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\usb_hs_hid_peripheral_interface.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_hs_hid_peripheral_interface.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_hs_hid_peripheral_interface.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\usb_hs_hid_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader/context.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF000 0x021F      AND      R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10  ;; 0xe000e280
   \   0000000A   0x0940             LSRS     R0,R0,#+5
   \   0000000C   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000010   0x4770             BX       LR               ;; return
     32          #include "bootloader/bootloader.h"
     33          #include "bootloader_common.h"
     34          #include "device/fsl_device_registers.h"
     35          #include "usb_class_hid.h"
     36          #include "usb_device_stack_interface.h"
     37          #include "usb_hid.h"
     38          #include "bootloader_hid_report_ids.h"
     39          #include "usb_error.h"
     40          #include "utilities/fsl_rtos_abstraction.h"
     41          #include <string.h>
     42          #include "property/property.h"
     43          #include "usb_descriptor.h"
     44          #include "usb_class_hid.h"
     45          
     46          #if (BL_CONFIG_USB_HID || BL_CONFIG_HS_USB_HID)
     47          
     48          //! @addtogroup usb_hid_peripheral
     49          //! @{
     50          
     51          ////////////////////////////////////////////////////////////////////////////////
     52          // Definitions
     53          ////////////////////////////////////////////////////////////////////////////////
     54          #if !defined USBHS_INSTANCE_COUNT
     55          #define USBHS_INSTANCE_COUNT   (0)
     56          #endif
     57          
     58          #define REQ_DATA_SIZE     (1)
     59          
     60          //! @brief Request parameters.
     61          enum
     62          {
     63              kAppRequestParam_IdleRate = 0,
     64              kAppRequestParam_Protocol,
     65              kAppRequestParamCount
     66          };
     67          
     68          //! @brief State information for the USB HID packetizer.
     69          typedef struct _usb_hid_packetizer_info {
     70              bool isEnumerated;              //!< Whether the device has enumerated and is configured.
     71              bool didReceiveFirstReport;     //!< Whether the first report has been received.
     72              bool didReceiveDataPhaseAbort;  //!< Whether we received a data phase abort request.
     73              bool isReceiveDataRequestRequired;  //!< Whether an interrupt out pipe receive data request is required.
     74              uint8_t appRequestParams[kAppRequestParamCount];    //!< Storage for request parameter values.
     75              sync_object_t receiveSync;      //!< Sync object used for reading packets.
     76              sync_object_t sendSync;         //!< Sync object used for sending packets.
     77              uint32_t reportSize;            //!< The size in bytes of a received report. May be greater than the packet contained within the report plus the header, as the host can send up to the max report size bytes.
     78              bl_hid_report_t report;         //!< Buffer used to hold HID reports for sending and receiving.
     79              hid_handle_t app_handle;
     80          } usb_hid_packetizer_info_t;
     81          
     82          ////////////////////////////////////////////////////////////////////////////////
     83          // Prototypes
     84          ////////////////////////////////////////////////////////////////////////////////
     85          static void usb_hid_app_callback(uint8_t event_type, void* val, void* arg);
     86          static uint8_t usb_hid_app_param_callback(uint8_t request,
     87              uint16_t value,
     88              uint8_t** data,
     89              USB_PACKET_SIZE* size,
     90              void* arg
     91              );
     92          
     93          extern usb_desc_request_notify_struct_t g_desc_callback;
     94          
     95          static bool usb_hid_poll_for_activity(const peripheral_descriptor_t * self);
     96          static status_t usb_hid_full_init(const peripheral_descriptor_t * self, serial_byte_receive_func_t function);
     97          static void usb_hid_full_shutdown(const peripheral_descriptor_t * self);
     98          
     99          static status_t usb_hid_packet_init(const peripheral_descriptor_t * self);
    100          static status_t usb_hid_packet_read(const peripheral_descriptor_t * self, uint8_t ** packet, uint32_t * packetLength, packet_type_t packetType);
    101          static status_t usb_hid_packet_write(const peripheral_descriptor_t * self, const uint8_t * packet, uint32_t byteCount, packet_type_t packetType);
    102          static void usb_hid_packet_abort_data_phase(const peripheral_descriptor_t * self);
    103          static status_t usb_hid_packet_finalize(const peripheral_descriptor_t * self);
    104          static uint32_t usb_hid_packet_get_max_packet_size(const peripheral_descriptor_t * self);
    105          static void usb_hid_Periodic_Task (const peripheral_descriptor_t * self);
    106          
    107          ////////////////////////////////////////////////////////////////////////////////
    108          // Variables
    109          ////////////////////////////////////////////////////////////////////////////////
    110          

   \                                 In section .rodata, align 4, keep-with-next
    111          const peripheral_control_interface_t g_usbHidControlInterface = {
   \                     g_usbHidControlInterface:
   \   00000000   0x........         DC32 usb_hid_poll_for_activity, usb_hid_full_init
   \              0x........   
   \   00000008   0x........         DC32 usb_hid_full_shutdown, usb_hid_Periodic_Task
   \              0x........   
    112              .pollForActivity = usb_hid_poll_for_activity,
    113              .init = usb_hid_full_init,
    114              .shutdown = usb_hid_full_shutdown,
    115              .pump = usb_hid_Periodic_Task
    116          };
    117          

   \                                 In section .rodata, align 4, keep-with-next
    118          const peripheral_packet_interface_t g_usbHidPacketInterface = {
   \                     g_usbHidPacketInterface:
   \   00000000   0x........         DC32 usb_hid_packet_init, usb_hid_packet_read, usb_hid_packet_write
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 usb_hid_packet_abort_data_phase, usb_hid_packet_finalize
   \              0x........   
   \   00000014   0x........         DC32 usb_hid_packet_get_max_packet_size, 0H
   \              0x00000000   
    119              .init = usb_hid_packet_init,
    120              .readPacket = usb_hid_packet_read,
    121              .writePacket = usb_hid_packet_write,
    122              .abortDataPhase = usb_hid_packet_abort_data_phase,
    123              .finalize = usb_hid_packet_finalize,
    124              .getMaxPacketSize = usb_hid_packet_get_max_packet_size,
    125              .byteReceivedCallback = 0
    126          };
    127          
    128          //! @brief Current state of the USB HID packetizer.

   \                                 In section .bss, align 4
    129          static usb_hid_packetizer_info_t s_hidInfo[USB_INSTANCE_COUNT + USBHS_INSTANCE_COUNT];
   \                     s_hidInfo:
   \   00000000                      DS8 60
    130          //static usb_hid_packetizer_info_t s_hidInfo;
    131          
    132          ////////////////////////////////////////////////////////////////////////////////
    133          // Code
    134          ////////////////////////////////////////////////////////////////////////////////
    135          

   \                                 In section .text, align 2, keep-with-next
    136          uint32_t usb_get_instance_via_ipsr(void)
    137          {
    138          #if (USBHS_INSTANCE_COUNT == 0)  
    139              return USB_CONTROLLER_KHCI_0;
   \                     usb_get_instance_via_ipsr: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    140          #else      
    141              uint32_t vectorNum;
    142          
    143              __asm("mrs r0, ipsr\n"
    144                    "mov %0, r0" : "=r"(vectorNum));
    145          
    146              return (vectorNum==INT_USB0) ? USB_CONTROLLER_KHCI_0 : USB_CONTROLLER_EHCI_0;
    147          #endif    
    148          }
    149          

   \                                 In section .text, align 2, keep-with-next
    150          bool usb_hid_poll_for_activity(const peripheral_descriptor_t * self)
    151          {
    152              uint32_t hidInfoIndex = self->instance / 2;
   \                     usb_hid_poll_for_activity: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x0840             LSRS     R0,R0,#+1
    153              return s_hidInfo[hidInfoIndex].isEnumerated && s_hidInfo[hidInfoIndex].didReceiveFirstReport;
   \   00000004   0x213C             MOVS     R1,#+60
   \   00000006   0x4348             MULS     R0,R1,R0
   \   00000008   0x....             LDR.N    R1,??DataTable10_1
   \   0000000A   0x5C42             LDRB     R2,[R0, R1]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xBF1A             ITTE     NE 
   \   00000010   0x1840             ADDNE    R0,R0,R1
   \   00000012   0x7840             LDRBNE   R0,[R0, #+1]
   \   00000014   0x2000             MOVEQ    R0,#+0
   \   00000016   0x4770             BX       LR
    154          }
    155          
    156          /*!
    157           * @brief This function handles the callback
    158           *
    159           * This function is called from the class layer whenever reset occurs or enum
    160           * is complete. after the enum is complete this function sets a variable so
    161           * that the application can start
    162           *
    163           * @param event_type     value of the event
    164           * @param val            gives the configuration value
    165           * @param arg
    166           */

   \                                 In section .text, align 2, keep-with-next
    167          void usb_hid_app_callback(uint8_t event_type, void* val, void* arg)
    168          {
   \                     usb_hid_app_callback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    169              UNUSED_ARGUMENT(arg)
    170              UNUSED_ARGUMENT(val)
    171          
    172              uint32_t hidInfoIndex = usb_get_instance_via_ipsr() / 2;
    173          
    174              if ((event_type == USB_DEV_EVENT_BUS_RESET) ||
    175                  (event_type == USB_DEV_EVENT_CONFIG_CHANGED))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xBF18             IT       NE 
   \   00000006   0x2801             CMPNE    R0,#+1
   \   00000008   0x....             LDR.N    R4,??DataTable10_1
   \   0000000A   0xD102             BNE.N    ??usb_hid_app_callback_0
    176              {
    177                  s_hidInfo[hidInfoIndex].isEnumerated = false;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x8020             STRH     R0,[R4, #+0]
    178                  s_hidInfo[hidInfoIndex].didReceiveFirstReport = false;
    179              }
    180              else if (event_type == USB_DEV_EVENT_ENUM_COMPLETE)
    181              {
    182                  // Enumeration is complete.
    183                  s_hidInfo[hidInfoIndex].isEnumerated = true;
    184                  USB_Class_HID_Recv_Data(s_hidInfo[hidInfoIndex].app_handle,
    185                                        HID_OUT_ENDPOINT,
    186                                       (uint8_t *)&s_hidInfo[hidInfoIndex].report.header,
    187                                       sizeof(s_hidInfo[hidInfoIndex].report));
    188              }
    189              else if (event_type == USB_DEV_EVENT_ERROR)
    190              {
    191                      /* user may add code here for error handling
    192                         NOTE : val has the value of error from h/w*/
    193                  return;
    194              }
    195          
    196              return;
   \                     ??usb_hid_app_callback_1: (+1)
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   \                     ??usb_hid_app_callback_0: (+1)
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD1FC             BNE.N    ??usb_hid_app_callback_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7020             STRB     R0,[R4, #+0]
   \   0000001A   0xF104 0x0214      ADD      R2,R4,#+20
   \   0000001E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x2324             MOVS     R3,#+36
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x.... 0x....      B.W      USB_Class_HID_Recv_Data
    197          }
    198          
    199          /******************************************************************************
    200           *
    201           *    @name        usb_hid_app_param_callback
    202           *
    203           *    @brief       This function handles the callback for Get/Set report req
    204           *
    205           * This function is called whenever a HID class request is received. This
    206           * function handles these class requests
    207           *    @param       request  :  request type
    208           *    @param       value    :  give report type and id
    209           *    @param       data     :  pointer to the data
    210           *    @param       size     :  size of the transfer
    211           *
    212           *    @return      status
    213           *                  USB_OK  :  if successful
    214           *                  else return error
    215           *
    216           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    217          uint8_t usb_hid_app_param_callback(
    218              uint8_t request,
    219              uint16_t value,
    220              uint8_t** data,
    221              USB_PACKET_SIZE* size,
    222              void* arg
    223              )
    224          {
   \                     usb_hid_app_param_callback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
    225              UNUSED_ARGUMENT(arg)
    226          
    227              uint8_t status = USB_OK;
    228              uint8_t index = (uint8_t)((request - 2) & USB_HID_REQUEST_TYPE_MASK);
    229              USB_PACKET_SIZE incomingSize = * size;
   \   00000004   0x681E             LDR      R6,[R3, #+0]
    230              const bl_hid_header_t * header;
    231          
    232              uint32_t hidInfoIndex = usb_get_instance_via_ipsr() / 2;
    233          
    234              if (request == USB_DEV_EVENT_SEND_COMPLETE)
   \   00000006   0x....             LDR.N    R4,??DataTable10_1
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000000E   0xD10B             BNE.N    ??usb_hid_app_param_callback_0
    235              {
    236                  usb_event_struct_t * event = (usb_event_struct_t *)data;
    237                  if ((event->len == 0xFFFFFFFF) || (event->len == 0x0))
   \   00000010   0x68A8             LDR      R0,[R5, #+8]
   \   00000012   0xF110 0x0F01      CMN      R0,#+1
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2800             CMPNE    R0,#+0
   \   0000001A   0xD049             BEQ.N    ??usb_hid_app_param_callback_1
    238                  {
    239                      // Transfer failure
    240                      return status;
    241                  }
    242                  
    243                  // Protect against extra complete due to data abort.
    244                  if (s_hidInfo[hidInfoIndex].sendSync > 0)
   \   0000001C   0x68E0             LDR      R0,[R4, #+12]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xDB46             BLT.N    ??usb_hid_app_param_callback_1
    245                  {
    246                      // Signal that write has completed.
    247                      sync_signal(&s_hidInfo[hidInfoIndex].sendSync);
   \   00000022   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000026   0xE039             B.N      ??usb_hid_app_param_callback_2
    248                  }
    249                  return status;
    250              }
    251              else if (request == USB_DEV_EVENT_DATA_RECEIVED)
   \                     ??usb_hid_app_param_callback_0: (+1)
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD107             BNE.N    ??usb_hid_app_param_callback_3
    252              {
    253                  // Save the report size.
    254                  usb_event_struct_t * event = (usb_event_struct_t *)data;
    255                  if ((event->len == 0xFFFFFFFF) || (event->len == 0x0))
   \   0000002C   0x68A8             LDR      R0,[R5, #+8]
   \   0000002E   0xF110 0x0F01      CMN      R0,#+1
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x2800             CMPNE    R0,#+0
   \   00000036   0xD03B             BEQ.N    ??usb_hid_app_param_callback_1
    256                  {
    257                      // Transfer failure
    258                      return status;
    259                  }
    260                  
    261                  s_hidInfo[hidInfoIndex].reportSize = event->len;
   \   00000038   0x6120             STR      R0,[R4, #+16]
    262          
    263                  s_hidInfo[hidInfoIndex].didReceiveFirstReport = true;
   \   0000003A   0xE02B             B.N      ??usb_hid_app_param_callback_4
    264          
    265                  // Wake up the read packet handler.
    266                  sync_signal(&s_hidInfo[hidInfoIndex].receiveSync);
    267                  return status;
    268              }
    269          
    270              // Set default return size of 0.
    271              *size = 0;
    272          
    273              // handle the class request
    274              switch (request)
   \                     ??usb_hid_app_param_callback_3: (+1)
   \   0000003C   0x1912             ADDS     R2,R2,R4
   \   0000003E   0x2700             MOVS     R7,#+0
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0x601F             STR      R7,[R3, #+0]
   \   00000044   0xD00B             BEQ.N    ??usb_hid_app_param_callback_5
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xBF18             IT       NE 
   \   0000004A   0x2803             CMPNE    R0,#+3
   \   0000004C   0xD02C             BEQ.N    ??usb_hid_app_param_callback_6
   \   0000004E   0x2809             CMP      R0,#+9
   \   00000050   0xD00E             BEQ.N    ??usb_hid_app_param_callback_7
   \   00000052   0x280A             CMP      R0,#+10
   \   00000054   0xD025             BEQ.N    ??usb_hid_app_param_callback_8
   \   00000056   0x280B             CMP      R0,#+11
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0x7111             STRBEQ   R1,[R2, #+4]
    275              {
    276                  case USB_HID_GET_REPORT_REQUEST:
    277                      // Send an empty report. The host should only be reading reports via the interrupt pipe.
    278                      memset(&s_hidInfo[hidInfoIndex].report, 0, sizeof(s_hidInfo[hidInfoIndex].report));
    279                      *data = (uint8_t *)&s_hidInfo[hidInfoIndex].report.header; // point to the report to send
    280                      // size is set to 0 above
    281                      break;
    282          
    283                  case USB_HID_SET_REPORT_REQUEST:
    284                      // Check for data phase abort packet.
    285                      header = (bl_hid_header_t *)*data;
    286                      if ((header->packetLengthLsb == 0) &&
    287                          (header->packetLengthMsb == 0) &&
    288                          (header->reportID == kBootloaderReportID_CommandOut))
    289                      {
    290                          s_hidInfo[hidInfoIndex].didReceiveDataPhaseAbort = true;
    291                          break;
    292                      }
    293          
    294                      // Copy the report data into our local buffer.
    295                      memcpy(&s_hidInfo[hidInfoIndex].report.header, *data, incomingSize);
    296          
    297                      // Save the report size.
    298                      s_hidInfo[hidInfoIndex].reportSize = incomingSize;
    299          
    300                      // Remember that we received a report.
    301                      s_hidInfo[hidInfoIndex].didReceiveFirstReport = true;
    302          
    303                      // Wake up the read packet handler.
    304                      sync_signal(&s_hidInfo[hidInfoIndex].receiveSync);
    305                      break;
    306          
    307                  case USB_HID_GET_IDLE_REQUEST:
    308                      // point to the current idle rate
    309                      *data = &s_hidInfo[hidInfoIndex].appRequestParams[index];
    310                      *size = REQ_DATA_SIZE;
    311                      break;
    312          
    313                  case USB_HID_SET_IDLE_REQUEST:
    314                      // set the idle rate sent by the host
    315                      s_hidInfo[hidInfoIndex].appRequestParams[index] = (uint8_t)((value & MSB_MASK) >> HIGH_BYTE_SHIFT);
    316                      break;
    317          
    318                  case USB_HID_GET_PROTOCOL_REQUEST:
    319                      // point to the current protocol code
    320                      //  0 = Boot Protocol
    321                      //  1 = Report Protocol
    322                      *data = &s_hidInfo[hidInfoIndex].appRequestParams[index];
    323                      *size = REQ_DATA_SIZE;
    324                      break;
    325          
    326                  case USB_HID_SET_PROTOCOL_REQUEST:
    327                      // set the protocol sent by the host
    328                      //      0 = Boot Protocol
    329                      //      1 = Report Protocol
    330                      s_hidInfo[hidInfoIndex].appRequestParams[index] = (uint8_t)(value);
   \   0000005C   0xE028             B.N      ??usb_hid_app_param_callback_1
   \                     ??usb_hid_app_param_callback_5: (+1)
   \   0000005E   0x2124             MOVS     R1,#+36
   \   00000060   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000064   0x.... 0x....      BL       __aeabi_memclr4
   \   00000068   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000006C   0x6028             STR      R0,[R5, #+0]
   \   0000006E   0xE01F             B.N      ??usb_hid_app_param_callback_1
   \                     ??usb_hid_app_param_callback_7: (+1)
   \   00000070   0x6829             LDR      R1,[R5, #+0]
   \   00000072   0x788A             LDRB     R2,[R1, #+2]
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xBF04             ITT      EQ 
   \   00000078   0x78CA             LDRBEQ   R2,[R1, #+3]
   \   0000007A   0x2A00             CMPEQ    R2,#+0
   \   0000007C   0xD104             BNE.N    ??usb_hid_app_param_callback_9
   \   0000007E   0x7808             LDRB     R0,[R1, #+0]
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xBF08             IT       EQ 
   \   00000084   0x70A0             STRBEQ   R0,[R4, #+2]
   \   00000086   0xD013             BEQ.N    ??usb_hid_app_param_callback_1
   \                     ??usb_hid_app_param_callback_9: (+1)
   \   00000088   0x4632             MOV      R2,R6
   \   0000008A   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000008E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000092   0x6126             STR      R6,[R4, #+16]
   \                     ??usb_hid_app_param_callback_4: (+1)
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x7060             STRB     R0,[R4, #+1]
   \   00000098   0xF104 0x0008      ADD      R0,R4,#+8
   \                     ??usb_hid_app_param_callback_2: (+1)
   \   0000009C   0x.... 0x....      BL       sync_signal
   \   000000A0   0xE006             B.N      ??usb_hid_app_param_callback_1
   \                     ??usb_hid_app_param_callback_8: (+1)
   \   000000A2   0x0A08             LSRS     R0,R1,#+8
   \   000000A4   0x7110             STRB     R0,[R2, #+4]
   \   000000A6   0xE003             B.N      ??usb_hid_app_param_callback_1
   \                     ??usb_hid_app_param_callback_6: (+1)
   \   000000A8   0x1D10             ADDS     R0,R2,#+4
   \   000000AA   0x6028             STR      R0,[R5, #+0]
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x6018             STR      R0,[R3, #+0]
    331                      break;
    332                  default:
    333                      break;
    334              }
    335          
    336              return status;
   \                     ??usb_hid_app_param_callback_1: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    337          }
    338          

   \                                 In section .text, align 2, keep-with-next
    339          status_t usb_hid_full_init(const peripheral_descriptor_t * self, serial_byte_receive_func_t function)
    340          {
   \                     usb_hid_full_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB088             SUB      SP,SP,#+32
    341              // Not used for USB
    342              (void)function;
    343          
    344              uint32_t hidInfoIndex = self->instance / 2;
   \   00000006   0x6860             LDR      R0,[R4, #+4]
    345          
    346              // Init the state info.
    347              memset(&s_hidInfo[hidInfoIndex], 0, sizeof(s_hidInfo[hidInfoIndex]));
   \   00000008   0x....             LDR.N    R1,??DataTable10_1
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x223C             MOVS     R2,#+60
   \   0000000E   0xFB02 0x1500      MLA      R5,R2,R0,R1
   \   00000012   0x213C             MOVS     R1,#+60
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       __aeabi_memclr
    348          
    349              //Init the usb clock, if usb clock cannot be enabled, clear corresponding bit even it is enabled by user.
    350              if(!usb_clock_init())
   \   0000001A   0x.... 0x....      BL       usb_clock_init
   \   0000001E   0x....             LDR.N    R6,??DataTable10_2
   \   00000020   0xB978             CBNZ.N   R0,??usb_hid_full_init_0
   \   00000022   0x68B0             LDR      R0,[R6, #+8]
   \   00000024   0x6900             LDR      R0,[R0, #+16]
   \   00000026   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \   0000002A   0xF001 0x01EF      AND      R1,R1,#0xEF
   \   0000002E   0xF880 0x1080      STRB     R1,[R0, #+128]
   \   00000032   0x68B0             LDR      R0,[R6, #+8]
   \   00000034   0x6900             LDR      R0,[R0, #+16]
   \   00000036   0x68C1             LDR      R1,[R0, #+12]
   \   00000038   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000003C   0x60C1             STR      R1,[R0, #+12]
    351              {
    352                  g_bootloaderContext.propertyInterface->store->configurationData.enabledPeripherals &= ~kPeripheralType_USB_HID;
    353                  g_bootloaderContext.propertyInterface->store->availablePeripherals &= ~kPeripheralType_USB_HID;
    354                  return kStatus_Fail;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE038             B.N      ??usb_hid_full_init_1
    355              }
    356          
    357              if (self->instance == USB_CONTROLLER_KHCI_0)
   \                     ??usb_hid_full_init_0: (+1)
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0xB930             CBNZ.N   R0,??usb_hid_full_init_2
    358              {
    359                  // Clear any pending interrupts on USB
    360                  NVIC_ClearPendingIRQ(USB0_IRQn);
   \   00000046   0x2035             MOVS     R0,#+53
   \   00000048   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    361          
    362                  // Enable interrupts from USB module
    363                  NVIC_EnableIRQ(USB0_IRQn);
   \   0000004C   0x....             LDR.N    R1,??DataTable10_3  ;; 0xe000e104
   \   0000004E   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000052   0x6008             STR      R0,[R1, #+0]
    364              }
    365          #if USBCFG_DEV_EHCI     
    366              else if (self->instance == USB_CONTROLLER_EHCI_0)
    367              {
    368                  // Clear any pending interrupts on USB
    369                  NVIC_ClearPendingIRQ(USBHS_IRQn);
    370          
    371                  // Enable interrupts from USB module
    372                  NVIC_EnableIRQ(USBHS_IRQn);
    373              }
    374          #endif
    375              property_store_t * propertyStore = g_bootloaderContext.propertyInterface->store;
    376          
    377              if(( propertyStore->configurationData.usbPid != (uint16_t)0xFFFF )||( propertyStore->configurationData.usbVid != (uint16_t)0xFFFF))
   \                     ??usb_hid_full_init_2: (+1)
   \   00000054   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000058   0x68B0             LDR      R0,[R6, #+8]
   \   0000005A   0x6900             LDR      R0,[R0, #+16]
   \   0000005C   0xF830 0x1F84      LDRH     R1,[R0, #+132]!
   \   00000060   0x8843             LDRH     R3,[R0, #+2]
   \   00000062   0x4293             CMP      R3,R2
   \   00000064   0xBF08             IT       EQ 
   \   00000066   0x4291             CMPEQ    R1,R2
   \   00000068   0xD009             BEQ.N    ??usb_hid_full_init_3
    378              {
    379                  g_device_descriptor[kUsbDescriptorIndex_VidLow] = ((propertyStore->configurationData.usbVid)&0xFF);
   \   0000006A   0x....             LDR.N    R2,??DataTable10_4
   \   0000006C   0x7211             STRB     R1,[R2, #+8]
    380                  g_device_descriptor[kUsbDescriptorIndex_VidHigh] = ((propertyStore->configurationData.usbVid)&0xFF00)>>8;
   \   0000006E   0x8801             LDRH     R1,[R0, #+0]
   \   00000070   0x0A09             LSRS     R1,R1,#+8
   \   00000072   0x7251             STRB     R1,[R2, #+9]
    381                  g_device_descriptor[kUsbDescriptorIndex_PidLow] = ((propertyStore->configurationData.usbPid)&0xFF);
   \   00000074   0x8841             LDRH     R1,[R0, #+2]
   \   00000076   0x7291             STRB     R1,[R2, #+10]
    382                  g_device_descriptor[kUsbDescriptorIndex_PidHigh] = ((propertyStore->configurationData.usbPid)&0xFF00)>>8;
   \   00000078   0x8841             LDRH     R1,[R0, #+2]
   \   0000007A   0x0A09             LSRS     R1,R1,#+8
   \   0000007C   0x72D1             STRB     R1,[R2, #+11]
    383              }
    384          
    385              if( propertyStore->configurationData.usbStringsPointer !=0xFFFFFFFF)
    386              {
    387                  g_lang_ptr = (struct _USB_ALL_LANGUAGES *)propertyStore->configurationData.usbStringsPointer;
    388              }
    389              else
    390              {
    391                  g_lang_ptr = &g_languages;
    392              }
    393          
    394              // Init HID class driver.
    395              hid_config_struct_t hidConfig;
    396              hidConfig.hid_application_callback.callback = usb_hid_app_callback;
    397              hidConfig.hid_application_callback.arg = &s_hidInfo[hidInfoIndex].app_handle;
    398              hidConfig.class_specific_callback.callback = usb_hid_app_param_callback;
    399              hidConfig.class_specific_callback.arg = &s_hidInfo[hidInfoIndex].app_handle;
    400              hidConfig.desc_callback_ptr = &g_desc_callback;
    401          
    402              uint8_t status = USB_Class_HID_Init(self->instance, &hidConfig, &s_hidInfo[hidInfoIndex].app_handle);
   \                     ??usb_hid_full_init_3: (+1)
   \   0000007E   0xF105 0x0238      ADD      R2,R5,#+56
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \   00000084   0x....             LDR.N    R1,??DataTable10_5
   \   00000086   0xF110 0x0F01      CMN      R0,#+1
   \   0000008A   0xBF08             IT       EQ 
   \   0000008C   0x....             LDREQ.N  R0,??DataTable10_6
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   \   00000090   0x4669             MOV      R1,SP
   \   00000092   0x....             LDR.N    R0,??DataTable10_7
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0xF105 0x0038      ADD      R0,R5,#+56
   \   0000009A   0x9001             STR      R0,[SP, #+4]
   \   0000009C   0x....             LDR.N    R0,??DataTable10_8
   \   0000009E   0x9004             STR      R0,[SP, #+16]
   \   000000A0   0xF105 0x0038      ADD      R0,R5,#+56
   \   000000A4   0x9005             STR      R0,[SP, #+20]
   \   000000A6   0x....             LDR.N    R0,??DataTable10_9
   \   000000A8   0x9006             STR      R0,[SP, #+24]
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0xB2C0             UXTB     R0,R0
   \   000000AE   0x.... 0x....      BL       USB_Class_HID_Init
    403          
    404              return kStatus_Success;
   \   000000B2   0x2000             MOVS     R0,#+0
   \                     ??usb_hid_full_init_1: (+1)
   \   000000B4   0xB008             ADD      SP,SP,#+32
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
    405          }
    406          

   \                                 In section .text, align 2, keep-with-next
    407          void usb_hid_full_shutdown(const peripheral_descriptor_t * self)
    408          {
   \                     usb_hid_full_shutdown: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    409              uint32_t hidInfoIndex = self->instance / 2;
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x0844             LSRS     R4,R0,#+1
    410          
    411              // Make sure we are clocking to the peripheral to ensure there
    412              // are no bus errors
    413              if ((self->instance == USB_CONTROLLER_KHCI_0) && (SIM_SCGC4 & SIM_SCGC4_USBOTG_MASK))
   \   00000006   0xB9A8             CBNZ.N   R0,??usb_hid_full_shutdown_0
   \   00000008   0x....             LDR.N    R5,??DataTable10_10  ;; 0x40048034
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x0340             LSLS     R0,R0,#+13
   \   0000000E   0xD511             BPL.N    ??usb_hid_full_shutdown_0
    414              {
    415                  // Disable the USB interrupt
    416                  NVIC_DisableIRQ(USB0_IRQn);
   \   00000010   0x....             LDR.N    R1,??DataTable10_11  ;; 0xe000e184
   \   00000012   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000016   0x6008             STR      R0,[R1, #+0]
    417          
    418                  // Clear any pending interrupts on USB
    419                  NVIC_ClearPendingIRQ(USB0_IRQn);
   \   00000018   0x2035             MOVS     R0,#+53
   \   0000001A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    420          
    421                  // Shutdown class driver
    422                  USB_Class_HID_Deinit(s_hidInfo[hidInfoIndex].app_handle);
   \   0000001E   0x....             LDR.N    R0,??DataTable10_1
   \   00000020   0x213C             MOVS     R1,#+60
   \   00000022   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000026   0x6B80             LDR      R0,[R0, #+56]
   \   00000028   0x.... 0x....      BL       USB_Class_HID_Deinit
    423          
    424                  // Turn off clocking to USB
    425                  SIM_SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0xF420 0x2080      BIC      R0,R0,#0x40000
   \   00000032   0x6028             STR      R0,[R5, #+0]
    426              }
    427          #if USBCFG_DEV_EHCI   
    428              else if ((self->instance == USB_CONTROLLER_EHCI_0) && (SIM_SCGC3 & SIM_SCGC3_USBHS_MASK))
    429              {
    430                  // Disable the USB interrupt
    431                  NVIC_DisableIRQ(USBHS_IRQn);
    432          
    433                  // Clear any pending interrupts on USB
    434                  NVIC_ClearPendingIRQ(USBHS_IRQn);
    435          
    436                  // Shutdown class driver
    437                  USB_Class_HID_Deinit(s_hidInfo[hidInfoIndex].app_handle);
    438          
    439                  // Turn off HS USB PHY clock gate
    440                  SIM_SCGC3 &= ~(SIM_SCGC3_USBHS_MASK | SIM_SCGC3_USBHSPHY_MASK);
    441              }
    442          #endif    
    443          }
   \                     ??usb_hid_full_shutdown_0: (+1)
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    444          

   \                                 In section .text, align 2, keep-with-next
    445          static status_t usb_hid_packet_init(const peripheral_descriptor_t * self)
    446          {
   \                     usb_hid_packet_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    447              uint32_t hidInfoIndex = self->instance / 2;
   \   00000002   0x6840             LDR      R0,[R0, #+4]
    448          
    449              sync_init(&s_hidInfo[hidInfoIndex].receiveSync, false);
   \   00000004   0x....             LDR.N    R1,??DataTable10_1
   \   00000006   0x0840             LSRS     R0,R0,#+1
   \   00000008   0x223C             MOVS     R2,#+60
   \   0000000A   0xFB02 0x1400      MLA      R4,R2,R0,R1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000014   0x.... 0x....      BL       sync_init
    450              sync_init(&s_hidInfo[hidInfoIndex].sendSync, false);
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xF104 0x000C      ADD      R0,R4,#+12
   \   0000001E   0x.... 0x....      BL       sync_init
    451          
    452              // Check for any received data that may be pending
    453              sync_signal(&s_hidInfo[hidInfoIndex].receiveSync);
   \   00000022   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000026   0x.... 0x....      BL       sync_signal
    454          
    455              return kStatus_Success;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    456          }
    457          

   \                                 In section .text, align 2, keep-with-next
    458          static status_t usb_hid_packet_read(const peripheral_descriptor_t * self, uint8_t ** packet, uint32_t * packetLength, packet_type_t packetType)
    459          {
   \                     usb_hid_packet_read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    460              uint32_t hidInfoIndex = self->instance / 2;
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x0840             LSRS     R0,R0,#+1
   \   00000008   0x4615             MOV      R5,R2
    461          
    462              if (!packet || !packetLength)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2D00             CMPNE    R5,#+0
   \   00000010   0xD101             BNE.N    ??usb_hid_packet_read_0
    463              {
    464                  debug_printf("Error: invalid packet\r\n");
    465                  return kStatus_InvalidArgument;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    466              }
    467              *packetLength = 0;
   \                     ??usb_hid_packet_read_0: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6029             STR      R1,[R5, #+0]
    468          
    469              // Determine report ID based on packet type.
    470              uint8_t reportID;
    471              switch (packetType)
   \   0000001A   0xB113             CBZ.N    R3,??usb_hid_packet_read_1
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD01E             BEQ.N    ??usb_hid_packet_read_2
   \   00000020   0xE027             B.N      ??usb_hid_packet_read_3
    472              {
    473                  case kPacketType_Command:
    474                      reportID = kBootloaderReportID_CommandOut;
   \                     ??usb_hid_packet_read_1: (+1)
   \   00000022   0x2601             MOVS     R6,#+1
    475                      break;
    476                  case kPacketType_Data:
    477                      reportID = kBootloaderReportID_DataOut;
    478                      break;
    479                  default:
    480                      debug_printf("usbhid: unsupported packet type %d\r\n", (int)packetType);
    481                      return kStatus_Fail;
    482              };
    483          
    484              // The first receive data request was initiated after enumeration.
    485              // After that we wait until we are ready to read data before
    486              // we request more. This mechanism prevents data loss
    487              // by allowing the USB controller to hold off the host with NAKs
    488              // on the interrupt out pipe until we are ready.
    489              if (s_hidInfo[hidInfoIndex].isReceiveDataRequestRequired)
   \                     ??usb_hid_packet_read_4: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable10_1
   \   00000026   0x223C             MOVS     R2,#+60
   \   00000028   0xFB02 0x1700      MLA      R7,R2,R0,R1
   \   0000002C   0x78F8             LDRB     R0,[R7, #+3]
   \   0000002E   0xB130             CBZ.N    R0,??usb_hid_packet_read_5
    490              {
    491                  // Initiate receive on interrupt out pipe.
    492                  USB_Class_HID_Recv_Data(s_hidInfo[hidInfoIndex].app_handle,
    493                                        HID_OUT_ENDPOINT,
    494                                       (uint8_t *)&s_hidInfo[hidInfoIndex].report.header,
    495                                       sizeof(s_hidInfo[hidInfoIndex].report));
   \   00000030   0x6BB8             LDR      R0,[R7, #+56]
   \   00000032   0x2324             MOVS     R3,#+36
   \   00000034   0xF107 0x0214      ADD      R2,R7,#+20
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x.... 0x....      BL       USB_Class_HID_Recv_Data
    496              }
    497              s_hidInfo[hidInfoIndex].isReceiveDataRequestRequired = true;
   \                     ??usb_hid_packet_read_5: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x70F8             STRB     R0,[R7, #+3]
    498          
    499              // Wait until we have received a report.
    500              sync_wait(&s_hidInfo[hidInfoIndex].receiveSync, kSyncWaitForever);
   \   00000042   0xF04F 0x31FF      MOV      R1,#-1
   \   00000046   0xF107 0x0008      ADD      R0,R7,#+8
   \   0000004A   0x.... 0x....      BL       sync_wait
    501          
    502              // Check the report ID, the first byte of the report buffer.
    503              if (s_hidInfo[hidInfoIndex].report.header.reportID != reportID)
   \   0000004E   0x7D38             LDRB     R0,[R7, #+20]
   \   00000050   0x42B0             CMP      R0,R6
   \   00000052   0xD006             BEQ.N    ??usb_hid_packet_read_6
    504              {
    505                  // If waiting for a command but get data, this is a flush after a data abort.
    506                  if ((reportID == kBootloaderReportID_CommandOut) &&
    507                      (s_hidInfo[hidInfoIndex].report.header.reportID == kBootloaderReportID_DataOut))
   \   00000054   0x2E01             CMP      R6,#+1
   \   00000056   0xBF08             IT       EQ 
   \   00000058   0x2802             CMPEQ    R0,#+2
   \   0000005A   0xD10A             BNE.N    ??usb_hid_packet_read_3
    508                  {
    509                      return kStatus_AbortDataPhase;
   \   0000005C   0x....             B.N      ?Subroutine0
    510                  }
    511                  debug_printf("usbhid: received unexpected report=%x\r\n", s_hidInfo[hidInfoIndex].report.header.reportID);
    512                  return kStatus_Fail;
    513              }
   \                     ??usb_hid_packet_read_2: (+1)
   \   0000005E   0x2602             MOVS     R6,#+2
   \   00000060   0xE7E0             B.N      ??usb_hid_packet_read_4
    514          
    515              // Extract the packet length encoded as bytes 1 and 2 of the report. The packet length
    516              // is transferred in little endian byte order.
    517              uint16_t lengthOfPacket = s_hidInfo[hidInfoIndex].report.header.packetLengthLsb
    518                                          | (s_hidInfo[hidInfoIndex].report.header.packetLengthMsb << 8);
   \                     ??usb_hid_packet_read_6: (+1)
   \   00000062   0x7DB8             LDRB     R0,[R7, #+22]
   \   00000064   0x7DF9             LDRB     R1,[R7, #+23]
   \   00000066   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    519          
    520              // Make sure we got all of the packet. Some hosts (Windows) may send up to the maximum
    521              // report size, so there may be extra trailing bytes.
    522              if ((s_hidInfo[hidInfoIndex].reportSize - sizeof(s_hidInfo[hidInfoIndex].report.header)) < lengthOfPacket)
   \   0000006A   0x6939             LDR      R1,[R7, #+16]
   \   0000006C   0x1F09             SUBS     R1,R1,#+4
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xD201             BCS.N    ??usb_hid_packet_read_7
    523              {
    524                  debug_printf("usbhid: received only %d bytes of packet with length %d\r\n", s_hidInfo[hidInfoIndex].reportSize - 3, lengthOfPacket);
    525                  return kStatus_Fail;
   \                     ??usb_hid_packet_read_3: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}
    526              }
    527          
    528              // Return packet to caller.
    529              *packet = s_hidInfo[hidInfoIndex].report.packet;
   \                     ??usb_hid_packet_read_7: (+1)
   \   00000076   0xF107 0x0118      ADD      R1,R7,#+24
   \   0000007A   0x6021             STR      R1,[R4, #+0]
    530              *packetLength = lengthOfPacket;
   \   0000007C   0x6028             STR      R0,[R5, #+0]
    531          
    532              return kStatus_Success;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    533          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF242 0x7012      MOVW     R0,#+10002
   \   00000004   0xBDF2             POP      {R1,R4-R7,PC}
    534          

   \                                 In section .text, align 2, keep-with-next
    535          static status_t usb_hid_packet_write(const peripheral_descriptor_t * self, const uint8_t * packet, uint32_t byteCount, packet_type_t packetType)
    536          {
   \                     usb_hid_packet_write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    537              uint32_t hidInfoIndex = self->instance / 2;
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x0846             LSRS     R6,R0,#+1
    538          
    539              if (byteCount > kMinPacketBufferSize)
   \   00000008   0x2D21             CMP      R5,#+33
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0xD301             BCC.N    ??usb_hid_packet_write_0
    540              {
    541                  debug_printf("Error: invalid packet size %d\r\n", byteCount);
    542                  return kStatus_InvalidArgument;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}
    543              }
    544          
    545              // Determine report ID based on packet type.
    546              uint8_t reportID;
    547              switch (packetType)
   \                     ??usb_hid_packet_write_0: (+1)
   \   00000012   0xB113             CBZ.N    R3,??usb_hid_packet_write_1
   \   00000014   0x2B01             CMP      R3,#+1
   \   00000016   0xD00E             BEQ.N    ??usb_hid_packet_write_2
   \   00000018   0xE00F             B.N      ??usb_hid_packet_write_3
    548              {
    549                  case kPacketType_Command:
    550                      reportID = kBootloaderReportID_CommandIn;
   \                     ??usb_hid_packet_write_1: (+1)
   \   0000001A   0x2703             MOVS     R7,#+3
    551                      break;
    552                  case kPacketType_Data:
    553                      reportID = kBootloaderReportID_DataIn;
    554                      break;
    555                  default:
    556                      debug_printf("usbhid: unsupported packet type %d\r\n", (int)packetType);
    557                      return kStatus_Fail;
    558              };
    559          
    560              // Check for data phase aborted by receiver.
    561              lock_acquire();
   \                     ??usb_hid_packet_write_4: (+1)
   \   0000001C   0x.... 0x....      BL       lock_acquire
    562              if (s_hidInfo[hidInfoIndex].didReceiveDataPhaseAbort)
   \   00000020   0x....             LDR.N    R0,??DataTable10_1
   \   00000022   0x213C             MOVS     R1,#+60
   \   00000024   0xFB01 0x0606      MLA      R6,R1,R6,R0
   \   00000028   0x78B0             LDRB     R0,[R6, #+2]
   \   0000002A   0xB140             CBZ.N    R0,??usb_hid_packet_write_5
    563              {
    564                  s_hidInfo[hidInfoIndex].didReceiveDataPhaseAbort = false;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x70B0             STRB     R0,[R6, #+2]
    565                  lock_release();
   \   00000030   0x.... 0x....      BL       lock_release
    566                  return kStatus_AbortDataPhase;
   \   00000034   0x....             B.N      ?Subroutine0
    567              }
   \                     ??usb_hid_packet_write_2: (+1)
   \   00000036   0x2704             MOVS     R7,#+4
   \   00000038   0xE7F0             B.N      ??usb_hid_packet_write_4
   \                     ??usb_hid_packet_write_3: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}
    568              lock_release();
   \                     ??usb_hid_packet_write_5: (+1)
   \   0000003E   0x.... 0x....      BL       lock_release
    569          
    570              // Construct report contents.
    571              s_hidInfo[hidInfoIndex].report.header.reportID = reportID;
    572              s_hidInfo[hidInfoIndex].report.header._padding = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7570             STRB     R0,[R6, #+21]
   \   00000046   0x7537             STRB     R7,[R6, #+20]
    573              s_hidInfo[hidInfoIndex].report.header.packetLengthLsb = byteCount & 0xff;
    574              s_hidInfo[hidInfoIndex].report.header.packetLengthMsb = (byteCount >> 8) & 0xff;
   \   00000048   0x0A28             LSRS     R0,R5,#+8
   \   0000004A   0x75B5             STRB     R5,[R6, #+22]
   \   0000004C   0x75F0             STRB     R0,[R6, #+23]
    575              if (packet && byteCount > 0)
   \   0000004E   0x2C00             CMP      R4,#+0
   \   00000050   0xBF18             IT       NE 
   \   00000052   0x2D00             CMPNE    R5,#+0
   \   00000054   0xD005             BEQ.N    ??usb_hid_packet_write_6
    576              {
    577                  memcpy(&s_hidInfo[hidInfoIndex].report.packet, packet, byteCount);
   \   00000056   0x462A             MOV      R2,R5
   \   00000058   0x4621             MOV      R1,R4
   \   0000005A   0xF106 0x0018      ADD      R0,R6,#+24
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy
    578              }
    579          
    580              // Send the maximum report size since that's what the host expects.
    581              // There may be extra trailing bytes.
    582              USB_Class_HID_Send_Data(s_hidInfo[hidInfoIndex].app_handle, HID_IN_ENDPOINT, (uint8_t *)&s_hidInfo[hidInfoIndex].report.header, sizeof(s_hidInfo[hidInfoIndex].report));
   \                     ??usb_hid_packet_write_6: (+1)
   \   00000062   0x6BB0             LDR      R0,[R6, #+56]
   \   00000064   0x2324             MOVS     R3,#+36
   \   00000066   0xF106 0x0214      ADD      R2,R6,#+20
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x.... 0x....      BL       USB_Class_HID_Send_Data
    583              sync_wait(&s_hidInfo[hidInfoIndex].sendSync, kSyncWaitForever);
   \   00000070   0xF04F 0x31FF      MOV      R1,#-1
   \   00000074   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000078   0x.... 0x....      BL       sync_wait
    584              return kStatus_Success;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    585          }
    586          

   \                                 In section .text, align 2, keep-with-next
    587          static void usb_hid_packet_abort_data_phase(const peripheral_descriptor_t * self)
    588          {
   \                     usb_hid_packet_abort_data_phase: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    589              status_t status = self->packetInterface->writePacket(self, NULL, 0, kPacketType_Command);
    590              if (status != kStatus_Success)
   \   00000002   0x6944             LDR      R4,[R0, #+20]
   \   00000004   0x68A4             LDR      R4,[R4, #+8]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x47A0             BLX      R4
    591              {
    592                  debug_printf("Error: usb_hid_packet_abort write packet returned status 0x%x\r\n", status);
    593                  return;
    594              }
    595          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    596          

   \                                 In section .text, align 2, keep-with-next
    597          static status_t usb_hid_packet_finalize(const peripheral_descriptor_t * self)
    598          {
    599              return kStatus_Success;
   \                     usb_hid_packet_finalize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    600          }
    601          

   \                                 In section .text, align 2, keep-with-next
    602          static uint32_t usb_hid_packet_get_max_packet_size(const peripheral_descriptor_t * self)
    603          {
    604              return kMinPacketBufferSize;
   \                     usb_hid_packet_get_max_packet_size: (+1)
   \   00000000   0x2020             MOVS     R0,#+32
   \   00000002   0x4770             BX       LR               ;; return
    605          }
    606          
    607          /**************************************************************************//*!
    608           *
    609           * @name   USB_Class_Periodic_Task
    610           *
    611           * @brief  The function calls for periodic tasks
    612           *
    613           * @param  None
    614           *
    615           * @return None
    616           ******************************************************************************
    617           * Called to check for any pending requests
    618           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    619          void usb_hid_Periodic_Task(const peripheral_descriptor_t * self)
    620          {
    621              USB_HID_Periodic_Task();
   \                     usb_hid_Periodic_Task: (+1)
   \   00000000   0x.... 0x....      B.W      USB_Class_Periodic_Task
    622          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     s_hidInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0xE000E104         DC32     0xe000e104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     g_device_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     g_lang_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     g_languages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     usb_hid_app_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     usb_hid_app_param_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     g_desc_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0xE000E184         DC32     0xe000e184
    623          
    624          //! @}
    625          
    626          #endif // BL_CONFIG_USB_HID
    627          
    628          ////////////////////////////////////////////////////////////////////////////////
    629          // EOF
    630          ////////////////////////////////////////////////////////////////////////////////
    631          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   usb_get_instance_via_ipsr
       0   usb_hid_Periodic_Task
         0   -> USB_Class_Periodic_Task
       8   usb_hid_app_callback
         0   -> USB_Class_HID_Recv_Data
      24   usb_hid_app_param_callback
        24   -> __aeabi_memclr4
        24   -> __aeabi_memcpy
        24   -> sync_signal
      48   usb_hid_full_init
        48   -> NVIC_ClearPendingIRQ
        48   -> USB_Class_HID_Init
        48   -> __aeabi_memclr
        48   -> usb_clock_init
      16   usb_hid_full_shutdown
        16   -> NVIC_ClearPendingIRQ
        16   -> USB_Class_HID_Deinit
       8   usb_hid_packet_abort_data_phase
         8   -- Indirect call
       0   usb_hid_packet_finalize
       0   usb_hid_packet_get_max_packet_size
       8   usb_hid_packet_init
         8   -> sync_init
         8   -> sync_signal
      24   usb_hid_packet_read
        24   -> USB_Class_HID_Recv_Data
        24   -> sync_wait
      24   usb_hid_packet_write
        24   -> USB_Class_HID_Send_Data
        24   -> __aeabi_memcpy
        24   -> lock_acquire
        24   -> lock_release
        24   -> sync_wait
       0   usb_hid_poll_for_activity


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       6  ?Subroutine0
      18  NVIC_ClearPendingIRQ
      16  g_usbHidControlInterface
      28  g_usbHidPacketInterface
      60  s_hidInfo
       4  usb_get_instance_via_ipsr
       4  usb_hid_Periodic_Task
      44  usb_hid_app_callback
     180  usb_hid_app_param_callback
     184  usb_hid_full_init
      54  usb_hid_full_shutdown
      16  usb_hid_packet_abort_data_phase
       4  usb_hid_packet_finalize
       4  usb_hid_packet_get_max_packet_size
      46  usb_hid_packet_init
     130  usb_hid_packet_read
     128  usb_hid_packet_write
      24  usb_hid_poll_for_activity

 
  60 bytes in section .bss
  44 bytes in section .rodata
 894 bytes in section .text
 
 894 bytes of CODE  memory
  44 bytes of CONST memory
  60 bytes of DATA  memory

Errors: none
Warnings: none
