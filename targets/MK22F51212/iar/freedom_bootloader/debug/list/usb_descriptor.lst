###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:44
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\hid_device\usb_descriptor.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\hid_device\usb_descriptor.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_descriptor.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_descriptor.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\hid_device\usb_descriptor.c
      1          /******************************************************************************
      2           *
      3           * Freescale Semiconductor Inc.
      4           * (c) Copyright 2004-2013 Freescale Semiconductor, Inc.
      5           * ALL RIGHTS RESERVED.
      6           *
      7           **************************************************************************//*!
      8           *
      9           * @file usb_descriptor.c
     10           *
     11           * @author
     12           *
     13           * @version
     14           *
     15           * @date May-28-2009
     16           *
     17           * @brief The file contains USB descriptors
     18           *
     19           *****************************************************************************/
     20          
     21          /******************************************************************************
     22           * Includes
     23           *****************************************************************************/
     24          #include "usb_device_config.h"
     25          #include "usb.h"
     26          #include "usb_device_stack_interface.h"
     27          #include "usb_class_hid.h"
     28          #include "usb_descriptor.h"
     29          #include "soc.h"
     30          #include "types.h"
     31          
     32          #include "bootloader_hid_report_ids.h"
     33          #include "bootloader/peripheral.h"
     34          #include "property/property.h"
     35          #include "bootloader/context.h"
     36          
     37          #if (defined __MCF52xxx_H__) || (defined __MK_xxx_H__)
     38          /* Put CFV2 descriptors in RAM */
     39          #define USB_DESC_CONST
     40          #else
     41          #define USB_DESC_CONST	const
     42          #endif
     43          
     44          /*****************************************************************************
     45           * Constant and Macro's
     46           *****************************************************************************/
     47          
     48          
     49          #define BL_MIN_PACKET_SIZE (32)
     50          #define BL_PACKET_SIZE_HEADER_SIZE (3)  // alignment byte + length lsb + length msb (does not include report id)
     51          #define BL_REPORT_SIZE (BL_MIN_PACKET_SIZE + BL_PACKET_SIZE_HEADER_SIZE)
     52          
     53          
     54          	/* hidtc data buffer out report descriptor */
     55          #define HID_USAGE_HIDTC_DATA_OUT(__id, __count, __size)       \
     56          	  0x85, ((uint8_t)(__id)),		/*	 REPORT_ID (__id) */	  \
     57          	  0x19, 0x01,					 /*   USAGE_MINIMUM (1)*/	   \
     58          	  0x29, 0x01,					 /*   USAGE_MAXIMUM (1)*/	   \
     59          	  0x15, 0x00,					 /*   LOGICAL_MINIMUM (0)*/    \
     60          	  0x26, 0xff, 0x00, 			 /*   LOGICAL_MAXIMUM (255)*/  \
     61          	  0x75, ((uint8_t)(__size)), 	/*	 REPORT_SIZE (n)*/		  \
     62          	  0x95, ((uint8_t)(__count)),	/*	 REPORT_COUNT (n)*/ 	  \
     63          	  0x91, 0x02					 /*   OUTPUT (Data,Var,Abs) */
     64          
     65          	/* hidtc data buffer in report descriptor */
     66          #define HID_USAGE_HIDTC_DATA_IN(__id, __count, __size)        \
     67          	  0x85, ((uint8_t)(__id)),		/*	 REPORT_ID (__id) */	  \
     68          	  0x19, 0x01,					 /*   USAGE_MINIMUM (1)*/	   \
     69          	  0x29, 0x01,					 /*   USAGE_MAXIMUM (1)*/	   \
     70          	  0x15, 0x00,					 /*   LOGICAL_MINIMUM (0)*/    \
     71          	  0x26, 0xff, 0x00, 			 /*   LOGICAL_MAXIMUM (255)*/  \
     72          	  0x75, ((uint8_t)(__size)), 	/*	 REPORT_SIZE (n)*/		  \
     73          	  0x95, ((uint8_t)(__count)),	/*	 REPORT_COUNT (n)*/ 	  \
     74          	  0x81, 0x02					 /*   INPUT (Data,Var,Abs) */
     75          
     76          

   \                                 In section .data, align 4
     77          usb_ep_struct_t g_ep[HID_DESC_ENDPOINT_COUNT] =
   \                     g_ep:
   \   00000000   0x01 0x03          DC8 1, 3, 1, 0
   \              0x01 0x00    
   \   00000004   0x00000040         DC32 64
   \   00000008   0x02 0x03          DC8 2, 3, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000040         DC32 64
     78          {
     79              {HID_IN_ENDPOINT,
     80               USB_INTERRUPT_PIPE,
     81               USB_SEND,
     82               HID_ENDPOINT_PACKET_SIZE,
     83               },
     84              {HID_OUT_ENDPOINT,
     85               USB_INTERRUPT_PIPE,
     86               USB_RECV,
     87               HID_ENDPOINT_PACKET_SIZE,
     88               }
     89          };
     90          
     91          /* structure containing details of all the endpoints used by this device */

   \                                 In section .data, align 4
     92          USB_DESC_CONST usb_endpoints_t usb_desc_ep =
   \                     usb_desc_ep:
   \   00000000   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 g_ep
     93          {
     94              HID_DESC_ENDPOINT_COUNT,
     95              g_ep
     96          };
     97          

   \                                 In section .data, align 4
     98          static usb_if_struct_t g_usb_if[1] ;
   \                     g_usb_if:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     99          
    100          usb_class_struct_t g_usb_dec_class =
   \                     g_usb_dec_class:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 1, 0, 0, 0
   \              0x00 0x00    
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000014   0x........         DC32 g_usb_if
    101          {
    102             USB_CLASS_HID,
    103             {
    104                  1,
    105                  g_usb_if
    106              }
    107          };
    108          
    109          

   \                                 In section .data, align 4
    110          uint8_t USB_DESC_CONST g_device_descriptor[DEVICE_DESCRIPTOR_SIZE] =
   \                     g_device_descriptor:
   \   00000000   0x12 0x01          DC8 18, 1, 0, 2, 0, 0, 0, 64, 162, 21, 115, 0, 2, 0, 1, 2, 0, 1, 0, 0
   \              0x00 0x02    
   \              0x00 0x00    
   \              0x00 0x40    
   \              0xA2 0x15    
   \              0x73 0x00    
   \              0x02 0x00    
   \              0x01 0x02    
   \              0x00 0x01    
   \              0x00 0x00    
    111          {
    112             DEVICE_DESCRIPTOR_SIZE,               /* "Device Descriptor Size        */
    113             USB_DEVICE_DESCRIPTOR,                /* "Device" Type of descriptor    */
    114             0x00, 0x02,                           /*  BCD USB version               */
    115             DEVICE_DESC_DEVICE_CLASS,             /*  Device Class is indicated in
    116                                                       the interface descriptors     */
    117             DEVICE_DESC_DEVICE_SUBCLASS,          /*  Device Subclass is indicated
    118                                                       in the interface descriptors  */
    119             DEVICE_DESC_DEVICE_PROTOCOL,          /*  Device Protocol               */
    120             CONTROL_MAX_PACKET_SIZE,              /*  Max Packet size               */
    121             0xA2,0x15,                            /*  Vendor ID for Freescale       */
    122             0x73,0x00,                            /* 0x73,0x00,ProductID for KL25Z48M */
    123             0x02,0x00,                            /*  BCD Device version            */
    124             0x01,                                 /*  Manufacturer string index     */
    125             0x02,                                 /*  Product string index          */
    126             0x00,                                 /*  Serial number string index    */
    127             DEVICE_DESC_NUM_CONFIG_SUPPOTED       /*  Number of configurations      */
    128          };
    129          
    130          uint8_t USB_DESC_CONST g_config_descriptor[CONFIG_DESC_SIZE] =
    131          {
    132             CONFIG_ONLY_DESC_SIZE,  /*  Configuration Descriptor Size - always 9 bytes*/
    133             USB_CONFIG_DESCRIPTOR,  /* "Configuration" type of descriptor */
    134             CONFIG_DESC_SIZE, 0x00, /*  Total length of the Configuration descriptor */
    135             CONFIG_DESC_NUM_INTERFACES_SUPPOTED,     /*  NumInterfaces */
    136             1,                      /*  Configuration Value */
    137             0,                      /*  Configuration Description String Index*/
    138             (USB_DESC_CFG_ATTRIBUTES_D7_POS) | (USBCFG_DEV_SELF_POWER << USB_DESC_CFG_ATTRIBUTES_SELF_POWERED_SHIFT) | (USBCFG_DEV_REMOTE_WAKEUP << USB_DESC_CFG_ATTRIBUTES_REMOTE_WAKEUP_SHIFT),
    139             /* S08/CFv1 are both self powered (its compulsory to set bus powered)*/
    140             /*Attributes.support RemoteWakeup and self power*/
    141             CONFIG_DESC_CURRENT_DRAWN,              /*  Current draw from bus */
    142          
    143             /* Interface Descriptor */
    144             IFACE_ONLY_DESC_SIZE,
    145             USB_IFACE_DESCRIPTOR,
    146             0x00,
    147             0x00,
    148             HID_DESC_ENDPOINT_COUNT,
    149             0x03,
    150             0x00,  
    151             0x00,  /* protocol None*/
    152             0x00,
    153          
    154             /* HID descriptor */
    155             HID_ONLY_DESC_SIZE,
    156             USB_HID_DESCRIPTOR,
    157             0x00,0x01,
    158             0x00,
    159             0x01,
    160             0x22,/*  hid report        */
    161          
    162             (REPORT_DESC_SIZE & 0x00ff),		 /* report_desc_length_l */
    163             (REPORT_DESC_SIZE & 0xff00) >> 8, /* report_desc_length_h */
    164          
    165             /*IN Endpoint descriptor */
    166             ENDP_ONLY_DESC_SIZE,
    167             USB_ENDPOINT_DESCRIPTOR,
    168             HID_IN_ENDPOINT|(USB_SEND << 7),
    169             USB_INTERRUPT_PIPE,
    170             HID_ENDPOINT_PACKET_SIZE, 0x00,
    171             0x0A,
    172          
    173             /* OUT Endpoint descriptor */
    174             ENDP_ONLY_DESC_SIZE,
    175             USB_ENDPOINT_DESCRIPTOR,
    176             HID_OUT_ENDPOINT|(USB_RECV << 7),
    177             USB_INTERRUPT_PIPE,
    178             HID_ENDPOINT_PACKET_SIZE, 0x00,
    179             0x0A
    180          };
    181          
    182          uint8_t  g_device_qualifier_descriptor[DEVICE_QUALIFIER_DESCRIPTOR_SIZE] =
    183          {
    184              /* Device Qualifier Descriptor Size */
    185              DEVICE_QUALIFIER_DESCRIPTOR_SIZE, 
    186              /* Type of Descriptor */
    187              USB_DEVQUAL_DESCRIPTOR,
    188              /*  BCD USB version  */
    189              USB_uint_16_low(BCD_USB_VERSION), USB_uint_16_high(BCD_USB_VERSION),
    190              /* bDeviceClass */
    191              DEVICE_DESC_DEVICE_CLASS,
    192              /* bDeviceSubClass */
    193              DEVICE_DESC_DEVICE_SUBCLASS,
    194              /* bDeviceProtocol */
    195              DEVICE_DESC_DEVICE_PROTOCOL,
    196              /* bMaxPacketSize0 */
    197              CONTROL_MAX_PACKET_SIZE,
    198              /* bNumConfigurations */
    199              DEVICE_OTHER_DESC_NUM_CONFIG_SUPPOTED,  
    200              /* Reserved : must be zero */ 
    201              0x00
    202          };
    203          
    204          uint8_t  g_other_speed_config_descriptor[OTHER_SPEED_CONFIG_DESCRIPTOR_SIZE] =
    205          {
    206              /* Length of this descriptor */
    207              CONFIG_ONLY_DESC_SIZE,     
    208              /* This is a Other speed config descr */
    209              USB_OTHER_SPEED_DESCRIPTOR,
    210              /*  Total length of the Configuration descriptor */
    211              USB_uint_16_low(CONFIG_DESC_SIZE), USB_uint_16_high(CONFIG_DESC_SIZE),
    212              CONFIG_DESC_NUM_INTERFACES_SUPPOTED,
    213              /*value used to selct this configuration : Configuration Value */
    214              1, 
    215              /*  Configuration Description String Index*/   
    216              0, 
    217              /*  Attributes.support RemoteWakeup and self power */
    218              (USB_DESC_CFG_ATTRIBUTES_D7_POS) | (USBCFG_DEV_SELF_POWER << USB_DESC_CFG_ATTRIBUTES_SELF_POWERED_SHIFT) | (USBCFG_DEV_REMOTE_WAKEUP << USB_DESC_CFG_ATTRIBUTES_REMOTE_WAKEUP_SHIFT),    
    219              /*  Current draw from bus */
    220              CONFIG_DESC_CURRENT_DRAWN, 
    221          
    222              /* Interface Descriptor */
    223              IFACE_ONLY_DESC_SIZE,
    224              USB_IFACE_DESCRIPTOR,
    225              0x00,
    226              0x00,
    227              HID_DESC_ENDPOINT_COUNT,
    228              0x03,
    229              0x01,
    230              0x02,
    231              0x00,
    232          
    233              /* HID descriptor */
    234              HID_ONLY_DESC_SIZE, 
    235              USB_HID_DESCRIPTOR,
    236              0x00,0x01,
    237              0x00,
    238              0x01,
    239              0x22,
    240              0x34,0x00,
    241               
    242              /*Endpoint descriptor */
    243          /*    ENDP_ONLY_DESC_SIZE, 
    244              USB_ENDPOINT_DESCRIPTOR,
    245              HID_ENDPOINT|(USB_SEND << 7),
    246              USB_INTERRUPT_PIPE, 
    247              HID_ENDPOINT_PACKET_SIZE, 0x00, 
    248              0x0A
    249          */      
    250             /*IN Endpoint descriptor */
    251             ENDP_ONLY_DESC_SIZE,
    252             USB_ENDPOINT_DESCRIPTOR,
    253             HID_IN_ENDPOINT|(USB_SEND << 7),
    254             USB_INTERRUPT_PIPE,
    255             HID_ENDPOINT_PACKET_SIZE, 0x00,
    256             0x0A,
    257          
    258             /* OUT Endpoint descriptor */
    259             ENDP_ONLY_DESC_SIZE,
    260             USB_ENDPOINT_DESCRIPTOR,
    261             HID_OUT_ENDPOINT|(USB_RECV << 7),
    262             USB_INTERRUPT_PIPE,
    263             HID_ENDPOINT_PACKET_SIZE, 0x00,
    264             0x0A        
    265          };
    266          
    267          uint8_t USB_DESC_CONST g_report_descriptor[REPORT_DESC_SIZE] =
    268          {
    269             0x06, 0x00, 0xFF ,  /* Usage Page (Vendor Defined Page 1)*/
    270             0x09, 0x01,   /* USAGE (Vendor 1) */
    271             0xA1, 0x01,   /* Collection (Application) */
    272              HID_USAGE_HIDTC_DATA_OUT(kBootloaderReportID_CommandOut, BL_REPORT_SIZE, 8),
    273              HID_USAGE_HIDTC_DATA_OUT(kBootloaderReportID_DataOut, BL_REPORT_SIZE , 8),
    274              HID_USAGE_HIDTC_DATA_IN (kBootloaderReportID_CommandIn, BL_REPORT_SIZE, 8),
    275              HID_USAGE_HIDTC_DATA_IN (kBootloaderReportID_DataIn, BL_REPORT_SIZE, 8),
    276             0xC0          /* end collection */
    277          };
    278          
    279          uint8_t USB_DESC_CONST USB_STR_0[USB_STR_0_SIZE+USB_STR_DESC_SIZE] =
    280                                              {sizeof(USB_STR_0),
    281                                               USB_STRING_DESCRIPTOR,
    282                                                0x09,
    283                                                0x04/*equiavlent to 0x0409*/
    284                                              };
    285          
    286          uint8_t USB_DESC_CONST USB_STR_1[USB_STR_1_SIZE+USB_STR_DESC_SIZE]
    287                                    = {  sizeof(USB_STR_1),
    288                                         USB_STRING_DESCRIPTOR,
    289                                         'F',0,
    290                                         'r',0,
    291                                         'e',0,
    292                                         'e',0,
    293                                         's',0,
    294                                         'c',0,
    295                                         'a',0,
    296                                         'l',0,
    297                                         'e',0,
    298                                         ' ',0,
    299                                         'S',0,
    300                                         'e',0,
    301                                         'm',0,
    302                                         'i',0,
    303                                         'c',0,
    304                                         'o',0,
    305                                         'n',0,
    306                                         'd',0,
    307                                         'u',0,
    308                                         'c',0,
    309                                         't',0,
    310                                         'o',0,
    311                                         'r',0,
    312                                         ' ',0,
    313                                         'I',0,
    314                                         'n',0,
    315                                         'c',0,
    316                                         '.',0
    317                                    };
    318          
    319          
    320          uint8_t USB_DESC_CONST USB_STR_2[USB_STR_2_SIZE+USB_STR_DESC_SIZE]
    321                                    = {  sizeof(USB_STR_2),
    322                                         USB_STRING_DESCRIPTOR,
    323                                         'K',0,
    324                                         'i',0,
    325                                         'n',0,
    326                                         'e',0,
    327                                         't',0,
    328                                         'i',0,
    329                                         's',0,
    330                                         ' ',0,
    331                                         'B',0,
    332                                         'o',0,
    333                                         'o',0,
    334                                         't',0,
    335                                         'l',0,
    336                                         'o',0,
    337                                         'a',0,
    338                                         'd',0,
    339                                         'e',0,
    340                                         'r',0,
    341                                    };
    342          
    343          uint8_t USB_DESC_CONST USB_STR_n[USB_STR_n_SIZE+USB_STR_DESC_SIZE]
    344                                    = {  sizeof(USB_STR_n),
    345                                         USB_STRING_DESCRIPTOR,
    346                                         'B',0,
    347                                         'A',0,
    348                                         'D',0,
    349                                         ' ',0,
    350                                         'S',0,
    351                                         'T',0,
    352                                         'R',0,
    353                                         'I',0,
    354                                         'N',0,
    355                                         'G',0,
    356                                         ' ',0,
    357                                         'I',0,
    358                                         'N',0,
    359                                         'D',0,
    360                                         'E',0,
    361                                         'X',0
    362                                    };
    363          
    364          

   \                                 In section .text, align 4, keep-with-next
    365          USB_PACKET_SIZE const g_std_desc_size[USB_MAX_STD_DESCRIPTORS+1] =
   \                     g_std_desc_size:
   \   00000000   0x00000000         DC32 0, 18, 41, 0, 0, 0, 0, 0, 76
   \              0x00000012   
   \              0x00000029   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x0000004C   
    366                                              {0,
    367                                               DEVICE_DESCRIPTOR_SIZE,
    368                                               CONFIG_DESC_SIZE,
    369                                               0, /* string */
    370                                               0, /* Interface */
    371                                               0, /* Endpoint */
    372                                               0, /* Device Qualifier */
    373                                               0, /* other speed config */
    374                                               REPORT_DESC_SIZE
    375                                              };
    376          

   \                                 In section .rodata, align 4, keep-with-next
    377          USB_PACKET_SIZE const g_std_desc_size_hs[USB_MAX_STD_DESCRIPTORS+1] =
   \                     g_std_desc_size_hs:
   \   00000000   0x00000000         DC32 0, 18, 41, 0, 0, 0, 10, 41, 76
   \              0x00000012   
   \              0x00000029   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x0000000A   
   \              0x00000029   
   \              0x0000004C   
    378                                              {0,
    379                                               DEVICE_DESCRIPTOR_SIZE,
    380                                               CONFIG_DESC_SIZE,
    381                                               0, /* string */
    382                                               0, /* Interface */
    383                                               0, /* Endpoint */
    384                                               DEVICE_QUALIFIER_DESCRIPTOR_SIZE,
    385                                               OTHER_SPEED_CONFIG_DESCRIPTOR_SIZE,
    386                                               REPORT_DESC_SIZE
    387                                              };
    388          

   \                                 In section .text, align 4, keep-with-next
    389          uint_8_ptr const g_std_descriptors[USB_MAX_STD_DESCRIPTORS+1] =
   \                     g_std_descriptors:
   \   00000000   0x00000000         DC32 0H, g_device_descriptor, g_config_descriptor, 0H, 0H, 0H, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000020   0x........         DC32 g_report_descriptor
    390                                                      {
    391                                                          NULL,
    392                                                          (uint_8_ptr)g_device_descriptor,
    393                                                          (uint_8_ptr)g_config_descriptor,
    394                                                          NULL, /* string */
    395                                                          NULL, /* Interface */
    396                                                          NULL, /* Endpoint */
    397                                                          NULL, /* Device Qualifier */
    398                                                          NULL, /* other speed config*/
    399                                                          (uint_8_ptr)g_report_descriptor
    400                                                      };
    401          

   \                                 In section .rodata, align 4, keep-with-next
    402          uint_8_ptr const g_std_descriptors_hs[USB_MAX_STD_DESCRIPTORS+1] =
   \                     g_std_descriptors_hs:
   \   00000000   0x00000000         DC32 0H, g_device_descriptor, g_config_descriptor, 0H, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000018   0x........         DC32 g_device_qualifier_descriptor, g_other_speed_config_descriptor
   \              0x........   
   \   00000020   0x........         DC32 g_report_descriptor
    403                                                      {
    404                                                          NULL,
    405                                                          (uint_8_ptr)g_device_descriptor,
    406                                                          (uint_8_ptr)g_config_descriptor,
    407                                                          NULL, /* string */
    408                                                          NULL, /* Interface */
    409                                                          NULL, /* Endpoint */
    410                                                          g_device_qualifier_descriptor,
    411                                                          g_other_speed_config_descriptor,
    412                                                          (uint_8_ptr)g_report_descriptor
    413                                                      };
    414          

   \                                 In section .rodata, align 4, keep-with-next
    415          uint8_t const g_string_desc_size[USB_MAX_STRING_DESCRIPTORS+1] =
   \                     g_string_desc_size:
   \   00000000   0x04 0x3A          DC8 4, 58, 38, 34
   \              0x26 0x22    
    416                                             {
    417                                               sizeof(USB_STR_0),
    418                                               sizeof(USB_STR_1),
    419                                               sizeof(USB_STR_2),
    420                                               sizeof(USB_STR_n)
    421                                              };
    422          

   \                                 In section .rodata, align 4, keep-with-next
    423          uint_8_ptr const g_string_descriptors[USB_MAX_STRING_DESCRIPTORS+1] =
   \                     g_string_descriptors:
   \   00000000   0x........         DC32 USB_STR_0, USB_STR_1, USB_STR_2, USB_STR_n
   \              0x........   
   \              0x........   
   \              0x........   
    424                                            {
    425                                                (uint_8_ptr) USB_STR_0,
    426                                                (uint_8_ptr) USB_STR_1,
    427                                                (uint_8_ptr) USB_STR_2,
    428                                                (uint_8_ptr) USB_STR_n
    429                                            };
    430          

   \                                 In section .text, align 4, keep-with-next
    431          USB_ALL_LANGUAGES g_languages = { USB_STR_0, sizeof(USB_STR_0),
   \                     g_languages:
   \   00000000   0x........         DC32 USB_STR_0
   \   00000004   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x0409             DC16 1033
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 g_string_descriptors, g_string_desc_size
   \              0x........   
    432                                            { (uint16_t)0x0409,
    433                                             (const uint8_t **)g_string_descriptors,
    434                                                g_string_desc_size}
    435                                          };
    436          
    437          

   \                                 In section .bss, align 4
    438          USB_ALL_LANGUAGES * g_lang_ptr;
   \                     g_lang_ptr:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
    439          uint8_t const g_valid_config_values[USB_MAX_CONFIG_SUPPORTED+1]={0,1};
   \                     g_valid_config_values:
   \   00000000   0x00 0x01          DC8 0, 1
    440          
    441          /****************************************************************************
    442           * Global Variables
    443           ****************************************************************************/

   \                                 In section .bss, align 1
    444          static uint8_t g_alternate_interface[USB_MAX_SUPPORTED_INTERFACES];
   \                     g_alternate_interface:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
    445          
    446          /*****************************************************************************
    447           * Local Types - None
    448           *****************************************************************************/
    449          
    450          /*****************************************************************************
    451           * Local Functions Prototypes
    452           *****************************************************************************/
    453          
    454          /*****************************************************************************
    455           * Local Variables - None
    456           *****************************************************************************/
    457          
    458           /*****************************************************************************
    459           * Local Functions - None
    460           *****************************************************************************/
    461          
    462          /*****************************************************************************
    463           * Global Functions
    464           *****************************************************************************/
    465          extern uint32_t usb_get_instance_via_ipsr(void);
    466          
    467          /**************************************************************************//*!
    468           *
    469           * @name  USB_Desc_Get_Descriptor
    470           *
    471           * @brief The function returns the correponding descriptor
    472           *
    473           * @param controller_ID : Controller ID
    474           * @param type          : Type of descriptor requested
    475           * @param sub_type      : String index for string descriptor
    476           * @param index         : String descriptor language Id
    477           * @param descriptor    : Output descriptor pointer
    478           * @param size          : Size of descriptor returned
    479           *
    480           * @return USB_OK                              When Successfull
    481           *         USBERR_INVALID_REQ_TYPE             when Error
    482           *****************************************************************************
    483           * This function is used to pass the pointer of the requested descriptor
    484           *****************************************************************************/
    485          int device_desc_req_count = 0;
   \                     device_desc_req_count:
   \   00000000   0x00000000         DC32 0
   \                     g_config_descriptor:
   \   00000004   0x09 0x02          DC8 9, 2, 41, 0, 1, 1, 0, 192, 50, 9, 4, 0, 0, 2, 3, 0, 0, 0, 9, 33, 0
   \              0x29 0x00    
   \              0x01 0x01    
   \              0x00 0xC0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x02    
   \              0x03 0x00    
   \              0x00 0x00    
   \              0x09 0x21    
   \              0x00         
   \   00000019   0x01 0x00          DC8 1, 0, 1, 34, 76, 0, 7, 5, 129, 3, 64, 0, 10, 7, 5, 2, 3, 64, 0, 10
   \              0x01 0x22    
   \              0x4C 0x00    
   \              0x07 0x05    
   \              0x81 0x03    
   \              0x40 0x00    
   \              0x0A 0x07    
   \              0x05 0x02    
   \              0x03 0x40    
   \              0x00 0x0A    
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     g_report_descriptor:
   \   00000030   0x06 0x00          DC8 6, 0, 255, 9, 1, 161, 1, 133, 1, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0xFF 0x09    
   \              0x01 0xA1    
   \              0x01 0x85    
   \              0x01 0x19    
   \              0x01 0x29    
   \              0x01 0x15    
   \              0x00 0x26    
   \              0xFF 0x00    
   \   00000042   0x75 0x08          DC8 117, 8, 149, 35, 145, 2, 133, 2, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0x95 0x23    
   \              0x91 0x02    
   \              0x85 0x02    
   \              0x19 0x01    
   \              0x29 0x01    
   \              0x15 0x00    
   \              0x26 0xFF    
   \              0x00         
   \   00000053   0x75 0x08          DC8 117, 8, 149, 35, 145, 2, 133, 3, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0x95 0x23    
   \              0x91 0x02    
   \              0x85 0x03    
   \              0x19 0x01    
   \              0x29 0x01    
   \              0x15 0x00    
   \              0x26 0xFF    
   \              0x00         
   \   00000064   0x75 0x08          DC8 117, 8, 149, 35, 129, 2, 133, 4, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0x95 0x23    
   \              0x81 0x02    
   \              0x85 0x04    
   \              0x19 0x01    
   \              0x29 0x01    
   \              0x15 0x00    
   \              0x26 0xFF    
   \              0x00         
   \   00000075   0x75 0x08          DC8 117, 8, 149, 35, 129, 2, 192
   \              0x95 0x23    
   \              0x81 0x02    
   \              0xC0         
   \                     USB_STR_0:
   \   0000007C   0x04 0x03          DC8 4, 3, 9, 4
   \              0x09 0x04    

   \                                 In section .data, align 4
   \                     g_device_qualifier_descriptor:
   \   00000000   0x0A 0x06          DC8 10, 6, 0, 2, 0, 0, 0, 64, 0, 0, 0, 0
   \              0x00 0x02    
   \              0x00 0x00    
   \              0x00 0x40    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     g_other_speed_config_descriptor:
   \   00000000   0x09 0x07          DC8 9, 7, 41, 0, 1, 1, 0, 192, 50, 9, 4, 0, 0, 2, 3, 1, 2, 0, 9, 33, 0
   \              0x29 0x00    
   \              0x01 0x01    
   \              0x00 0xC0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x02    
   \              0x03 0x01    
   \              0x02 0x00    
   \              0x09 0x21    
   \              0x00         
   \   00000015   0x01 0x00          DC8 1, 0, 1, 34, 52, 0, 7, 5, 129, 3, 64, 0, 10, 7, 5, 2, 3, 64, 0, 10
   \              0x01 0x22    
   \              0x34 0x00    
   \              0x07 0x05    
   \              0x81 0x03    
   \              0x40 0x00    
   \              0x0A 0x07    
   \              0x05 0x02    
   \              0x03 0x40    
   \              0x00 0x0A    
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     USB_STR_1:
   \   00000000   0x3A 0x03          DC8 58, 3, 70, 0, 114, 0, 101, 0, 101, 0, 115, 0, 99, 0, 97, 0, 108, 0
   \              0x46 0x00    
   \              0x72 0x00    
   \              0x65 0x00    
   \              0x65 0x00    
   \              0x73 0x00    
   \              0x63 0x00    
   \              0x61 0x00    
   \              0x6C 0x00    
   \   00000012   0x65 0x00          DC8 101, 0, 32, 0, 83, 0, 101, 0, 109, 0, 105, 0, 99, 0, 111, 0, 110, 0
   \              0x20 0x00    
   \              0x53 0x00    
   \              0x65 0x00    
   \              0x6D 0x00    
   \              0x69 0x00    
   \              0x63 0x00    
   \              0x6F 0x00    
   \              0x6E 0x00    
   \   00000024   0x64 0x00          DC8 100, 0, 117, 0, 99, 0, 116, 0, 111, 0, 114, 0, 32, 0, 73, 0, 110, 0
   \              0x75 0x00    
   \              0x63 0x00    
   \              0x74 0x00    
   \              0x6F 0x00    
   \              0x72 0x00    
   \              0x20 0x00    
   \              0x49 0x00    
   \              0x6E 0x00    
   \   00000036   0x63 0x00          DC8 99, 0, 46, 0, 0, 0
   \              0x2E 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     USB_STR_2:
   \   00000000   0x26 0x03          DC8 38, 3, 75, 0, 105, 0, 110, 0, 101, 0, 116, 0, 105, 0, 115, 0, 32, 0
   \              0x4B 0x00    
   \              0x69 0x00    
   \              0x6E 0x00    
   \              0x65 0x00    
   \              0x74 0x00    
   \              0x69 0x00    
   \              0x73 0x00    
   \              0x20 0x00    
   \   00000012   0x42 0x00          DC8 66, 0, 111, 0, 111, 0, 116, 0, 108, 0, 111, 0, 97, 0, 100, 0, 101
   \              0x6F 0x00    
   \              0x6F 0x00    
   \              0x74 0x00    
   \              0x6C 0x00    
   \              0x6F 0x00    
   \              0x61 0x00    
   \              0x64 0x00    
   \              0x65         
   \   00000023   0x00 0x72          DC8 0, 114, 0, 0, 0
   \              0x00 0x00    
   \              0x00         

   \                                 In section .data, align 4
   \                     USB_STR_n:
   \   00000000   0x22 0x03          DC8 34, 3, 66, 0, 65, 0, 68, 0, 32, 0, 83, 0, 84, 0, 82, 0, 73, 0, 78
   \              0x42 0x00    
   \              0x41 0x00    
   \              0x44 0x00    
   \              0x20 0x00    
   \              0x53 0x00    
   \              0x54 0x00    
   \              0x52 0x00    
   \              0x49 0x00    
   \              0x4E         
   \   00000013   0x00 0x47          DC8 0, 71, 0, 32, 0, 73, 0, 78, 0, 68, 0, 69, 0, 88, 0, 0, 0
   \              0x00 0x20    
   \              0x00 0x49    
   \              0x00 0x4E    
   \              0x00 0x44    
   \              0x00 0x45    
   \              0x00 0x58    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .text, align 2, keep-with-next
    486          uint8_t USB_Desc_Get_Descriptor(
    487               hid_handle_t handle,     /* [IN]  handle */
    488               uint8_t type,            /* [IN]  Type of descriptor requested */
    489               uint8_t str_num,         /* [IN]  String index for string descriptor */
    490               uint16_t index,          /* [IN]  String descriptor language Id */
    491               uint_8_ptr *descriptor, /* [OUT] Output descriptor pointer */
    492               uint32_t *size
    493          )
    494          {
   \                     USB_Desc_Get_Descriptor: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x460E             MOV      R6,R1
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
    495          
    496              uint32_t hidInforIndex = usb_get_instance_via_ipsr(); 
   \   00000008   0x.... 0x....      BL       usb_get_instance_via_ipsr
    497              UNUSED (handle)
    498                 
    499              switch(type)
   \   0000000C   0x9A06             LDR      R2,[SP, #+24]
   \   0000000E   0x9907             LDR      R1,[SP, #+28]
   \   00000010   0x....             LDR.N    R3,??DataTable13
   \   00000012   0x2E03             CMP      R6,#+3
   \   00000014   0xD011             BEQ.N    ??USB_Desc_Get_Descriptor_0
   \   00000016   0x2E21             CMP      R6,#+33
   \   00000018   0xD009             BEQ.N    ??USB_Desc_Get_Descriptor_1
   \   0000001A   0x2E22             CMP      R6,#+34
   \   0000001C   0xD12A             BNE.N    ??USB_Desc_Get_Descriptor_2
    500              {
    501                case USB_REPORT_DESCRIPTOR:
    502                  {
    503                    type = USB_MAX_STD_DESCRIPTORS;
    504                    if (hidInforIndex == USB_CONTROLLER_KHCI_0)
   \   0000001E   0xB920             CBNZ.N   R0,??USB_Desc_Get_Descriptor_3
    505                    {
    506                        *descriptor = (uint_8_ptr)g_std_descriptors[type];
   \   00000020   0xF103 0x0030      ADD      R0,R3,#+48
   \   00000024   0x6010             STR      R0,[R2, #+0]
    507                        *size = g_std_desc_size[type];
   \   00000026   0x204C             MOVS     R0,#+76
   \                     ??USB_Desc_Get_Descriptor_4: (+1)
   \   00000028   0x6008             STR      R0,[R1, #+0]
    508                    }
    509          #if USBCFG_DEV_EHCI          
    510                    else if (hidInforIndex == USB_CONTROLLER_EHCI_0)
    511                    {
    512                        *descriptor = (uint_8_ptr)g_std_descriptors_hs[type];
    513                        *size = g_std_desc_size_hs[type];
    514                    }  
    515          #endif          
    516                  }
    517                  break;
    518                case USB_HID_DESCRIPTOR:
    519                  {
    520                    type = USB_CONFIG_DESCRIPTOR ;
    521                    if (hidInforIndex == USB_CONTROLLER_KHCI_0)
    522                    {
    523                        *descriptor = (uint_8_ptr)(g_std_descriptors [type]+
    524                                         CONFIG_ONLY_DESC_SIZE+IFACE_ONLY_DESC_SIZE);
    525                    }
    526          #if USBCFG_DEV_EHCI          
    527                    else if (hidInforIndex == USB_CONTROLLER_EHCI_0)
    528                    {
    529                        *descriptor = (uint_8_ptr)(g_std_descriptors_hs [type]+
    530                                         CONFIG_ONLY_DESC_SIZE+IFACE_ONLY_DESC_SIZE);
    531                    }
    532          #endif          
    533                    *size = HID_ONLY_DESC_SIZE;
    534                  }
    535                  break;
    536                case USB_STRING_DESCRIPTOR:
    537                  {
    538                      if(index == 0)
    539                      {
    540                          /* return the string and size of all languages */
    541                          *descriptor = (uint8_t *)g_languages.languages_supported_string;
    542                          *size = g_languages.languages_supported_size; 
    543                      } else
    544                      {
    545                          uint8_t lang_id=0;
    546                          uint8_t lang_index=USB_MAX_LANGUAGES_SUPPORTED;
    547          
    548                          for(;lang_id< USB_MAX_LANGUAGES_SUPPORTED;lang_id++)
    549                          {
    550                              /* check whether we have a string for this language */
    551                               if (index == g_languages.usb_language[lang_id].language_id) 
    552                              {   /* check for max descriptors */
    553                                  if(str_num < USB_MAX_STRING_DESCRIPTORS)
    554                                  {   /* setup index for the string to be returned */
    555                                      lang_index=str_num;
    556                                  }
    557                                  break;
    558                              }
    559          
    560                          }
    561          
    562                          /* set return val for descriptor and size */
    563                          *descriptor = (uint8_t *)
    564                                  g_languages.usb_language[lang_id].lang_desc[lang_index];
    565                          *size = g_languages.usb_language[lang_id].lang_desc_size[lang_index];
    566                      }
    567                  }
    568                  break;
    569                default :
    570                  if (type < USB_MAX_STD_DESCRIPTORS)
    571                  {
    572                      /* set return val for descriptor and size*/
    573                    if (hidInforIndex == USB_CONTROLLER_KHCI_0)
    574                    {
    575                        *descriptor = (uint_8_ptr)g_std_descriptors[type];
    576                    }
    577          #if USBCFG_DEV_EHCI           
    578                    else if (hidInforIndex == USB_CONTROLLER_EHCI_0)
    579                    {
    580                        *descriptor = (uint_8_ptr)g_std_descriptors_hs[type];
    581                    }    
    582          #endif          
    583          //            *descriptor = (uint_8_ptr)g_std_descriptors [type];
    584          		//	printf("type: %d \n", type);
    585          
    586                      // device descriptor
    587                      if(type == 1){
    588                      	device_desc_req_count++;
    589                      }
    590                      // andrei: second request
    591                      if(device_desc_req_count>=2){
    592                      	device_desc_req_count = 0;
    593                      }
    594          
    595                      /* if there is no descriptor then return error */
    596                      if(*descriptor == NULL)
    597                      {
    598                          return USBERR_INVALID_REQ_TYPE;
    599                      }
    600          
    601                      if (hidInforIndex == USB_CONTROLLER_KHCI_0)
    602                      {
    603                          *size = g_std_desc_size[type];
    604                      }
    605          #if USBCFG_DEV_EHCI          
    606                      else if (hidInforIndex == USB_CONTROLLER_EHCI_0)
    607                      {
    608                          *size = g_std_desc_size_hs[type];
    609                      }  
    610          #endif          
    611                    
    612          //            *size = g_std_desc_size[type];
    613                  }
    614                  else /* invalid descriptor */
    615                  {
    616                      return USBERR_INVALID_REQ_TYPE;
    617                  }
    618                  break;
    619              }
    620              return USB_OK;
   \                     ??USB_Desc_Get_Descriptor_3: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??USB_Desc_Get_Descriptor_1: (+1)
   \   0000002E   0xB910             CBNZ.N   R0,??USB_Desc_Get_Descriptor_5
   \   00000030   0xF103 0x0016      ADD      R0,R3,#+22
   \   00000034   0x6010             STR      R0,[R2, #+0]
   \                     ??USB_Desc_Get_Descriptor_5: (+1)
   \   00000036   0x2009             MOVS     R0,#+9
   \   00000038   0xE7F6             B.N      ??USB_Desc_Get_Descriptor_4
   \                     ??USB_Desc_Get_Descriptor_0: (+1)
   \   0000003A   0xB925             CBNZ.N   R5,??USB_Desc_Get_Descriptor_6
   \   0000003C   0xF103 0x007C      ADD      R0,R3,#+124
   \   00000040   0x6010             STR      R0,[R2, #+0]
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0xE7F0             B.N      ??USB_Desc_Get_Descriptor_4
   \                     ??USB_Desc_Get_Descriptor_6: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x2301             MOVS     R3,#+1
   \   0000004A   0xF240 0x4609      MOVW     R6,#+1033
   \   0000004E   0x42B5             CMP      R5,R6
   \   00000050   0xD103             BNE.N    ??USB_Desc_Get_Descriptor_7
   \   00000052   0x2C03             CMP      R4,#+3
   \   00000054   0xDA02             BGE.N    ??USB_Desc_Get_Descriptor_8
   \   00000056   0x4623             MOV      R3,R4
   \   00000058   0xE000             B.N      ??USB_Desc_Get_Descriptor_8
   \                     ??USB_Desc_Get_Descriptor_7: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??USB_Desc_Get_Descriptor_8: (+1)
   \   0000005C   0x.... 0x....      ADR.W    R4,g_languages
   \   00000060   0x250C             MOVS     R5,#+12
   \   00000062   0xFB15 0x4000      SMLABB   R0,R5,R0,R4
   \   00000066   0x68C4             LDR      R4,[R0, #+12]
   \   00000068   0xF854 0x4023      LDR      R4,[R4, R3, LSL #+2]
   \   0000006C   0x6014             STR      R4,[R2, #+0]
   \   0000006E   0x6900             LDR      R0,[R0, #+16]
   \   00000070   0x5C18             LDRB     R0,[R3, R0]
   \   00000072   0xE7D9             B.N      ??USB_Desc_Get_Descriptor_4
   \                     ??USB_Desc_Get_Descriptor_2: (+1)
   \   00000074   0x2E08             CMP      R6,#+8
   \   00000076   0xDA18             BGE.N    ??USB_Desc_Get_Descriptor_9
   \   00000078   0xB920             CBNZ.N   R0,??USB_Desc_Get_Descriptor_10
   \   0000007A   0x.... 0x....      ADR.W    R4,g_std_descriptors
   \   0000007E   0xF854 0x4026      LDR      R4,[R4, R6, LSL #+2]
   \   00000082   0x6014             STR      R4,[R2, #+0]
   \                     ??USB_Desc_Get_Descriptor_10: (+1)
   \   00000084   0x2E01             CMP      R6,#+1
   \   00000086   0xD102             BNE.N    ??USB_Desc_Get_Descriptor_11
   \   00000088   0x681C             LDR      R4,[R3, #+0]
   \   0000008A   0x1C64             ADDS     R4,R4,#+1
   \   0000008C   0x601C             STR      R4,[R3, #+0]
   \                     ??USB_Desc_Get_Descriptor_11: (+1)
   \   0000008E   0x681C             LDR      R4,[R3, #+0]
   \   00000090   0x2C02             CMP      R4,#+2
   \   00000092   0xBFA4             ITT      GE 
   \   00000094   0x2400             MOVGE    R4,#+0
   \   00000096   0x601C             STRGE    R4,[R3, #+0]
   \   00000098   0x6812             LDR      R2,[R2, #+0]
   \   0000009A   0xB132             CBZ.N    R2,??USB_Desc_Get_Descriptor_9
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD1C4             BNE.N    ??USB_Desc_Get_Descriptor_3
   \   000000A0   0x.... 0x....      ADR.W    R0,g_std_desc_size
   \   000000A4   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   000000A8   0xE7BE             B.N      ??USB_Desc_Get_Descriptor_4
   \                     ??USB_Desc_Get_Descriptor_9: (+1)
   \   000000AA   0x20CE             MOVS     R0,#+206
   \   000000AC   0xBD76             POP      {R1,R2,R4-R6,PC}
    621          }
    622          
    623          /**************************************************************************//*!
    624           *
    625           * @name  USB_Desc_Get_Interface
    626           *
    627           * @brief The function returns the alternate interface
    628           *
    629           * @param controller_ID : Controller ID
    630           * @param interface     : Interface number
    631           * @param alt_interface : Output alternate interface
    632           *
    633           * @return USB_OK                              When Successfull
    634           *         USBERR_INVALID_REQ_TYPE             when Error
    635           *****************************************************************************
    636           *This function is called by the framework module to get the current interface
    637           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    638          uint8_t USB_Desc_Get_Interface(
    639                hid_handle_t handle,
    640                uint8_t interface,         /* [IN] Interface number */
    641                uint_8_ptr alt_interface  /* [OUT] Output alternate interface */
    642          )
    643          {
    644              UNUSED (handle)
    645              /* if interface valid */
    646              if(interface < USB_MAX_SUPPORTED_INTERFACES)
   \                     USB_Desc_Get_Interface: (+1)
   \   00000000   0xB921             CBNZ.N   R1,??USB_Desc_Get_Interface_0
    647              {
    648                  /* get alternate interface*/
    649                  *alt_interface = g_alternate_interface[interface];
   \   00000002   0x....             LDR.N    R0,??DataTable13_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x7010             STRB     R0,[R2, #+0]
    650                  return USB_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR
    651              }
    652              return USBERR_INVALID_REQ_TYPE;
   \                     ??USB_Desc_Get_Interface_0: (+1)
   \   0000000C   0x20CE             MOVS     R0,#+206
   \   0000000E   0x4770             BX       LR               ;; return
    653          }
    654          
    655          /**************************************************************************//*!
    656           *
    657           * @name  USB_Desc_Set_Interface
    658           *
    659           * @brief The function sets the alternate interface
    660           *
    661           * @param controller_ID : Controller ID
    662           * @param interface     : Interface number
    663           * @param alt_interface : Input alternate interface
    664           *
    665           * @return USB_OK                              When Successfull
    666           *         USBERR_INVALID_REQ_TYPE             when Error
    667           *****************************************************************************
    668           *This function is called by the framework module to set the interface
    669           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    670          uint8_t USB_Desc_Set_Interface(
    671                hid_handle_t handle,
    672                uint8_t interface,     /* [IN] Interface number */
    673                uint8_t alt_interface  /* [IN] Input alternate interface */
    674          )
    675          {
    676              UNUSED (handle)
    677              /* if interface valid */
    678              if(interface < USB_MAX_SUPPORTED_INTERFACES)
   \                     USB_Desc_Set_Interface: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xBF03             ITTTE    EQ 
   \   00000004   0x....             LDREQ.N  R0,??DataTable13_1
   \   00000006   0x7002             STRBEQ   R2,[R0, #+0]
   \   00000008   0x2000             MOVEQ    R0,#+0
   \   0000000A   0x20CE             MOVNE    R0,#+206
    679              {
    680                  /* set alternate interface*/
    681                  g_alternate_interface[interface] = alt_interface;
    682                  return USB_OK;
    683              }
    684          
    685              return USBERR_INVALID_REQ_TYPE;
   \   0000000C   0x4770             BX       LR
    686          }
    687          
    688          /**************************************************************************//*!
    689           *
    690           * @name  USB_Set_Configation
    691           *
    692           * @brief The function checks whether the configuration parameter
    693           *        input is valid or not
    694           *
    695           * @param handle          handle
    696           * @param config_val      configuration value
    697           *
    698           * @return TRUE           When Valid
    699           *         FALSE          When Error
    700           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    701          uint8_t USB_Set_Configation
    702          (
    703              hid_handle_t handle,
    704              uint8_t config
    705          )
    706          {
    707              UNUSED (handle)
    708          
    709              return USB_OK;
   \                     USB_Set_Configation: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    710          }
    711          
    712          /**************************************************************************//*!
    713           *
    714           * @name  USB_Desc_Valid_Configation
    715           *
    716           * @brief The function checks whether the configuration parameter
    717           *        input is valid or not
    718           *
    719           * @param controller_ID : Controller ID
    720           * @param config_val    : Configuration value
    721           *
    722           * @return TRUE           When Valid
    723           *         FALSE          When Error
    724           *****************************************************************************
    725           * This function checks whether the configuration is valid or not
    726           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    727          bool USB_Desc_Valid_Configation(
    728                hid_handle_t handle,
    729                uint16_t config_val)   //[IN] Configuration value 
    730          {
    731              uint8_t loop_index=0;
   \                     USB_Desc_Valid_Configation: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    732              UNUSED (handle)
   \   00000002   0x.... 0x....      ADR.W    R2,g_valid_config_values
    733          
    734              // check with only supported val right now 
    735              while(loop_index < (USB_MAX_CONFIG_SUPPORTED+1))
    736              {
    737                  if(config_val == g_valid_config_values[loop_index])
   \                     ??USB_Desc_Valid_Configation_0: (+1)
   \   00000006   0x5C83             LDRB     R3,[R0, R2]
   \   00000008   0x4299             CMP      R1,R3
   \   0000000A   0xD101             BNE.N    ??USB_Desc_Valid_Configation_1
    738                  {
    739                      return TRUE;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
    740                  }
    741                  loop_index++;
   \                     ??USB_Desc_Valid_Configation_1: (+1)
   \   00000010   0x1C40             ADDS     R0,R0,#+1
    742              }
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xDBF6             BLT.N    ??USB_Desc_Valid_Configation_0
    743              return FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    744          }
    745          
    746          /**************************************************************************//*!
    747           *
    748           * @name  USB_Desc_Valid_Interface
    749           *
    750           * @brief The function checks whether the interface parameter
    751           *        input is valid or not
    752           *
    753           * @param controller_ID : Controller ID
    754           * @param interface     : Target interface
    755           *
    756           * @return TRUE           When Valid
    757           *         FALSE          When Error
    758           *****************************************************************************
    759           * This function checks whether the interface is valid or not
    760           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    761          bool USB_Desc_Valid_Interface(
    762                hid_handle_t handle,
    763                uint8_t interface      /*[IN] Target interface */
    764          )
    765          {
    766              uint8_t loop_index=0;
    767              UNUSED (handle)
    768          
    769              /* check with only supported val right now */
    770              while(loop_index < USB_MAX_SUPPORTED_INTERFACES)
    771              {
    772                  if(interface == g_alternate_interface[loop_index])
   \                     USB_Desc_Valid_Interface: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xBF0C             ITE      EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   \   0000000A   0x2000             MOVNE    R0,#+0
    773                  {
    774                      return TRUE;
    775                  }
    776                  loop_index++;
    777              }
    778              return FALSE;
   \   0000000C   0x4770             BX       LR
    779          }
    780          /**************************************************************************//*!
    781           *
    782           * @name  USB_Desc_Remote_Wakeup
    783           *
    784           * @brief The function checks whether the remote wakeup is supported or not
    785           *
    786           * @param controller_ID : Controller ID
    787           *
    788           * @return REMOTE_WAKEUP_SUPPORT (TRUE) - If remote wakeup supported
    789           *****************************************************************************
    790           * This function returns remote wakeup is supported or not
    791           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    792          bool USB_Desc_Remote_Wakeup(
    793                hid_handle_t handle
    794          )
    795          {
    796              UNUSED (handle)
    797              return REMOTE_WAKEUP_SUPPORT;
   \                     USB_Desc_Remote_Wakeup: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    798          }
    799          
    800          
    801          /**************************************************************************//*!
    802           *
    803           * @name  USB_Desc_Get_Endpoints
    804           *
    805           * @brief The function returns with the list of all non control endpoints used
    806           *
    807           * @param controller_ID : Controller ID
    808           *
    809           * @return pointer to USB_ENDPOINTS
    810           *****************************************************************************
    811           * This function returns the information about all the non control endpoints
    812           * implemented
    813           *****************************************************************************/
    814          // JB void* USB_Desc_Get_Endpoints(

   \                                 In section .text, align 2, keep-with-next
    815          extern usb_endpoints_t *USB_Desc_Get_Endpoints(hid_handle_t handle)
    816          {
    817              UNUSED (handle)
    818              return (void*)&usb_desc_ep;
   \                     USB_Desc_Get_Endpoints: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_2
   \   00000002   0x4770             BX       LR               ;; return
    819          }
    820          

   \                                 In section .text, align 2, keep-with-next
    821          uint8_t USB_Desc_Get_Entity(
    822                hid_handle_t handle,
    823                entity_type type,
    824                uint32_t * object)
    825          {
   \                     USB_Desc_Get_Entity: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    826              switch (type)
   \   00000002   0xB949             CBNZ.N   R1,??USB_Desc_Get_Entity_0
    827              {
    828                  case USB_CLASS_INFO:
    829                      g_usb_if[0].index = 1;
   \   00000004   0x....             LDR.N    R0,??DataTable13_3
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    830                      g_usb_if[0].endpoints = usb_desc_ep;
   \   0000000A   0x....             LDR.N    R1,??DataTable13_2
   \   0000000C   0xE9D1 0x4500      LDRD     R4,R5,[R1, #+0]
   \   00000010   0xE9C0 0x4501      STRD     R4,R5,[R0, #+4]
    831                      *object = (unsigned long)&g_usb_dec_class;
   \   00000014   0x300C             ADDS     R0,R0,#+12
   \   00000016   0x6010             STR      R0,[R2, #+0]
    832                      break;
    833                  default :
    834                      break;
    835              }/* End Switch */
    836              return USB_OK;
   \                     ??USB_Desc_Get_Entity_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD30             POP      {R4,R5,PC}       ;; return
    837          }
    838          

   \                                 In section .data, align 4
    839          usb_desc_request_notify_struct_t  g_desc_callback =
   \                     g_desc_callback:
   \   00000000   0x........         DC32 USB_Desc_Get_Descriptor, USB_Desc_Get_Interface
   \              0x........   
   \   00000008   0x........         DC32 USB_Desc_Set_Interface, USB_Set_Configation, USB_Desc_Get_Entity
   \              0x........   
   \              0x........   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     device_desc_req_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     g_alternate_interface

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     usb_desc_ep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     g_usb_if
    840          {
    841              USB_Desc_Get_Descriptor,
    842              USB_Desc_Get_Interface,
    843              USB_Desc_Set_Interface,
    844              USB_Set_Configation,
    845              USB_Desc_Get_Entity
    846          };

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USB_Desc_Get_Descriptor
        24   -> usb_get_instance_via_ipsr
       0   USB_Desc_Get_Endpoints
      12   USB_Desc_Get_Entity
       0   USB_Desc_Get_Interface
       0   USB_Desc_Remote_Wakeup
       0   USB_Desc_Set_Interface
       0   USB_Desc_Valid_Configation
       0   USB_Desc_Valid_Interface
       0   USB_Set_Configation


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
     174  USB_Desc_Get_Descriptor
       4  USB_Desc_Get_Endpoints
      28  USB_Desc_Get_Entity
      16  USB_Desc_Get_Interface
       4  USB_Desc_Remote_Wakeup
      14  USB_Desc_Set_Interface
      28  USB_Desc_Valid_Configation
      14  USB_Desc_Valid_Interface
      60  USB_STR_1
      40  USB_STR_2
      36  USB_STR_n
       4  USB_Set_Configation
     128  device_desc_req_count
          g_config_descriptor
          g_report_descriptor
          USB_STR_0
       1  g_alternate_interface
      20  g_desc_callback
      20  g_device_descriptor
      12  g_device_qualifier_descriptor
      16  g_ep
       4  g_lang_ptr
      20  g_languages
      44  g_other_speed_config_descriptor
      36  g_std_desc_size
      36  g_std_desc_size_hs
      36  g_std_descriptors
      36  g_std_descriptors_hs
       4  g_string_desc_size
      16  g_string_descriptors
      24  g_usb_if
          g_usb_dec_class
       2  g_valid_config_values
       8  usb_desc_ep

 
   5 bytes in section .bss
 408 bytes in section .data
  92 bytes in section .rodata
 396 bytes in section .text
 
 396 bytes of CODE  memory
  92 bytes of CONST memory
 413 bytes of DATA  memory

Errors: none
Warnings: none
