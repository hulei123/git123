###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\bootloader.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\bootloader.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\bootloader.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\bootloader.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\bootloader.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <stdbool.h>
     32          #include "utilities/fsl_assert.h"
     33          #include "bootloader/context.h"
     34          #include "bootloader/peripheral.h"
     35          #include "bootloader/shutdown_cleanup.h"
     36          #include "bootloader_common.h"
     37          #include "microseconds/microseconds.h"
     38          #include "bootloader/bootloader.h"
     39          #include "flash/flash.h"
     40          #include "smc/smc.h"
     41          #include "microseconds/microseconds.h"
     42          #include "property/property.h"
     43          #include "utilities/vector_table_info.h"
     44          #include "utilities/fsl_rtos_abstraction.h"
     45          #if BL_ENABLE_CRC_CHECK
     46          #include "bootloader/app_crc_check.h"
     47          #endif
     48          
     49          //! @addtogroup bl_core
     50          //! @{
     51          
     52          ////////////////////////////////////////////////////////////////////////////////
     53          // Prototypes
     54          ////////////////////////////////////////////////////////////////////////////////
     55          
     56          #if DEBUG && !DEBUG_PRINT_DISABLE
     57          static const char * get_peripheral_name(uint32_t peripheralTypeMask);
     58          #endif
     59          
     60          static void get_user_application_entry(uint32_t *appEntry, uint32_t *appStack);
     61          static void jump_to_application(uint32_t applicationAddress, uint32_t stackPointer);
     62          static peripheral_descriptor_t const * get_active_peripheral(void);
     63          static void bootloader_init(void);
     64          static void bootloader_run(void);
     65          static bool is_direct_boot(void);
     66          
     67          void main(void);
     68          
     69          ////////////////////////////////////////////////////////////////////////////////
     70          // Variables
     71          ////////////////////////////////////////////////////////////////////////////////
     72          
     73          #if DEBUG && !DEBUG_PRINT_DISABLE
     74          static const char * const kPeripheralNames[] =
     75              {
     76                  "UART", // kPeripheralType_UART
     77                  "I2C", // kPeripheralType_I2CSlave
     78                  "SPI", // kPeripheralType_SPISlave
     79                  "CAN", // kPeripheralType_CAN
     80                  "HID", // kPeripheralType_USB_HID
     81                  "CDC", // kPeripheralType_USB_CDC
     82                  "DFU", // kPeripheralType_USB_DFU
     83                  "MSD" // kPeripheralType_USB_MSC
     84              };
     85          #endif // DEBUG
     86          
     87          ////////////////////////////////////////////////////////////////////////////////
     88          // Code
     89          ////////////////////////////////////////////////////////////////////////////////
     90          
     91          #if DEBUG && !DEBUG_PRINT_DISABLE
     92          //! @brief Returns the name of a peripheral given its type mask.
     93          const char * get_peripheral_name(uint32_t peripheralTypeMask)
     94          {
     95              unsigned i;
     96              for (i=0; i < ARRAY_SIZE(kPeripheralNames); ++i)
     97              {
     98                  if (peripheralTypeMask & (1 << i))
     99                  {
    100                      return kPeripheralNames[i];
    101                  }
    102              }
    103          
    104              return "Unknown peripheral";
    105          }
    106          #endif // DEBUG
    107          
    108          //! @brief Returns the user application address and stack pointer.
    109          //!
    110          //! For flash-resident and rom-resident target, gets the user application address
    111          //! and stack pointer from the APP_VECTOR_TABLE.
    112          //! Ram-resident version does not support jumping to application address.
    113          static void get_user_application_entry(uint32_t *appEntry, uint32_t *appStack)
    114          {
    115              assert(appEntry);
    116              assert(appStack);
    117          
    118          #if BL_TARGET_RAM
    119              *appEntry = NULL;
    120              *appStack = NULL;
    121          #else
    122              *appEntry = APP_VECTOR_TABLE[kInitialPC];
    123              *appStack = APP_VECTOR_TABLE[kInitialSP];
    124          #endif
    125          }
    126          
    127          //! @brief Return the value of the direct boot flag in the BCA.
    128          bool is_direct_boot(void)
    129          {
    130              bootloader_configuration_data_t * configurationData = &g_bootloaderContext.propertyInterface->store->configurationData;
    131          
    132              return (~configurationData->bootFlags) & kBootFlag_DirectBoot;
    133          }
    134          
    135          //! @brief Exits bootloader and jumps to the user application.

   \                                 In section .text, align 2, keep-with-next
    136          static void jump_to_application(uint32_t applicationAddress, uint32_t stackPointer)
    137          {
   \                     jump_to_application: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    138              shutdown_cleanup(kShutdownType_Shutdown);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       shutdown_cleanup
    139          
    140              // Create the function call to the user application.
    141              // Static variables are needed since changed the stack pointer out from under the compiler
    142              // we need to ensure the values we are using are not stored on the previous stack
    143              static uint32_t s_stackPointer = 0;
    144              s_stackPointer = stackPointer;
   \   0000000C   0x....             LDR.N    R0,??DataTable3
    145              static void (*farewellBootloader)(void) = 0;
    146              farewellBootloader = (void (*)(void))applicationAddress;
    147          
    148              // Set the VTOR to the application vector table address.
    149              SCB->VTOR = (uint32_t)APP_VECTOR_TABLE;
   \   0000000E   0x....             LDR.N    R2,??DataTable3_1  ;; 0xe000ed08
   \   00000010   0x6005             STR      R5,[R0, #+0]
   \   00000012   0x6044             STR      R4,[R0, #+4]
   \   00000014   0xF44F 0x4120      MOV      R1,#+40960
   \   00000018   0x6011             STR      R1,[R2, #+0]
    150          
    151              // Set stack pointers to the application stack pointer.
    152              __set_MSP(s_stackPointer);
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF381 0x8808      MSR      MSP,R1
    153              __set_PSP(s_stackPointer);
   \   00000020   0xF381 0x8809      MSR      PSP,R1
    154          
    155              // Jump to the application.
    156              farewellBootloader();
   \   00000024   0x6840             LDR      R0,[R0, #+4]
   \   00000026   0x4780             BLX      R0
    157              // Dummy fcuntion call, should never go to this fcuntion call
    158              shutdown_cleanup(kShutdownType_Shutdown);
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      B.W      shutdown_cleanup
    159          }

   \                                 In section .bss, align 4
   \                     ??s_stackPointer:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    160          
    161          //! A given jump address is considered valid if:
    162          //! - Not 0x00000000
    163          //! - Not 0xffffffff
    164          //! - Not the reset handler entry point for the bootloader
    165          //! - Is in flash or is in RAM or QuadSPI (if available)
    166          //! @note this interface is also used by the configure_quadspi command

   \                                 In section .text, align 2, keep-with-next
    167          bool is_valid_application_location(uint32_t applicationAddress)
    168          {
    169              property_store_t * store = g_bootloaderContext.propertyInterface->store;
   \                     is_valid_application_location: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable3_2
   \   00000002   0x6889             LDR      R1,[R1, #+8]
   \   00000004   0x6909             LDR      R1,[R1, #+16]
    170          
    171              bool isValid;
    172              // Verify that the jumpLocation is non zero and then either within flash or RAM, both calculations are:
    173              // (jumpLocation >= startAddress) && (jumpLocation < (startAddress + size))
    174              isValid = (  applicationAddress &&                                  // address is not null AND
    175                       (applicationAddress != 0xffffffff) &&                      // address is not blank Flash (0xff) AND
    176                       (applicationAddress != (uint32_t)&Reset_Handler) &&        // address is not bootloader AND
    177                      ((applicationAddress >= store->flashStartAddress) &&        // address is in Flash OR
    178                       (applicationAddress < (store->flashStartAddress +
    179                                              store->flashSizeInBytes))) ||
    180                      ((applicationAddress >= store->ramStartAddress) &&          // address is in Ram
    181                       (applicationAddress < (store->ramStartAddress +
    182                                              store->ramSizeInBytes))));
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xBF1E             ITTT     NE 
   \   0000000A   0xF110 0x0F01      CMNNE    R0,#+1
   \   0000000E   0x....             LDRNE.N  R2,??DataTable3_3
   \   00000010   0x4290             CMPNE    R0,R2
   \   00000012   0xD006             BEQ.N    ??is_valid_application_location_0
   \   00000014   0x690A             LDR      R2,[R1, #+16]
   \   00000016   0x4290             CMP      R0,R2
   \   00000018   0xD303             BCC.N    ??is_valid_application_location_0
   \   0000001A   0x694B             LDR      R3,[R1, #+20]
   \   0000001C   0x189A             ADDS     R2,R3,R2
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xD308             BCC.N    ??is_valid_application_location_1
   \                     ??is_valid_application_location_0: (+1)
   \   00000022   0x6A4A             LDR      R2,[R1, #+36]
   \   00000024   0x4290             CMP      R0,R2
   \   00000026   0xD307             BCC.N    ??is_valid_application_location_2
   \   00000028   0x6A89             LDR      R1,[R1, #+40]
   \   0000002A   0x1889             ADDS     R1,R1,R2
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0x4180             SBCS     R0,R0,R0
   \   00000030   0x0FC0             LSRS     R0,R0,#+31
   \   00000032   0x4770             BX       LR
   \                     ??is_valid_application_location_1: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x4770             BX       LR
   \                     ??is_valid_application_location_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
    183          #if BL_HAS_QSPI_MODULE
    184          
    185              if ((!isValid) && is_qspi_present() && (store->qspiInitStatus == kStatus_Success))
    186              {
    187                  const memory_map_entry_t* map = (const memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexQspiMemory];
    188          
    189                  isValid = (applicationAddress >= map->startAddress) && (applicationAddress <= map->endAddress);
    190              }
    191          
    192          #endif // BL_HAS_QSPI_MODULE
    193          
    194          
    195              return isValid;
   \   0000003A   0x4770             BX       LR               ;; return
    196          }
    197          
    198          //! @brief Jump application is considered ready for executing if the location is valid and crc check is passed
    199          static bool is_application_ready_for_executing(uint32_t applicationAddress)
    200          {
    201              bool result = is_valid_application_location(applicationAddress);
    202          
    203          #if BL_ENABLE_CRC_CHECK
    204              // Validate application crc only if its location is valid
    205              if (result)
    206              {
    207                  result = is_application_crc_check_pass();
    208              }
    209          #endif
    210              return result;
    211          }
    212          
    213          //! @brief Determines the active peripheral.
    214          //!
    215          //! This function has several stages:
    216          //! - Init enabled peripherals.
    217          //! - Compute timeout.
    218          //! - Wait for peripheral activity with timeout.
    219          //! - Shutdown inactive peripherals.
    220          //!
    221          //! If peripheral detection times out, then this function will call jump_to_application() to
    222          //! directly enter the user application.
    223          //!
    224          //! The timeout value comes from the BCA if set, or the #BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT
    225          //! configuration macro. If the boot pin is asserted, or if there is not a valid user application
    226          //! in flash, then the timeout is disabled and peripheral detection will continue infinitely.

   \                                 In section .text, align 2, keep-with-next
    227          static peripheral_descriptor_t const * get_active_peripheral(void)
    228          {
   \                     get_active_peripheral: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    229              peripheral_descriptor_t const * peripheral;
    230              peripheral_descriptor_t const * activePeripheral = NULL;
    231              bootloader_configuration_data_t * configurationData = &g_bootloaderContext.propertyInterface->store->configurationData;
   \   00000004   0x....             LDR.N    R5,??DataTable3_2
    232          
    233              // Bring up all the peripherals
    234              for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \   00000006   0x....             LDR.N    R6,??DataTable3_4
   \   00000008   0x68A8             LDR      R0,[R5, #+8]
   \   0000000A   0x6900             LDR      R0,[R0, #+16]
   \   0000000C   0xF100 0x0A70      ADD      R10,R0,#+112
   \   00000010   0x4637             MOV      R7,R6
   \   00000012   0xE00A             B.N      ??get_active_peripheral_0
    235              {
    236                  // Check that the peripheral is enabled in the user configuration data
    237                  if (configurationData->enabledPeripherals & peripheral->typeMask)
   \                     ??get_active_peripheral_1: (+1)
   \   00000014   0xF89A 0x1010      LDRB     R1,[R10, #+16]
   \   00000018   0x4201             TST      R1,R0
   \   0000001A   0xD005             BEQ.N    ??get_active_peripheral_2
    238                  {
    239                      assert(peripheral->controlInterface->init);
    240          
    241                      debug_printf("Initing %s\r\n", get_peripheral_name(peripheral->typeMask));
    242                      peripheral->controlInterface->init(peripheral, peripheral->packetInterface->byteReceivedCallback);
   \   0000001C   0x6978             LDR      R0,[R7, #+20]
   \   0000001E   0x68FA             LDR      R2,[R7, #+12]
   \   00000020   0x6981             LDR      R1,[R0, #+24]
   \   00000022   0x6852             LDR      R2,[R2, #+4]
   \   00000024   0x4638             MOV      R0,R7
   \   00000026   0x4790             BLX      R2
    243                  }
    244              }
   \                     ??get_active_peripheral_2: (+1)
   \   00000028   0x3718             ADDS     R7,R7,#+24
   \                     ??get_active_peripheral_0: (+1)
   \   0000002A   0x6838             LDR      R0,[R7, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD1F1             BNE.N    ??get_active_peripheral_1
    245          
    246              uint64_t lastTicks;          // Value of our last recorded ticks second marker
    247              uint32_t timeoutTicks = 0;   // The number of ticks we will wait for timeout, 0 means no timeout
    248          #if BL_FEATURE_POWERDOWN
    249              bool  shortTimeout = false;
    250          #endif
    251              const uint32_t ticksPerMillisecond = microseconds_convert_to_ticks(1000);
   \   00000030   0xF44F 0x707A      MOV      R0,#+1000
   \   00000034   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   00000038   0x4607             MOV      R7,R0
    252          
    253              // Get the user application entry point and stack pointer.
    254              uint32_t applicationAddress, stackPointer;
    255              get_user_application_entry(&applicationAddress, &stackPointer);
   \   0000003A   0xF44F 0x4020      MOV      R0,#+40960
   \   0000003E   0x2400             MOVS     R4,#+0
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0x9100             STR      R1,[SP, #+0]
   \   00000044   0xF8D0 0xB000      LDR      R11,[R0, #+0]
    256          
    257              // If the boot to rom option is not set AND there is a valid jump application determine the timeout value
    258              if (!is_boot_pin_asserted() && is_application_ready_for_executing(applicationAddress))
   \   00000048   0x.... 0x....      BL       is_boot_pin_asserted
   \   0000004C   0xBB70             CBNZ.N   R0,??get_active_peripheral_3
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x.... 0x....      BL       is_valid_application_location
   \   00000054   0xB350             CBZ.N    R0,??get_active_peripheral_3
   \   00000056   0x.... 0x....      BL       is_application_crc_check_pass
   \   0000005A   0xB338             CBZ.N    R0,??get_active_peripheral_3
    259              {
    260                  if (is_direct_boot())
   \   0000005C   0x68A8             LDR      R0,[R5, #+8]
   \   0000005E   0x6900             LDR      R0,[R0, #+16]
   \   00000060   0xF890 0x008E      LDRB     R0,[R0, #+142]
   \   00000064   0x07C0             LSLS     R0,R0,#+31
   \   00000066   0xD403             BMI.N    ??get_active_peripheral_4
    261                  {
    262                      jump_to_application(applicationAddress, stackPointer);
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x4659             MOV      R1,R11
   \   0000006C   0x.... 0x....      BL       jump_to_application
    263                  }
    264          
    265                  // Calculate how many ticks we need to wait based on the bootloader config. Check to see if
    266                  // there is a valid configuration data value for the timeout. If there's not, use the
    267                  // default timeout value.
    268                  uint32_t milliseconds;
    269                  if (configurationData->peripheralDetectionTimeoutMs != 0xFFFF)
   \                     ??get_active_peripheral_4: (+1)
   \   00000070   0xF8BA 0x0012      LDRH     R0,[R10, #+18]
   \   00000074   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xBF08             IT       EQ 
   \   0000007C   0xF241 0x3088      MOVWEQ   R0,#+5000
    270                  {
    271                      milliseconds = configurationData->peripheralDetectionTimeoutMs;
    272                  }
    273                  else
    274                  {
    275                      milliseconds = BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT;
    276                  }
    277                  timeoutTicks = milliseconds * ticksPerMillisecond;
   \   00000080   0xFB07 0xF400      MUL      R4,R7,R0
    278          
    279                  // save how many ticks we're currently at before the detection loop starts
    280                  lastTicks = microseconds_get_ticks();
   \   00000084   0x.... 0x....      BL       microseconds_get_ticks
   \   00000088   0x4680             MOV      R8,R0
   \   0000008A   0x4689             MOV      R9,R1
    281          #if BL_FEATURE_POWERDOWN
    282                  shortTimeout = true;
    283          #endif
    284              }
    285          #if BL_FEATURE_POWERDOWN
    286              else
    287              {
    288                  timeoutTicks = BL_DEFAULT_POWERDOWN_TIMEOUT * ticksPerMillisecond;
    289                  lastTicks = microseconds_get_ticks();
    290              }
    291          #endif
    292          
    293              // Wait for a peripheral to become active
    294              while (activePeripheral == NULL)
    295              {
    296                  // If timeout is enabled, check to see if we've exceeded it.
    297                  if (timeoutTicks)
   \                     ??get_active_peripheral_5: (+1)
   \   0000008C   0xB174             CBZ.N    R4,??get_active_peripheral_3
    298                  {
    299                      // Note that we assume that the tick counter won't overflow and wrap back to 0.
    300                      // The timeout value is only up to 65536 milliseconds, and the tick count starts
    301                      // at zero when when inited the microseconds driver just a few moments ago.
    302                      uint64_t elapsedTicks = microseconds_get_ticks() - lastTicks;
    303          
    304                      // Check if the elapsed time is longer than the timeout.
    305                      if (elapsedTicks >= timeoutTicks)
   \   0000008E   0x.... 0x....      BL       microseconds_get_ticks
   \   00000092   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000096   0xEB61 0x0109      SBC      R1,R1,R9
   \   0000009A   0x2500             MOVS     R5,#+0
   \   0000009C   0x42A9             CMP      R1,R5
   \   0000009E   0xD801             BHI.N    ??get_active_peripheral_6
   \   000000A0   0x42A0             CMP      R0,R4
   \   000000A2   0xD303             BCC.N    ??get_active_peripheral_3
    306                      {
    307          #if BL_FEATURE_POWERDOWN
    308                          if(shortTimeout)
    309                          {
    310          #endif
    311                              // In the case of the typical peripheral timeout, jump to the user application.
    312                              jump_to_application(applicationAddress, stackPointer);
   \                     ??get_active_peripheral_6: (+1)
   \   000000A4   0x9800             LDR      R0,[SP, #+0]
   \   000000A6   0x4659             MOV      R1,R11
   \   000000A8   0x.... 0x....      BL       jump_to_application
    313          #if BL_FEATURE_POWERDOWN
    314                          }
    315                          else
    316                          {
    317                              // Make sure a timeout value has been defined before shutting down.
    318                              if(BL_DEFAULT_POWERDOWN_TIMEOUT)
    319                              {
    320                                  // Shut down the bootloader and return to reset-type state prior to low
    321                                  // power entry
    322                                  shutdown_cleanup(kShutdownType_Shutdown);
    323          
    324                                  // Enter VLLS1 low power mode
    325                                  enter_vlls1();
    326                              }
    327                          }
    328          #endif
    329                      }
    330                  }
    331          
    332                  // Traverse through all the peripherals
    333                  for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \                     ??get_active_peripheral_3: (+1)
   \   000000AC   0x4637             MOV      R7,R6
   \   000000AE   0xE000             B.N      ??get_active_peripheral_7
   \                     ??get_active_peripheral_8: (+1)
   \   000000B0   0x3718             ADDS     R7,R7,#+24
   \                     ??get_active_peripheral_7: (+1)
   \   000000B2   0x6838             LDR      R0,[R7, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD0E9             BEQ.N    ??get_active_peripheral_5
    334                  {
    335                      assert(peripheral->controlInterface->pollForActivity);
    336          
    337                      if (peripheral->controlInterface->pollForActivity(peripheral))
   \   000000B8   0x68F9             LDR      R1,[R7, #+12]
   \   000000BA   0x6809             LDR      R1,[R1, #+0]
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0x4788             BLX      R1
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD0F5             BEQ.N    ??get_active_peripheral_8
    338                      {
    339                          debug_printf("%s is active\r\n", get_peripheral_name(peripheral->typeMask));
    340          
    341                          activePeripheral = peripheral;
    342                          break;
    343                      }
    344                  }
    345              }
   \   000000C4   0x2F00             CMP      R7,#+0
   \   000000C6   0xD0E1             BEQ.N    ??get_active_peripheral_5
    346          
    347              // Shut down all non active peripherals
    348              for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \   000000C8   0xE006             B.N      ??get_active_peripheral_9
    349              {
    350                  if (activePeripheral != peripheral)
   \                     ??get_active_peripheral_10: (+1)
   \   000000CA   0x42B7             CMP      R7,R6
   \   000000CC   0xD003             BEQ.N    ??get_active_peripheral_11
    351                  {
    352                      debug_printf("Shutting down %s\r\n", get_peripheral_name(peripheral->typeMask));
    353          
    354                      assert(peripheral->controlInterface->shutdown);
    355                      peripheral->controlInterface->shutdown(peripheral);
   \   000000CE   0x68F1             LDR      R1,[R6, #+12]
   \   000000D0   0x6889             LDR      R1,[R1, #+8]
   \   000000D2   0x4630             MOV      R0,R6
   \   000000D4   0x4788             BLX      R1
    356                  }
    357              }
   \                     ??get_active_peripheral_11: (+1)
   \   000000D6   0x3618             ADDS     R6,R6,#+24
   \                     ??get_active_peripheral_9: (+1)
   \   000000D8   0x6830             LDR      R0,[R6, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD1F5             BNE.N    ??get_active_peripheral_10
    358          
    359              return activePeripheral;
   \   000000DE   0x4638             MOV      R0,R7
   \   000000E0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    360          }
    361          
    362          //! @brief Initialize the bootloader and peripherals.
    363          //!
    364          //! This function initializes hardware and clocks, loads user configuration data, and initialzes
    365          //! a number of drivers. It then enters the active peripheral detection phase by calling
    366          //! get_active_peripheral(). Once the peripheral is detected, the packet and comand interfaces
    367          //! are initialized.
    368          //!
    369          //! Note that this routine may not return if peripheral detection times out and the bootloader
    370          //! jumps directly to the user application in flash.
    371          static void bootloader_init(void)
    372          {
    373              // Init the global irq lock
    374              lock_init();
    375          
    376              // Init pinmux and other hardware setup.
    377              init_hardware();
    378          
    379              // Load the user configuration data so that we can configure the clocks
    380              g_bootloaderContext.propertyInterface->load_user_config();
    381          
    382              // Init QSPI module if needed
    383          #if BL_HAS_QSPI_MODULE
    384              if (qspi_need_configure())
    385              {
    386                  status_t qspiOtfadInitStatus = qspi_otfad_init(NULL);
    387                  update_qspi_otfad_init_status(qspiOtfadInitStatus);
    388              }
    389          #endif // BL_HAS_QSPI_MODULE
    390          
    391              // Configure clocks.
    392              configure_clocks(kClockOption_EnterBootloader);
    393          
    394              // Start the lifetime counter
    395              microseconds_init();
    396          
    397              // Init flash driver.
    398              flash_init(&g_bootloaderContext.flashState);
    399          
    400          #if BL_BYPASS_WATCHDOG
    401              flash_register_callback(&g_bootloaderContext.flashState, bootloader_watchdog_service);
    402              bootloader_watchdog_init();
    403          #endif // BL_BYPASS_WATCHDOG
    404          
    405              // Init address range of flash array, SRAM_L and SRAM U.
    406              g_bootloaderContext.memoryInterface->init();
    407          
    408              // Fully init the property store.
    409              g_bootloaderContext.propertyInterface->init();
    410          
    411          #if DEBUG
    412              // Initialize any debug functionality
    413              debug_init();
    414          #endif
    415          
    416              // Message so python instantiated debugger can tell the
    417              // bootloader application is running on the target.
    418              debug_printf("\r\n\r\nRunning bootloader...\r\n");
    419          
    420          #if DEBUG && !DEBUG_PRINT_DISABLE
    421              standard_version_t version = g_bootloaderContext.propertyInterface->store->bootloaderVersion;
    422              debug_printf("Bootloader version %c%d.%d.%d\r\n",
    423                  version.name, version.major, version.minor, version.bugfix);
    424          #endif
    425          
    426              // Wait for a peripheral to become active.
    427              g_bootloaderContext.activePeripheral = get_active_peripheral();
    428              assert(g_bootloaderContext.activePeripheral);
    429          
    430              // Validate required active peripheral interfaces.
    431              assert(g_bootloaderContext.activePeripheral->controlInterface);
    432          
    433              // Init the active peripheral.
    434              if (g_bootloaderContext.activePeripheral->byteInterface
    435                  && g_bootloaderContext.activePeripheral->byteInterface->init)
    436              {
    437                  g_bootloaderContext.activePeripheral->byteInterface->init(g_bootloaderContext.activePeripheral);
    438              }
    439              if (g_bootloaderContext.activePeripheral->packetInterface
    440                  && g_bootloaderContext.activePeripheral->packetInterface->init)
    441              {
    442                  g_bootloaderContext.activePeripheral->packetInterface->init(g_bootloaderContext.activePeripheral);
    443              }
    444          
    445              // Initialize the command processor component.
    446              g_bootloaderContext.commandInterface->init();
    447          }
    448          
    449          //! @brief Bootloader outer loop.
    450          //!
    451          //! Infinitely calls the command interface and active peripheral control interface pump routines.
    452          static void bootloader_run(void)
    453          {
    454              const peripheral_descriptor_t * activePeripheral = g_bootloaderContext.activePeripheral;
    455          
    456              assert(g_bootloaderContext.commandInterface->pump);
    457          
    458              // Read and execute commands.
    459              while (1)
    460              {
    461                  g_bootloaderContext.commandInterface->pump();
    462          
    463                  // Pump the active peripheral.
    464                  if (activePeripheral->controlInterface->pump)
    465                  {
    466                      activePeripheral->controlInterface->pump(activePeripheral);
    467                  }
    468              }
    469          }
    470          
    471          //! @brief Entry point for the bootloader.

   \                                 In section .text, align 2, keep-with-next
    472          void main(void)
    473          {
   \                     main: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    474              bootloader_init();
   \   00000002   0x.... 0x....      BL       lock_init
   \   00000006   0x.... 0x....      BL       init_hardware
   \   0000000A   0x....             LDR.N    R4,??DataTable3_2
   \   0000000C   0x68A0             LDR      R0,[R4, #+8]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x4780             BLX      R0
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       configure_clocks
   \   00000018   0x.... 0x....      BL       microseconds_init
   \   0000001C   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000020   0x.... 0x....      BL       flash_init
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4780             BLX      R0
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x4780             BLX      R0
   \   00000030   0x.... 0x....      BL       get_active_peripheral
   \   00000034   0x61E0             STR      R0,[R4, #+28]
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0xB119             CBZ.N    R1,??main_0
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0x000A             MOVS     R2,R1
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x4788             BLXNE    R1
   \                     ??main_0: (+1)
   \   00000042   0x69E0             LDR      R0,[R4, #+28]
   \   00000044   0x6941             LDR      R1,[R0, #+20]
   \   00000046   0xB119             CBZ.N    R1,??main_1
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x000A             MOVS     R2,R1
   \   0000004C   0xBF18             IT       NE 
   \   0000004E   0x4788             BLXNE    R1
   \                     ??main_1: (+1)
   \   00000050   0x68E0             LDR      R0,[R4, #+12]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x4780             BLX      R0
    475              bootloader_run();
   \   00000056   0x69E5             LDR      R5,[R4, #+28]
   \                     ??main_2: (+1)
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x6840             LDR      R0,[R0, #+4]
   \   0000005C   0x4780             BLX      R0
   \   0000005E   0x68E8             LDR      R0,[R5, #+12]
   \   00000060   0x68C1             LDR      R1,[R0, #+12]
   \   00000062   0x0008             MOVS     R0,R1
   \   00000064   0xD0F8             BEQ.N    ??main_2
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x4788             BLX      R1
   \   0000006A   0xE7F5             B.N      ??main_2
    476          
    477              // Should never end up here.
    478              debug_printf("Warning: reached end of main()\r\n");
    479          }
    480          
    481          //! Since we never exit this gets rid of the C standard functions that cause
    482          //! extra ROM size usage.

   \                                 In section .text, align 2, keep-with-next
    483          void exit(int arg)
    484          {
    485          }
   \                     exit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     ??s_stackPointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     Reset_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     g_peripherals
    486          
    487          //! @}
    488          
    489          ////////////////////////////////////////////////////////////////////////////////
    490          // EOF
    491          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   exit
      40   get_active_peripheral
        40   -- Indirect call
        40   -> is_application_crc_check_pass
        40   -> is_boot_pin_asserted
        40   -> is_valid_application_location
        40   -> jump_to_application
        40   -> microseconds_convert_to_ticks
        40   -> microseconds_get_ticks
       0   is_valid_application_location
      16   jump_to_application
        16   -- Indirect call
         0   -> shutdown_cleanup
        16   -> shutdown_cleanup
      16   main
        16   -- Indirect call
        16   -> configure_clocks
        16   -> flash_init
        16   -> get_active_peripheral
        16   -> init_hardware
        16   -> lock_init
        16   -> microseconds_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       2  exit
     228  get_active_peripheral
      60  is_valid_application_location
      50  jump_to_application
     108  main
       8  s_stackPointer
          farewellBootloader

 
   8 bytes in section .bss
 468 bytes in section .text
 
 468 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
