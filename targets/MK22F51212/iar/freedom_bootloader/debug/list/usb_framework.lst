###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:49
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\usb_framework.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\usb_framework.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_framework.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_framework.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\usb_framework.c
      1          /**HEADER********************************************************************
      2          * 
      3          * Copyright (c) 2008, 2013 - 2014 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          * Copyright (c) 1989-2008 ARC International;
      7          * All Rights Reserved
      8          *
      9          *************************************************************************** 
     10          *
     11          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     12          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     13          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     14          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     15          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     16          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     17          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     18          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     19          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     20          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     21          * THE POSSIBILITY OF SUCH DAMAGE.
     22          *
     23          **************************************************************************
     24          *
     25          * $FileName: usb_framework.c$
     26          * $Version : 
     27          * $Date    : 
     28          *
     29          * Comments:
     30          *
     31          * @brief The file contains USB stack framework module implementation.
     32          *
     33          *****************************************************************************/
     34          
     35          /******************************************************************************
     36           * Includes
     37           *****************************************************************************/
     38          #include "usb_device_config.h"
     39          #if USBCFG_DEV_KHCI || USBCFG_DEV_EHCI
     40          #include "usb.h"
     41          #include "usb_device_stack_interface.h"
     42          #include "usb_framework.h"
     43          
     44          /*****************************************************************************
     45           * Constant and Macro's
     46           *****************************************************************************/
     47          
     48          /****************************************************************************
     49           * Global Variables
     50           ****************************************************************************/
     51          //usb_class_fw_object_struct_t*  usb_class_fw_object[USB_MAX_CLASS_FW_OBJECT];
     52           
     53          #ifdef DELAYED_PROCESSING
     54              usb_event_struct_t g_f_event;
     55              bool g_control_pending=FALSE;
     56          #endif
     57          #if ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)) 
     58          static bool g_validate_request[MAX_STRD_REQ][3] = 
     59          #else

   \                                 In section .data, align 4
     60          static uint8_t g_validate_request[MAX_STRD_REQ][3] = 
   \                     g_validate_request:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0
   \              0x00 0x01    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x00    
   \              0x00         
   \   00000017   0x00 0x01          DC8 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x01 0x01    
   \              0x00 0x01    
   \              0x00 0x00    
   \              0x01 0x00    
   \              0x00 0x01    
   \              0x00 0x00    
   \              0x00         
   \   00000028   0x........         DC32 USB_Strd_Req_Get_Status, USB_Strd_Req_Feature, 0H
   \              0x........   
   \              0x00000000   
   \   00000034   0x........         DC32 USB_Strd_Req_Feature, 0H, USB_Strd_Req_Set_Address
   \              0x00000000   
   \              0x........   
   \   00000040   0x........         DC32 USB_Strd_Req_Get_Descriptor, 0H, USB_Strd_Req_Get_Config
   \              0x00000000   
   \              0x........   
   \   0000004C   0x........         DC32 USB_Strd_Req_Set_Config, USB_Strd_Req_Get_Interface
   \              0x........   
   \   00000054   0x........         DC32 USB_Strd_Req_Set_Interface, USB_Strd_Req_Sync_Frame
   \              0x........   
     61          #endif
     62          
     63          { 
     64            {1,   1,   0,}, /*USB_Strd_Req_Get_Status*/
     65                   /* configured state: valid for existing interfaces/endpoints
     66                      address state   : valid only for interface or endpoint 0
     67                      default state   : not specified
     68                   */ 
     69            {1,   1,   0,}, /* Clear Feature */
     70                   /* configured state: valid only for device in configured state
     71                      address state   : valid only for device (in address state), 
     72                                        interface and endpoint 0 
     73                      default state   : not specified
     74                   */
     75            {0,   0,   0,}, /*reserved for future use*/
     76                   /* configured state: request not supported
     77                      address state   : request not supported
     78                      default state   : request not supported
     79                   */ 
     80          #ifdef USBCFG_OTG
     81            {1,   1,   1,}, /* Set Feature */
     82                  /*  configured state: valid only for device in configured state
     83                      address state   : valid only for interface or endpoint 0
     84                      default state   : not specified
     85                  */
     86          #else 
     87            {1,   1,   0,}, /* Set Feature */
     88                    /*  configured state: valid only for device in configured state
     89                        address state   : valid only for interface or endpoint 0
     90                        default state   : not specified
     91                    */
     92          #endif
     93            {0,   0,   0,},/*reserved for future use*/
     94                  /*  configured state: request not supported            
     95                      address state   : request not supported
     96                      default state   : request not supported
     97                   */ 
     98            {0,   1,   1,}, /*USB_Strd_Req_Set_Address*/
     99                  /*  configured state: not specified            
    100                      address state   : changes to default state if specified addr == 0,
    101                                        but uses newly specified address
    102                      default state   : changes to address state if specified addr != 0
    103                   */
    104            {1,   1,   1,}, /*USB_Strd_Req_Get_Descriptor*/
    105                   /* configured state: valid request            
    106                      address state   : valid request
    107                      default state   : valid request
    108                   */
    109            {0,   0,   0,}, /*Set Descriptor*/
    110                   /* configured state: request not supported
    111                      address state   : request not supported
    112                      default state   : request not supported
    113                   */
    114            {1,   1,   0,}, /*USB_Strd_Req_Get_Config*/
    115                   /* configured state: bConfiguration Value of current config returned
    116                      address state   : value zero must be returned
    117                      default state   : not specified            
    118                   */
    119            {1,   1,   0,}, /*USB_Strd_Req_Set_Config*/
    120                   /* configured state: If the specified configuration value is zero, 
    121                                        then the device enters the Address state.If the 
    122                                        specified configuration value matches the 
    123                                        configuration value from a config descriptor, 
    124                                        then that config is selected and the device
    125                                        remains in the Configured state. Otherwise, the 
    126                                        device responds with a Request Error.
    127                   
    128                      address state   : If the specified configuration value is zero, 
    129                                        then the device remains in the Address state. If 
    130                                        the specified configuration value matches the 
    131                                        configuration value from a configuration 
    132                                        descriptor, then that configuration is selected 
    133                                        and the device enters the Configured state. 
    134                                        Otherwise,response is Request Error.
    135                      default state   : not specified
    136                   */
    137            {1,   0,   0,}, /*USB_Strd_Req_Get_Interface*/
    138                   /* configured state: valid request          
    139                      address state   : request error
    140                      default state   : not specified
    141                   */
    142            {1,   0,   0,}, /*USB_Strd_Req_Set_Interface*/
    143                   /* configured state: valid request
    144                      address state   : request error
    145                      default state   : not specified
    146                   */
    147            {1,   0,   0,}, /*USB_Strd_Req_Sync_Frame*/
    148                   /* configured state: valid request
    149                      address state   : request error
    150                      default state   : not specified
    151                   */ 
    152          };
    153          
    154          /****************************************************************************
    155           * Global Functions
    156           ****************************************************************************/
    157          extern usb_status usb_device_get_status(usb_device_handle, uint8_t, uint16_t *);
    158          
    159          extern usb_status usb_device_set_status(usb_device_handle, uint8_t, uint16_t);
    160          
    161          extern usb_status _usb_device_set_address(usb_device_handle, uint8_t);
    162          
    163          /*****************************************************************************
    164           * Local Types - None
    165           *****************************************************************************/
    166          
    167          /*****************************************************************************
    168           * Local Functions
    169           *****************************************************************************/
    170          usb_class_fw_handle USB_Framework_Init( usb_device_handle    handle, /*[IN]*/
    171                                                  usb_device_notify_t  class_callback,/*[IN]*/
    172                                                  usb_request_notify_t other_req_callback,/*[IN]*/
    173                                                  void* callback_data,/*[IN]*/
    174                                                  int32_t data,/*[IN]*/
    175                                                  usb_desc_request_notify_struct_t*  desc_callback_ptr /*[IN]*/);
    176          uint8_t USB_Framework_Deinit( usb_device_handle handle, /*[IN]*/
    177                                        usb_class_fw_handle fw_handle /*[IN]*/); 
    178          uint8_t USB_Framework_Reset(usb_device_handle handle);
    179          void USB_Control_Service (void* handle, usb_event_struct_t* event,void* arg );
    180          void USB_Control_Service_Handler( usb_class_fw_object_struct_t* usb_fw_ptr,
    181                                            uint8_t error,
    182                                            usb_setup_struct_t * setup_packet, 
    183                                            uint8_t * *data, 
    184                                            uint32_t *size);
    185          
    186          static uint8_t USB_Strd_Req_Get_Status(usb_class_fw_object_struct_t* usb_fw_ptr,
    187                                         usb_setup_struct_t * setup_packet,
    188                                         uint8_t * *data, 
    189                                         uint32_t *size);
    190          static uint8_t USB_Strd_Req_Feature(usb_class_fw_object_struct_t* usb_fw_ptr,
    191                                      usb_setup_struct_t * setup_packet, 
    192                                      uint8_t * *data, 
    193                                      uint32_t *size);
    194          static uint8_t USB_Strd_Req_Set_Address(usb_class_fw_object_struct_t* usb_fw_ptr,
    195                                          usb_setup_struct_t * setup_packet,
    196                                          uint8_t * *data, 
    197                                          uint32_t *size);
    198          static uint8_t USB_Strd_Req_Assign_Address(usb_class_fw_object_struct_t* usb_fw_ptr);
    199          static uint8_t USB_Strd_Req_Get_Config(usb_class_fw_object_struct_t* usb_fw_ptr,
    200                                         usb_setup_struct_t * setup_packet, 
    201                                         uint8_t * *data, 
    202                                         uint32_t *size);
    203          static uint8_t USB_Strd_Req_Set_Config(usb_class_fw_object_struct_t* usb_fw_ptr,
    204                                         usb_setup_struct_t * setup_packet, 
    205                                         uint8_t * *data, 
    206                                         uint32_t *size);
    207          static uint8_t USB_Strd_Req_Get_Interface(usb_class_fw_object_struct_t* usb_fw_ptr,
    208                                            usb_setup_struct_t * setup_packet, 
    209                                            uint8_t * *data, 
    210                                            uint32_t *size);
    211          static uint8_t USB_Strd_Req_Set_Interface(usb_class_fw_object_struct_t* usb_fw_ptr,
    212                                            usb_setup_struct_t * setup_packet, 
    213                                            uint8_t * *data, 
    214                                            uint32_t *size);
    215          static uint8_t USB_Strd_Req_Sync_Frame(usb_class_fw_object_struct_t* usb_fw_ptr,
    216                                         usb_setup_struct_t * setup_packet, 
    217                                         uint8_t * *data, 
    218                                         uint32_t *size);
    219          static uint8_t USB_Strd_Req_Get_Descriptor(usb_class_fw_object_struct_t* usb_fw_ptr,
    220                                             usb_setup_struct_t * setup_packet, 
    221                                             uint8_t * *data, 
    222                                             uint32_t *size);
    223          
    224          #ifdef DELAYED_PROCESSING
    225              void USB_Control_Service_Callback( usb_event_struct_t* event,void* arg );
    226          #endif
    227          /*****************************************************************************
    228           * Local Functions Prototypes
    229           *****************************************************************************/
    230          
    231          /*****************************************************************************
    232           * Local Variables 
    233           *****************************************************************************/
    234          
    235          /*****************************************************************************
    236           * Global Functions
    237           *****************************************************************************/
    238          static USB_FW_REQ_FUNC g_standard_request[MAX_STRD_REQ] = 
    239          { 
    240              USB_Strd_Req_Get_Status,
    241              USB_Strd_Req_Feature,
    242              NULL,
    243              USB_Strd_Req_Feature,
    244              NULL,
    245              USB_Strd_Req_Set_Address,
    246              USB_Strd_Req_Get_Descriptor,
    247              NULL,
    248              USB_Strd_Req_Get_Config,
    249              USB_Strd_Req_Set_Config,
    250              USB_Strd_Req_Get_Interface,
    251              USB_Strd_Req_Set_Interface,
    252              USB_Strd_Req_Sync_Frame
    253          };
    254          
    255          #ifdef DELAYED_PROCESSING
    256          /**************************************************************************//*!
    257           *
    258           * @name  USB_Framework_Periodic_Task
    259           *
    260           * @brief The function is called to respond to any control request
    261           *
    262           * @param None
    263           *
    264           * @return None
    265           *
    266           *****************************************************************************/
    267          static void USB_Framework_Periodic_Task
    268          (
    269              void
    270          )
    271          {
    272              /* if control request pending to be completed */
    273              if (g_control_pending==TRUE) 
    274              {   /* handle pending control request */
    275                  USB_Control_Service(&g_f_event);       
    276                  g_control_pending=FALSE;
    277              }
    278          }
    279          
    280          /**************************************************************************//*!
    281           *
    282           * @name  USB_Control_Service_Callback
    283           *
    284           * @brief The function can be used as a callback function to the service.
    285           *
    286           * @param event:              from Service callback function
    287           *
    288           * @return None       
    289           *
    290           *****************************************************************************/
    291          static void USB_Control_Service_Callback
    292          (
    293              usb_event_struct_t* event,
    294              void*               arg 
    295          ) 
    296          {
    297              UNUSED_ARGUMENT(arg)
    298              /* save the event parameters */
    299              g_f_event.buffer_ptr = event->buffer_ptr;
    300              g_f_event.handle = event->handle; 
    301              g_f_event.ep_num = event->ep_num;
    302              g_f_event.setup  = event->setup;
    303              g_f_event.len = event->len;
    304              g_f_event.errors = event->errors;
    305          
    306              /* set the pending request flag */
    307              g_control_pending=TRUE;
    308          }
    309          #endif
    310          
    311          /**************************************************************************//*!
    312           *
    313           * @name  USB_Framework_Reset
    314           *
    315           * @brief The function resets the framework
    316           *
    317           * @param handle: handle to Identify the controller
    318           *
    319           * @return status       
    320           *         USB_OK           : When Successfully
    321           *         Others           : Errors
    322           *
    323           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    324          uint8_t USB_Framework_Reset
    325          (
    326              usb_device_handle handle
    327          )
    328          { 
    329              UNUSED_ARGUMENT(handle)
    330              return USB_OK; 
   \                     USB_Framework_Reset: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    331          }
    332          
    333          /**************************************************************************//*!
    334           *
    335           * @name  USB_Control_Service
    336           *
    337           * @brief Called upon a completed endpoint 0 (USB 1.1 Chapter 9) transfer 
    338           *
    339           * @param event:        from Service callback function
    340           *
    341           * @return None       
    342           *
    343           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    344          void USB_Control_Service
    345          (
    346              void*               handle, 
    347              usb_event_struct_t* event,
    348              void*               arg 
    349          )
    350          {
   \                     USB_Control_Service: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    351              uint16_t    device_state = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    352              uint8_t     error = USBERR_INVALID_REQ_TYPE;
    353              uint8_t * data = NULL;
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x460E             MOV      R6,R1
    354              uint32_t size; 
    355              usb_class_fw_object_struct_t*   usb_fw_ptr;
    356          
    357              usb_fw_ptr = (usb_class_fw_object_struct_t*)handle;
    358              
    359              /* get the device state  */
    360              (void)usb_device_get_status(usb_fw_ptr->dev_handle, (uint8_t)USB_STATUS_DEVICE_STATE,
    361                  &device_state);
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0xAA02             ADD      R2,SP,#+8
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x.... 0x....      BL       usb_device_get_status
    362              //USB_PRINTF("USB_Control_Service ++ \n");
    363              if (event->setup == TRUE) 
   \   00000018   0x7BB0             LDRB     R0,[R6, #+14]
   \   0000001A   0x25CE             MOVS     R5,#+206
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD050             BEQ.N    ??USB_Control_Service_0
    364              {
    365                  OS_Mem_copy(event->buffer_ptr,&usb_fw_ptr->setup_packet,USB_SETUP_PKT_SIZE);        
   \   00000020   0x6871             LDR      R1,[R6, #+4]
   \   00000022   0x2208             MOVS     R2,#+8
   \   00000024   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000028   0x.... 0x....      BL       memcpy
    366                  
    367                  /* take care of endianness  of the 16 bit fields correctly */
    368                  usb_fw_ptr->setup_packet.index = USB_SHORT_LE_TO_HOST(usb_fw_ptr->setup_packet.index);
   \   0000002C   0x8A20             LDRH     R0,[R4, #+16]
    369                  usb_fw_ptr->setup_packet.value = USB_SHORT_LE_TO_HOST(usb_fw_ptr->setup_packet.value);
    370                  usb_fw_ptr->setup_packet.length = USB_SHORT_LE_TO_HOST(usb_fw_ptr->setup_packet.length);
    371              //  USB_PRINTF("00++ Enter ++ type:%d \n",usb_fw_ptr->setup_packet.request_type);
    372                  /* if the request is standard request */
    373                  if ((usb_fw_ptr->setup_packet.request_type & USB_DEV_REQ_STD_REQUEST_TYPE_TYPE_POS) == 
    374                      USB_DEV_REQ_STD_REQUEST_TYPE_TYPE_STANDARD) 
   \   0000002E   0x7B21             LDRB     R1,[R4, #+12]
   \   00000030   0x8220             STRH     R0,[R4, #+16]
   \   00000032   0x2260             MOVS     R2,#+96
   \   00000034   0x89E0             LDRH     R0,[R4, #+14]
   \   00000036   0x81E0             STRH     R0,[R4, #+14]
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0x8A60             LDRH     R0,[R4, #+18]
   \   0000003C   0x8260             STRH     R0,[R4, #+18]
   \   0000003E   0xD117             BNE.N    ??USB_Control_Service_1
    375                  {
    376              //      USB_PRINTF("11++ Enter ++ :%d \n",usb_fw_ptr->setup_packet.request);
    377                      /* if callback is not NULL */
    378                      if (g_standard_request[usb_fw_ptr->setup_packet.request] != NULL) 
   \   00000040   0x7B60             LDRB     R0,[R4, #+13]
   \   00000042   0x....             LDR.N    R1,??DataTable0
   \   00000044   0xEB01 0x0280      ADD      R2,R1,R0, LSL #+2
   \   00000048   0x6A96             LDR      R6,[R2, #+40]
   \   0000004A   0x0032             MOVS     R2,R6
   \   0000004C   0xD05A             BEQ.N    ??USB_Control_Service_2
    379                      {
    380              //          USB_PRINTF("22++ Enter ++ :%d \n",usb_fw_ptr->setup_packet.request);
    381                          /* if the request is valid in this device state */
    382                          if((device_state < USB_STATE_POWERED) && 
    383                              (g_validate_request[usb_fw_ptr->setup_packet.request][device_state] 
    384                                  == (uint8_t)1))
   \   0000004E   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \   00000052   0x2A03             CMP      R2,#+3
   \   00000054   0xDA56             BGE.N    ??USB_Control_Service_2
   \   00000056   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000005A   0x1840             ADDS     R0,R0,R1
   \   0000005C   0x5C10             LDRB     R0,[R2, R0]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD150             BNE.N    ??USB_Control_Service_2
    385                          {
    386                              /* Standard Request function pointers */
    387                              error = g_standard_request[usb_fw_ptr->setup_packet.request]
    388                                  (usb_fw_ptr,&usb_fw_ptr->setup_packet,&data,&size);
   \   00000062   0xAB01             ADD      R3,SP,#+4
   \   00000064   0xAA03             ADD      R2,SP,#+12
   \   00000066   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x47B0             BLX      R6
   \   0000006E   0xE026             B.N      ??USB_Control_Service_3
    389                          }
    390                      }
    391                  }
    392                  else /* for Class/Vendor requests */
    393                  {  
    394                      /*get the length from the setup_request*/
    395                      size = usb_fw_ptr->setup_packet.length;
   \                     ??USB_Control_Service_1: (+1)
   \   00000070   0x9001             STR      R0,[SP, #+4]
    396          
    397                      if( (size != 0) && 
    398                          ((usb_fw_ptr->setup_packet.request_type & USB_DEV_REQ_STD_REQUEST_TYPE_DIR_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_DIR_OUT)
    399                        )
   \   00000072   0xB1D8             CBZ.N    R0,??USB_Control_Service_4
   \   00000074   0x7B20             LDRB     R0,[R4, #+12]
   \   00000076   0x0600             LSLS     R0,R0,#+24
   \   00000078   0xD418             BMI.N    ??USB_Control_Service_4
    400                      {
    401                          /* we have gone for one time memory allocation of ext_req_to_host
    402                             to avoid memory fragmentation, as there was memory crunch in 
    403                             some of our Socs. */
    404                          if((size + USB_SETUP_PKT_SIZE) > MAX_EXPECTED_CONTROL_OUT_SIZE)
   \   0000007A   0x9801             LDR      R0,[SP, #+4]
   \   0000007C   0x3008             ADDS     R0,R0,#+8
   \   0000007E   0x2855             CMP      R0,#+85
   \   00000080   0xD305             BCC.N    ??USB_Control_Service_5
    405                          {
    406                              #ifdef _DEBUG
    407          //                        USB_PRINTF("MAX_EXPECTED_CONTROL_OUT_SIZE insufficient, needed %d\n", size + USB_SETUP_PKT_SIZE);
    408          //                        USB_PRINTF("Please change the macro!!!\n");
    409                              #endif  
    410                              usb_device_stall_endpoint(usb_fw_ptr->dev_handle,USB_CONTROL_ENDPOINT,USB_RECV);
   \   00000082   0x68A0             LDR      R0,[R4, #+8]
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x.... 0x....      BL       usb_device_stall_endpoint
    411                              return;
   \   0000008C   0xBD7F             POP      {R0-R6,PC}
    412                          }
    413          
    414                          /* copy setup token to ext_req_to_host */
    415                          OS_Mem_copy(&usb_fw_ptr->setup_packet, usb_fw_ptr->ext_req_to_host,
    416                              USB_SETUP_PKT_SIZE);
   \                     ??USB_Control_Service_5: (+1)
   \   0000008E   0x6960             LDR      R0,[R4, #+20]
   \   00000090   0x2208             MOVS     R2,#+8
   \   00000092   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000096   0x.... 0x....      BL       memcpy
    417                          /* expecting host to send data (OUT TRANSACTION)*/
    418                          (void)usb_device_recv_data(event->handle, 
    419                              USB_CONTROL_ENDPOINT,(usb_fw_ptr->ext_req_to_host+USB_SETUP_PKT_SIZE),
    420                                  (uint32_t)(size));
   \   0000009A   0x6960             LDR      R0,[R4, #+20]
   \   0000009C   0x9B01             LDR      R3,[SP, #+4]
   \   0000009E   0xF100 0x0208      ADD      R2,R0,#+8
   \   000000A2   0x6830             LDR      R0,[R6, #+0]
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x.... 0x....      BL       usb_device_recv_data
    421                          return;
   \   000000AA   0xBD7F             POP      {R0-R6,PC}
    422                      }
    423                      /*call class/vendor request*/
    424                      else if(usb_fw_ptr->request_notify_callback != NULL)
   \                     ??USB_Control_Service_4: (+1)
   \   000000AC   0x6A26             LDR      R6,[R4, #+32]
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0xD028             BEQ.N    ??USB_Control_Service_2
    425                      {
    426                    //    USB_PRINTF("USB_Control_Service_Handler ++ #### \n");
    427                          error = usb_fw_ptr->request_notify_callback(
    428                          &usb_fw_ptr->setup_packet,&data,&size,usb_fw_ptr->request_notify_param);
   \   000000B2   0x6A63             LDR      R3,[R4, #+36]
   \   000000B4   0xAA01             ADD      R2,SP,#+4
   \   000000B6   0xA903             ADD      R1,SP,#+12
   \   000000B8   0xF104 0x000C      ADD      R0,R4,#+12
   \   000000BC   0x47B0             BLX      R6
   \                     ??USB_Control_Service_3: (+1)
   \   000000BE   0x4605             MOV      R5,R0
   \   000000C0   0xE020             B.N      ??USB_Control_Service_2
    429                      }
    430                  } 
    431                  USB_Control_Service_Handler(usb_fw_ptr,error,&usb_fw_ptr->setup_packet,
    432                      &data,&size);
    433              } 
    434              else if(device_state == USB_STATE_PENDING_ADDRESS)
   \                     ??USB_Control_Service_0: (+1)
   \   000000C2   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xD105             BNE.N    ??USB_Control_Service_6
    435              {
    436                  /* Device state is PENDING_ADDRESS */
    437                  /* Assign the new address to the Device */
    438                  //USB_PRINTF("send ZLT done\n");
    439                  (void)USB_Strd_Req_Assign_Address(usb_fw_ptr);
   \   000000CA   0x8861             LDRH     R1,[R4, #+2]
   \   000000CC   0x68A0             LDR      R0,[R4, #+8]
   \   000000CE   0xB2C9             UXTB     R1,R1
   \   000000D0   0x.... 0x....      BL       _usb_device_set_address
    440              }
   \   000000D4   0xBD7F             POP      {R0-R6,PC}
    441              else if( ((usb_fw_ptr->setup_packet.request_type & USB_DEV_REQ_STD_REQUEST_TYPE_DIR_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_DIR_OUT) && 
    442                       (event->direction == USB_RECV) && 
    443                       (usb_fw_ptr->setup_packet.length)
    444                     )
   \                     ??USB_Control_Service_6: (+1)
   \   000000D6   0x7B20             LDRB     R0,[R4, #+12]
   \   000000D8   0x0600             LSLS     R0,R0,#+24
   \   000000DA   0xD41C             BMI.N    ??USB_Control_Service_7
   \   000000DC   0x7BF0             LDRB     R0,[R6, #+15]
   \   000000DE   0xB9D0             CBNZ.N   R0,??USB_Control_Service_7
   \   000000E0   0x8A60             LDRH     R0,[R4, #+18]
   \   000000E2   0xB1C0             CBZ.N    R0,??USB_Control_Service_7
    445              {
    446                  /* execution enters Control Service because of 
    447                     OUT transaction on USB_CONTROL_ENDPOINT*/
    448                  if(usb_fw_ptr->request_notify_callback != NULL) 
   \   000000E4   0x6A20             LDR      R0,[R4, #+32]
   \   000000E6   0xB148             CBZ.N    R0,??USB_Control_Service_8
    449                  {   
    450                      /* class or vendor request */
    451                      size = event->len+USB_SETUP_PKT_SIZE;
   \   000000E8   0x68B0             LDR      R0,[R6, #+8]
   \   000000EA   0x3008             ADDS     R0,R0,#+8
   \   000000EC   0x9001             STR      R0,[SP, #+4]
    452                      error = usb_fw_ptr->request_notify_callback(
    453                      (usb_setup_struct_t*) usb_fw_ptr->ext_req_to_host,
    454                       &data,&size,usb_fw_ptr->request_notify_param); 
   \   000000EE   0x6A63             LDR      R3,[R4, #+36]
   \   000000F0   0x6960             LDR      R0,[R4, #+20]
   \   000000F2   0x6A25             LDR      R5,[R4, #+32]
   \   000000F4   0xAA01             ADD      R2,SP,#+4
   \   000000F6   0xA903             ADD      R1,SP,#+12
   \   000000F8   0x47A8             BLX      R5
   \   000000FA   0x4605             MOV      R5,R0
    455                  }
    456          		/* if it is called by usb_dci_khci_cancel() in the reset procedure, there is no need to to prime the endpoint*/
    457                  if(event->len != 0xFFFFFFFF)
   \                     ??USB_Control_Service_8: (+1)
   \   000000FC   0x68B0             LDR      R0,[R6, #+8]
   \   000000FE   0xF110 0x0F01      CMN      R0,#+1
   \   00000102   0xD008             BEQ.N    ??USB_Control_Service_7
    458                  {
    459                  	USB_Control_Service_Handler(usb_fw_ptr,error,&usb_fw_ptr->setup_packet,
    460                      	&data,&size);
   \                     ??USB_Control_Service_2: (+1)
   \   00000104   0xA801             ADD      R0,SP,#+4
   \   00000106   0x9000             STR      R0,[SP, #+0]
   \   00000108   0xAB03             ADD      R3,SP,#+12
   \   0000010A   0xF104 0x020C      ADD      R2,R4,#+12
   \   0000010E   0xB2E9             UXTB     R1,R5
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       USB_Control_Service_Handler
    461                  }
    462              }
    463              return;
   \                     ??USB_Control_Service_7: (+1)
   \   00000116   0xBD7F             POP      {R0-R6,PC}       ;; return
    464          } 
    465          
    466          /**************************************************************************//*!
    467           *
    468           * @name  USB_Reset_Service
    469           *
    470           * @brief The function is called upon a bus reset event.
    471                        Initializes the control endpoint.
    472           *
    473           * @param event:        for Service callback function     
    474           *
    475           * @return None       
    476           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    477          void USB_Reset_Service
    478          (
    479              void*               handle, 
    480              usb_event_struct_t* event, 
    481              void*               arg
    482          )
    483          {
   \                     USB_Reset_Service: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB083             SUB      SP,SP,#+12
    484              usb_ep_struct_t ep_struct;
    485              volatile usb_class_fw_object_struct_t*   usb_fw_ptr;
    486              void* temp; 
    487          
    488              usb_fw_ptr = (usb_class_fw_object_struct_t*)handle;
    489          
    490              usb_device_reset(usb_fw_ptr->dev_handle);
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x.... 0x....      BL       usb_device_reset
    491          
    492              /* Initialize the endpoint 0 in both directions */
    493              ep_struct.direction = USB_RECV;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    494              ep_struct.ep_num = USB_CONTROL_ENDPOINT;
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    495              ep_struct.size = CONTROL_MAX_PACKET_SIZE;
    496              ep_struct.type = USB_CONTROL_PIPE;
    497          
    498              usb_device_init_endpoint(event->handle, &ep_struct, TRUE);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2040             MOVS     R0,#+64
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x.... 0x....      BL       usb_device_init_endpoint
    499          
    500              ep_struct.direction = USB_SEND;   
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    501              usb_device_init_endpoint(event->handle, &ep_struct, TRUE);
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x.... 0x....      BL       usb_device_init_endpoint
    502              temp = usb_fw_ptr->device_notify_param;
   \   0000003C   0x69E2             LDR      R2,[R4, #+28]
    503              /* let the application know that bus reset has taken place */
    504              if (usb_fw_ptr->device_notify_callback != NULL)  
   \   0000003E   0x69A0             LDR      R0,[R4, #+24]
   \   00000040   0xB118             CBZ.N    R0,??USB_Reset_Service_0
    505              {
    506                  usb_fw_ptr->device_notify_callback(USB_DEV_EVENT_BUS_RESET,NULL,temp); 
   \   00000042   0x69A3             LDR      R3,[R4, #+24]
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4798             BLX      R3
    507              }
    508          
    509              return;
   \                     ??USB_Reset_Service_0: (+1)
   \   0000004A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    510          }
    511          
    512          #if USBCFG_DEV_DETACH_ENABLE
    513          /**************************************************************************//*!
    514           *
    515           * @name  USB_Detach_Service
    516           *
    517           * @brief The function is called upon a bus reset event.
    518                        Initializes the control endpoint.
    519           *
    520           * @param event:        for Service callback function     
    521           *
    522           * @return None       
    523           *****************************************************************************/
    524          void USB_Detach_Service
    525          (
    526              void*               handle, 
    527              usb_event_struct_t* event, 
    528              void*               arg
    529          )
    530          {
    531              volatile usb_class_fw_object_struct_t*   usb_fw_ptr;
    532          
    533              usb_fw_ptr = (usb_class_fw_object_struct_t*)handle;
    534          
    535              usb_device_reset(usb_fw_ptr->dev_handle);
    536          
    537              /* let the application know that bus reset has taken place */
    538              if (usb_fw_ptr->device_notify_callback != NULL)  
    539              {
    540                  usb_fw_ptr->device_notify_callback(USB_DEV_EVENT_DETACH, NULL, usb_fw_ptr->device_notify_param); 
    541              }
    542          
    543              return;
    544          }
    545          #endif
    546          
    547          #if USBCFG_DEV_KHCI_ADVANCED_ERROR_HANDLING
    548          /**************************************************************************//*!
    549           *
    550           * @name  USB_Error_Service
    551           *
    552           * @brief The function is called when an error has been detected
    553           *
    554           * @param event:        for Service callback function     
    555           *
    556           * @return None       
    557           *****************************************************************************/
    558          void USB_Error_Service
    559          (
    560              void*               handle, 
    561              usb_event_struct_t* event, 
    562              void*               arg
    563          )
    564          {
    565              volatile usb_class_fw_object_struct_t*   usb_fw_ptr;
    566          
    567              usb_fw_ptr = (usb_class_fw_object_struct_t*)handle;
    568          
    569              /* notify the application of the error */
    570              if (usb_fw_ptr->device_notify_callback != NULL) 
    571              {
    572                  usb_fw_ptr->device_notify_callback(USB_DEV_EVENT_ERROR,event->buffer_ptr,usb_fw_ptr->device_notify_param);
    573              }
    574              return; 
    575          }
    576          #endif
    577          
    578          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME
    579          /**************************************************************************//*!
    580           *
    581           * @name  USB_Suspend_Service
    582           *
    583           * @brief The function is called when host suspends the USB port
    584           *
    585           * @param event:        for Service callback function     
    586           *
    587           * @return None       
    588           *****************************************************************************/
    589          void USB_Suspend_Service
    590          (
    591              void*               handle,
    592              usb_event_struct_t* event,
    593              void*               arg 
    594          )
    595          {
    596              UNUSED_ARGUMENT(handle)
    597              UNUSED_ARGUMENT(event)
    598              UNUSED_ARGUMENT(arg)
    599              return;
    600          }
    601          
    602          /**************************************************************************//*!
    603           *
    604           * @name  USB_Resume_Service
    605           *
    606           * @brief The function is called when host resumes the USB port
    607           *
    608            * @param event:        for Service callback function     
    609           *
    610           * @return None       
    611           *****************************************************************************/
    612          void USB_Resume_Service
    613          (
    614              void*               handle,
    615              usb_event_struct_t* event,
    616              void*               arg 
    617          )
    618          {
    619              UNUSED_ARGUMENT(handle)
    620              UNUSED_ARGUMENT(event)
    621              UNUSED_ARGUMENT(arg)
    622              return;
    623          }
    624          #endif
    625          
    626          /**************************************************************************//*!
    627           *
    628           * @name  USB_Control_Service_Handler
    629           *
    630           * @brief The function is used to send a response to the Host based. 
    631           *
    632           * @param status:           status of Device e.g USB_OK,USBERR_INVALID_REQ_TYPE
    633           * @param setup_packet:     setup packet received
    634           * @param data:             data to be send back
    635           * @param size:             size to be returned 
    636           *
    637           * @return None       
    638           *
    639           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    640          void USB_Control_Service_Handler
    641          (
    642              usb_class_fw_object_struct_t* usb_fw_ptr,
    643              uint8_t error,
    644              usb_setup_struct_t * setup_packet, 
    645              uint8_t * *data, 
    646              uint32_t *size
    647          ) 
    648          {  
   \                     USB_Control_Service_Handler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    649              if (error == USBERR_INVALID_REQ_TYPE)
   \   00000004   0x29CE             CMP      R1,#+206
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0xD106             BNE.N    ??USB_Control_Service_Handler_0
    650              {   
    651                  uint8_t direction = USB_SEND;
    652                  uint8_t ep_num = USB_CONTROL_ENDPOINT;
    653          
    654                  usb_device_stall_endpoint(usb_fw_ptr->dev_handle,ep_num,direction);
   \   0000000C   0x68A0             LDR      R0,[R4, #+8]
   \   0000000E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x.... 0x....      B.W      usb_device_stall_endpoint
    655              }
    656              else /* Need to send Data to the USB Host */
    657              {
    658                  /* send the data prepared by the handlers.*/
    659                  if (*size > setup_packet->length) 
   \                     ??USB_Control_Service_Handler_0: (+1)
   \   0000001A   0x9904             LDR      R1,[SP, #+16]
   \   0000001C   0x88EA             LDRH     R2,[R5, #+6]
   \   0000001E   0x680B             LDR      R3,[R1, #+0]
   \   00000020   0x429A             CMP      R2,R3
   \   00000022   0xBF38             IT       CC 
   \   00000024   0x600A             STRCC    R2,[R1, #+0]
    660                  {
    661                      *size = setup_packet->length;
    662                  }
    663          
    664                  /* send the data to the host */
    665                  (void)usb_device_send_data(usb_fw_ptr->dev_handle,USB_CONTROL_ENDPOINT, *data, *size);
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0x680B             LDR      R3,[R1, #+0]
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      BL       usb_device_send_data
    666                  //USB_PRINTF("send %d to host\n", *size);
    667          
    668                  if ((setup_packet->request_type & USB_DEV_REQ_STD_REQUEST_TYPE_DIR_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_DIR_IN)
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
   \   00000034   0x0600             LSLS     R0,R0,#+24
   \   00000036   0xD508             BPL.N    ??USB_Control_Service_Handler_1
    669                  {
    670                      /* Request was to Get Data from device */
    671                      /* setup recv to get status from host */
    672                      (void)usb_device_recv_data(usb_fw_ptr->dev_handle,
    673                          USB_CONTROL_ENDPOINT,NULL,0);
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0xB001             ADD      SP,SP,#+4
   \   0000003C   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x.... 0x....      B.W      usb_device_recv_data
    674                      //USB_PRINTF("ready to receive ZLT on EP0\n");
    675                  }
    676              }
    677              return;
   \                     ??USB_Control_Service_Handler_1: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    678          }
    679          /*************************************************************************//*!
    680           *
    681           * @name  USB_Strd_Req_Get_Status
    682           *
    683           * @brief  This function is called in response to Get Status request
    684           *
    685           * @param setup_packet:     setup packet received
    686           * @param data:             data to be send back
    687           * @param size:             size to be returned 
    688           *
    689           * @return status:       
    690           *                        USB_OK : When Successfully
    691           *                        Others : When Error
    692           *
    693           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    694          static uint8_t USB_Strd_Req_Get_Status
    695          (
    696              usb_class_fw_object_struct_t*   usb_fw_ptr,
    697              usb_setup_struct_t *            setup_packet, 
    698              uint8_t *                       *data, 
    699              uint32_t                        *size
    700          )
    701          {
   \                     USB_Strd_Req_Get_Status: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461E             MOV      R6,R3
    702              uint8_t endpoint;
    703              uint8_t error = USBERR_ERROR;
    704              
    705              if ((setup_packet->request_type & USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_DEVICE)
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x231F             MOVS     R3,#+31
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xD109             BNE.N    ??USB_Strd_Req_Get_Status_0
    706              {   /* request for Device */
    707          #ifdef USBCFG_OTG
    708                  if(setup_packet->index == USB_WINDEX_OTG_STATUS_SEL)
    709                  {
    710                      uint8_t hnp_support; 
    711                      (void)usb_device_otg_get_hnp_support(usb_fw_ptr->dev_handle, &hnp_support);
    712                      if(hnp_support)
    713                      {
    714                          error = usb_device_get_status(usb_fw_ptr->dev_handle,
    715                                                         (uint8_t)USB_STATUS_OTG, &usb_fw_ptr->std_framework_data);
    716                          usb_fw_ptr->std_framework_data &= GET_STATUS_OTG_MASK; 
    717                          usb_fw_ptr->std_framework_data = USB_SHORT_LE_TO_HOST(usb_fw_ptr->std_framework_data);
    718                          *size=OTG_STATUS_SIZE;
    719                      }
    720                      else
    721                      {
    722                          error = USBERR_INVALID_REQ_TYPE;
    723                      }
    724                }
    725                else
    726          #endif    
    727                {
    728                    error = usb_device_get_status(usb_fw_ptr->dev_handle,
    729                        (uint8_t)USB_STATUS_DEVICE, &usb_fw_ptr->std_framework_data);
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x4622             MOV      R2,R4
   \   00000016   0x2106             MOVS     R1,#+6
   \   00000018   0x.... 0x....      BL       usb_device_get_status
    730                    usb_fw_ptr->std_framework_data &= GET_STATUS_DEVICE_MASK; 
    731                    usb_fw_ptr->std_framework_data = USB_SHORT_LE_TO_HOST(usb_fw_ptr->std_framework_data);                                      
   \   0000001C   0x7821             LDRB     R1,[R4, #+0]
   \   0000001E   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000022   0x8021             STRH     R1,[R4, #+0]
    732                    *size=DEVICE_STATUS_SIZE;     
   \   00000024   0xE013             B.N      ??USB_Strd_Req_Get_Status_1
    733                }
    734              }
    735              else if ((setup_packet->request_type & USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \                     ??USB_Strd_Req_Get_Status_0: (+1)
   \   00000026   0xF002 0x031F      AND      R3,R2,#0x1F
   \   0000002A   0x2B01             CMP      R3,#+1
   \   0000002C   0xD103             BNE.N    ??USB_Strd_Req_Get_Status_2
    736              {    /* request for Interface */
    737                  usb_fw_ptr->std_framework_data = 0;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x8021             STRH     R1,[R4, #+0]
    738                  *size=INTERFACE_STATUS_SIZE;
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xE00C             B.N      ??USB_Strd_Req_Get_Status_3
    739              }
    740              else if ((setup_packet->request_type & USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_ENDPOINT)
   \                     ??USB_Strd_Req_Get_Status_2: (+1)
   \   00000036   0xF002 0x021F      AND      R2,R2,#0x1F
   \   0000003A   0x2A02             CMP      R2,#+2
   \   0000003C   0xD109             BNE.N    ??USB_Strd_Req_Get_Status_4
    741              {   /* request for Endpoint */
    742                  endpoint  =(uint8_t)(((uint8_t)setup_packet->index)|USB_STATUS_ENDPOINT);
    743                  error =  usb_device_get_status(usb_fw_ptr->dev_handle,
    744                      (uint8_t)endpoint, 
    745                      &usb_fw_ptr->std_framework_data);
   \   0000003E   0x8888             LDRH     R0,[R1, #+4]
   \   00000040   0xF040 0x0110      ORR      R1,R0,#0x10
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x.... 0x....      BL       usb_device_get_status
    746                  usb_fw_ptr->std_framework_data = USB_SHORT_LE_TO_HOST(usb_fw_ptr->std_framework_data);                                      
    747                  *size=ENDP_STATUS_SIZE;
   \                     ??USB_Strd_Req_Get_Status_1: (+1)
   \   0000004E   0x2102             MOVS     R1,#+2
   \                     ??USB_Strd_Req_Get_Status_3: (+1)
   \   00000050   0x6031             STR      R1,[R6, #+0]
    748              }
    749             
    750              *data = (uint8_t *)&usb_fw_ptr->std_framework_data;
   \                     ??USB_Strd_Req_Get_Status_4: (+1)
   \   00000052   0x602C             STR      R4,[R5, #+0]
    751              return error;
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    752          }
    753          
    754          /**************************************************************************//*!
    755           *
    756           * @name  USB_Strd_Req_Feature
    757           *
    758           * @brief  This function is called in response to Clear or Set Feature request
    759           *
    760           * @param setup_packet:     setup packet received
    761           * @param data:             data to be send back
    762           * @param size:             size to be returned 
    763           *
    764           * @return status:       
    765           *                        USB_OK : When Successfully
    766           *                        Others : When Error
    767           *
    768           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    769          static uint8_t USB_Strd_Req_Feature
    770          (
    771              usb_class_fw_object_struct_t*   usb_fw_ptr,
    772              usb_setup_struct_t *            setup_packet, 
    773              uint8_t *                       *data, 
    774              uint32_t                        *size
    775          )
    776          {
   \                     USB_Strd_Req_Feature: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    777              //uint16_t device_status;
    778              uint16_t set_request;
    779              uint8_t  error=USBERR_INVALID_REQ_TYPE;
    780              uint8_t  epinfo;
    781              uint8_t  event;
    782              uint8_t feature;
    783              
    784          #if USBCFG_DEV_EHCI_TEST_MODE
    785              uint16_t ptc = 0;
    786              volatile uint32_t loop = 10*1000*1000;
    787          #endif
    788          
    789              UNUSED_ARGUMENT(data)
    790              *size=0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6018             STR      R0,[R3, #+0]
   \   0000000A   0x25CE             MOVS     R5,#+206
    791              /* find whether its a clear feature request or a set feature request */
    792              set_request = (uint16_t)((setup_packet->request & USB_SET_REQUEST_MASK)>>1);
    793          
    794              if ((setup_packet->request_type & USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_DEVICE)
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x7848             LDRB     R0,[R1, #+1]
   \   00000010   0x231F             MOVS     R3,#+31
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000018   0xD112             BNE.N    ??USB_Strd_Req_Feature_0
    795              {
    796          #ifdef USBCFG_OTG
    797                  if (set_request)
    798                  {
    799                      if ((setup_packet->value == USB_DEV_REQ_STD_FEATURE_B_HNP_ENABLE) || (setup_packet->value == USB_DEV_REQ_STD_FEATURE_A_HNP_SUPPORT))
    800                      {
    801                          uint8_t hnp_support; 
    802                          (void)usb_device_otg_get_hnp_support(usb_fw_ptr->dev_handle, &hnp_support);
    803                          if (hnp_support)
    804                          {
    805                              error = USB_OK;
    806                              if (setup_packet->value == USB_DEV_REQ_STD_FEATURE_B_HNP_ENABLE)
    807                              {
    808                                  (void)usb_device_otg_set_hnp_enable(usb_fw_ptr->dev_handle);
    809                              }
    810                          }
    811                          else
    812                          {
    813                              error = USBERR_INVALID_REQ_TYPE;
    814                          }
    815                      }
    816                  }
    817          #endif  
    818                  /* request for Device */
    819                  feature = setup_packet->value & USB_DEV_REQ_STD_FEATURE_SELECTOR_MASK;
   \   0000001A   0x7889             LDRB     R1,[R1, #+2]
   \   0000001C   0xF011 0x0103      ANDS     R1,R1,#0x3
    820                  if (feature)
   \   00000020   0xD038             BEQ.N    ??USB_Strd_Req_Feature_1
    821                  {    
    822                      if (feature == USB_DEV_REQ_STD_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP)
   \   00000022   0x2901             CMP      R1,#+1
   \   00000024   0xD136             BNE.N    ??USB_Strd_Req_Feature_1
    823                      {
    824                          if (set_request == (uint16_t)TRUE)  
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xBF14             ITE      NE 
   \   0000002A   0x2611             MOVNE    R6,#+17
   \   0000002C   0x2612             MOVEQ    R6,#+18
    825                          {  
    826                              event = USB_DEV_EVENT_TYPE_SET_REMOTE_WAKEUP;
    827                          }
    828                          else   
    829                          {   /* remove the request to be cleared from device_status */
    830                              event = USB_DEV_EVENT_TYPE_CLR_REMOTE_WAKEUP;
    831                          }
    832                          error = USB_OK;
    833                          if (usb_fw_ptr->device_notify_callback)
   \   0000002E   0x69A3             LDR      R3,[R4, #+24]
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x0018             MOVS     R0,R3
   \   00000034   0xD02E             BEQ.N    ??USB_Strd_Req_Feature_1
    834                          {
    835                              usb_fw_ptr->device_notify_callback(event, NULL, usb_fw_ptr->request_notify_param);
   \   00000036   0x6A62             LDR      R2,[R4, #+36]
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x4798             BLX      R3
   \   0000003E   0xE029             B.N      ??USB_Strd_Req_Feature_1
    836                          }
    837                      }
    838                      else if (feature == USB_DEV_REQ_STD_FEATURE_SELECTOR_TEST_MODE)
    839                      {
    840          #if USBCFG_DEV_EHCI_TEST_MODE
    841                          (void)usb_device_send_data(usb_fw_ptr->dev_handle,USB_CONTROL_ENDPOINT, NULL, 0);
    842                          /* need add some delay to wait for zero length packet is sent complete */
    843                          while(loop --);
    844                          ptc = setup_packet->index >> 8;
    845                          usb_device_set_test_mode(usb_fw_ptr->dev_handle,ptc);
    846                          error = USB_OK;
    847          #endif
    848                      }           
    849                  }       
    850                  else
    851                  {
    852                      /* TODO */
    853                      /* if the feature is 0, a request error need to be sent out*/
    854                      
    855                  }
    856              }
    857              else if ((setup_packet->request_type & USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_POS) == USB_DEV_REQ_STD_REQUEST_TYPE_RECIPIENT_ENDPOINT)
   \                     ??USB_Strd_Req_Feature_0: (+1)
   \   00000040   0xF002 0x021F      AND      R2,R2,#0x1F
   \   00000044   0x2A02             CMP      R2,#+2
   \   00000046   0xBF02             ITTT     EQ 
   \   00000048   0x788A             LDRBEQ   R2,[R1, #+2]
   \   0000004A   0x2303             MOVEQ    R3,#+3
   \   0000004C   0x421A             TSTEQ    R2,R3
    858              {   
    859                  /* request for Endpoint */
    860                  feature = setup_packet->value & USB_DEV_REQ_STD_FEATURE_SELECTOR_MASK;
    861                  if (feature == 0)
   \   0000004E   0xD121             BNE.N    ??USB_Strd_Req_Feature_1
    862                  {
    863                      epinfo = (uint8_t)(setup_packet->index & 0x00FF);
   \   00000050   0x8889             LDRH     R1,[R1, #+4]
   \   00000052   0xF88D 0x1000      STRB     R1,[SP, #+0]
    864                      if(set_request)
   \   00000056   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000005A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005E   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000062   0x09D2             LSRS     R2,R2,#+7
   \   00000064   0xB120             CBZ.N    R0,??USB_Strd_Req_Feature_2
    865                      {
    866                          event = USB_DEV_EVENT_TYPE_SET_EP_HALT;
    867                          error = usb_device_stall_endpoint(usb_fw_ptr->dev_handle,epinfo & 0x0F, (epinfo & 0x80) >> 7);
   \   00000066   0x68A0             LDR      R0,[R4, #+8]
   \   00000068   0x.... 0x....      BL       usb_device_stall_endpoint
   \   0000006C   0x2613             MOVS     R6,#+19
   \   0000006E   0xE008             B.N      ??USB_Strd_Req_Feature_3
    868                      }
    869                      else
    870                      {
    871                          event = USB_DEV_EVENT_TYPE_CLR_EP_HALT;
    872                          if ((epinfo & 0x0f) == 0)
   \                     ??USB_Strd_Req_Feature_2: (+1)
   \   00000070   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000074   0x2614             MOVS     R6,#+20
   \   00000076   0x230F             MOVS     R3,#+15
   \   00000078   0x4218             TST      R0,R3
   \   0000007A   0xD103             BNE.N    ??USB_Strd_Req_Feature_4
    873                          {
    874                              error = usb_device_unstall_endpoint(usb_fw_ptr->dev_handle,epinfo & 0x0F, (epinfo & 0x80) >> 7);
   \   0000007C   0x68A0             LDR      R0,[R4, #+8]
   \   0000007E   0x.... 0x....      BL       usb_device_unstall_endpoint
   \                     ??USB_Strd_Req_Feature_3: (+1)
   \   00000082   0x4605             MOV      R5,R0
    875                          }
    876                      }
    877                      if(usb_fw_ptr->device_notify_callback)
   \                     ??USB_Strd_Req_Feature_4: (+1)
   \   00000084   0x69A3             LDR      R3,[R4, #+24]
   \   00000086   0x0018             MOVS     R0,R3
   \   00000088   0xD004             BEQ.N    ??USB_Strd_Req_Feature_1
    878                      {
    879                          usb_fw_ptr->device_notify_callback(event, (void*)&epinfo, usb_fw_ptr->request_notify_param);
   \   0000008A   0x6A62             LDR      R2,[R4, #+36]
   \   0000008C   0x4669             MOV      R1,SP
   \   0000008E   0x4630             MOV      R0,R6
   \   00000090   0x4798             BLX      R3
    880                          error = USB_OK;
   \   00000092   0x2500             MOVS     R5,#+0
    881                      }
    882                  }
    883                  else
    884                  {
    885                      /* TODO */
    886                      /* if feature is not 0, request error need to be sent out */
    887                  }
    888                  
    889              }
    890              return error;
   \                     ??USB_Strd_Req_Feature_1: (+1)
   \   00000094   0xB2E8             UXTB     R0,R5
   \   00000096   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    891          }
    892          
    893          /**************************************************************************//*!
    894           *
    895           * @name  USB_Strd_Req_Set_Address
    896           *
    897           * @brief  This function is called in response to Set Address request
    898           *
    899           * @param setup_packet:     setup packet received
    900           * @param data:             data to be send back
    901           * @param size:             size to be returned 
    902           *
    903           * @return status:       
    904           *                        USB_OK : When Successfully
    905           *                        Others : When Error
    906           *
    907           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    908          static uint8_t USB_Strd_Req_Set_Address
    909          (
    910              usb_class_fw_object_struct_t*   usb_fw_ptr,
    911              usb_setup_struct_t *            setup_packet, 
    912              uint8_t *                       *data, 
    913              uint32_t                        *size
    914          )
    915          {  
   \                     USB_Strd_Req_Set_Address: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    916              UNUSED_ARGUMENT(data)
    917              *size=0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6018             STR      R0,[R3, #+0]
   \   00000008   0x460D             MOV      R5,R1
    918              /* update device state */
    919              (void)usb_device_set_status(usb_fw_ptr->dev_handle,
    920                  (uint8_t)USB_STATUS_DEVICE_STATE,
    921                  (uint16_t)USB_STATE_PENDING_ADDRESS);
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x.... 0x....      BL       usb_device_set_status
    922              /*store the address from setup_packet into assigned_address*/
    923              usb_fw_ptr->assigned_address = setup_packet->value;
   \   00000014   0x8868             LDRH     R0,[R5, #+2]
   \   00000016   0x8060             STRH     R0,[R4, #+2]
    924          
    925              return USB_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    926          }
    927          
    928          /**************************************************************************//*!
    929           *
    930           * @name  USB_Strd_Req_Assign_Address
    931           *
    932           * @brief  This function assigns the address to the Device
    933           *
    934           * @param handle      
    935           *
    936           * @return status       
    937           *                       USB_OK: Always
    938           *
    939           *****************************************************************************/
    940          static uint8_t USB_Strd_Req_Assign_Address
    941          (
    942              usb_class_fw_object_struct_t* usb_fw_ptr
    943          )
    944          {
    945              /* Set Device Address */
    946              (void)_usb_device_set_address(usb_fw_ptr->dev_handle,
    947                  (uint8_t)(usb_fw_ptr->assigned_address&0x00FF)); 
    948              return USB_OK;
    949          }
    950          
    951          /**************************************************************************//*!
    952           *
    953           * @name  USB_Strd_Req_Get_Config
    954           *
    955           * @brief  This function is called in response to Get Config request
    956           *
    957           * @param setup_packet:     setup packet received
    958           * @param data:             data to be send back
    959           * @param size:             size to be returned 
    960           *
    961           * @return status:       
    962           *                        USB_OK : Always
    963           *
    964           *****************************************************************************/ 

   \                                 In section .text, align 2, keep-with-next
    965          static uint8_t USB_Strd_Req_Get_Config
    966          (   
    967              usb_class_fw_object_struct_t* usb_fw_ptr,
    968              usb_setup_struct_t * setup_packet, 
    969              uint8_t * *data, 
    970              uint32_t *size
    971          )
    972          {
    973              UNUSED_ARGUMENT(setup_packet)
    974          
    975              *size = CONFIG_SIZE;
   \                     USB_Strd_Req_Get_Config: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x6019             STR      R1,[R3, #+0]
    976              usb_fw_ptr->cur_config = USB_SHORT_LE_TO_HOST(usb_fw_ptr->cur_config);
    977              *data = (uint8_t *)(&usb_fw_ptr->cur_config);      
   \   00000004   0x3030             ADDS     R0,R0,#+48
   \   00000006   0x6010             STR      R0,[R2, #+0]
    978          
    979              return USB_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    980          }
    981          
    982          /**************************************************************************//*!
    983           *
    984           * @name  USB_Strd_Req_Set_Config
    985           *
    986           * @brief  This function is called in response to Set Config request
    987           *
    988           * @param setup_packet:     setup packet received
    989           * @param data:             data to be send back
    990           * @param size:             size to be returned 
    991           *
    992           * @return status:       
    993           *                        USB_OK : When Successfully
    994           *                        Others : When Error
    995           *
    996           *****************************************************************************/ 

   \                                 In section .text, align 2, keep-with-next
    997          static uint8_t USB_Strd_Req_Set_Config
    998          (   usb_class_fw_object_struct_t* usb_fw_ptr,
    999              usb_setup_struct_t * setup_packet, 
   1000              uint8_t * *data, 
   1001              uint32_t *size
   1002          )
   1003          {
   \                     USB_Strd_Req_Set_Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1004              uint8_t error = USBERR_INVALID_REQ_TYPE;
   1005              uint16_t config_val;
   1006          
   1007              uint16_t device_state = USB_STATE_CONFIG;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4604             MOV      R4,R0
   1008              UNUSED_ARGUMENT(data)     
   1009              *size=0;
   \   00000006   0x601A             STR      R2,[R3, #+0]
   1010              error = USB_STATUS_ERROR;
   1011              config_val = setup_packet->value;
   \   00000008   0x8848             LDRH     R0,[R1, #+2]
   \   0000000A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1012              
   1013              if (!config_val) /* if config_val is 0 */ 
   \   0000000E   0xB900             CBNZ.N   R0,??USB_Strd_Req_Set_Config_0
   1014              {
   1015                  device_state = USB_STATE_ADDRESS ;
   \   00000010   0x2201             MOVS     R2,#+1
   1016              }
   1017              
   1018              error = usb_device_set_status(usb_fw_ptr->dev_handle, 
   1019                  (uint8_t)USB_STATUS_DEVICE_STATE, 
   1020                  (uint16_t)device_state);
   \                     ??USB_Strd_Req_Set_Config_0: (+1)
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x.... 0x....      BL       usb_device_set_status
   \   0000001A   0x4605             MOV      R5,R0
   1021          
   1022              usb_fw_ptr->cur_config = config_val;
   \   0000001C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1023              /* callback to the app. to let the application know about the new Config */
   1024              if (usb_fw_ptr->device_notify_callback != NULL)  
   \   00000020   0x69A3             LDR      R3,[R4, #+24]
   \   00000022   0x8620             STRH     R0,[R4, #+48]
   \   00000024   0x0018             MOVS     R0,R3
   \   00000026   0xD00B             BEQ.N    ??USB_Strd_Req_Set_Config_1
   1025              {
   1026                  usb_fw_ptr->device_notify_callback(USB_DEV_EVENT_CONFIG_CHANGED, 
   1027                                                    (void *)&config_val,usb_fw_ptr->device_notify_param);
   \   00000028   0x69E2             LDR      R2,[R4, #+28]
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x4798             BLX      R3
   1028                  if(config_val)
   \   00000030   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000034   0xB120             CBZ.N    R0,??USB_Strd_Req_Set_Config_1
   1029                  {
   1030                      usb_fw_ptr->device_notify_callback(USB_DEV_EVENT_ENUM_COMPLETE,NULL,
   1031                                                        usb_fw_ptr->device_notify_param);     
   \   00000036   0x69E2             LDR      R2,[R4, #+28]
   \   00000038   0x69A3             LDR      R3,[R4, #+24]
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x4798             BLX      R3
   1032                  }
   1033              }
   1034           
   1035              return error;
   \                     ??USB_Strd_Req_Set_Config_1: (+1)
   \   00000040   0xB2E8             UXTB     R0,R5
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1036           }
   1037          
   1038          /**************************************************************************//*!
   1039           *
   1040           * @name  USB_Strd_Req_Get_Interface
   1041           *
   1042           * @brief  This function is called in response to Get Interface request
   1043           *
   1044           * @param setup_packet:     setup packet received
   1045           * @param data:             data to be send back
   1046           * @param size:             size to be returned 
   1047           *
   1048           * @return status:       
   1049           *                        USB_OK : When Successfully
   1050           *                        Others : When Error
   1051           *
   1052           *****************************************************************************/  

   \                                 In section .text, align 2, keep-with-next
   1053          static uint8_t USB_Strd_Req_Get_Interface
   1054          (
   1055              usb_class_fw_object_struct_t* usb_fw_ptr,
   1056              usb_setup_struct_t * setup_packet, 
   1057              uint8_t * *data, 
   1058              uint32_t *size
   1059          )
   1060          {
   \                     USB_Strd_Req_Get_Interface: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1061              uint8_t error = USBERR_NULL_CALLBACK;
   1062              
   1063              *size = INTERFACE_STATUS_SIZE;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x6018             STR      R0,[R3, #+0]
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xD101             BNE.N    ??USB_Strd_Req_Get_Interface_0
   1064          
   1065              if(!usb_fw_ptr->desc_notify_callback->get_desc_interface)
   1066                  return error;
   \   00000012   0x20CA             MOVS     R0,#+202
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}
   1067              
   1068              error = usb_fw_ptr->desc_notify_callback->get_desc_interface((uint32_t)(usb_fw_ptr->desc_notify_param), 
   1069                  (uint8_t)setup_packet->index, (uint8_t *)&usb_fw_ptr->std_framework_data);
   \                     ??USB_Strd_Req_Get_Interface_0: (+1)
   \   00000016   0x8889             LDRH     R1,[R1, #+4]
   \   00000018   0x6AE0             LDR      R0,[R4, #+44]
   \   0000001A   0x4622             MOV      R2,R4
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x4798             BLX      R3
   1070              usb_fw_ptr->std_framework_data = USB_SHORT_LE_TO_HOST(usb_fw_ptr->std_framework_data);
   1071              *data = (uint8_t *)&usb_fw_ptr->std_framework_data;
   \   00000020   0x602C             STR      R4,[R5, #+0]
   1072          
   1073              return error;
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1074          }
   1075          
   1076          /**************************************************************************//*!
   1077           *
   1078           * @name  USB_Strd_Req_Set_Interface
   1079           *
   1080           * @brief  This function is called in response to Set Interface request
   1081           *
   1082           * @param setup_packet:     setup packet received
   1083           * @param data:             data to be send back
   1084           * @param size:             size to be returned 
   1085           *
   1086           * @return status:       
   1087           *                        USB_OK : Always       
   1088           *
   1089           *****************************************************************************/ 

   \                                 In section .text, align 2, keep-with-next
   1090          static uint8_t USB_Strd_Req_Set_Interface
   1091          (
   1092              usb_class_fw_object_struct_t* usb_fw_ptr,
   1093              usb_setup_struct_t * setup_packet, 
   1094              uint8_t * *data, 
   1095              uint32_t *size
   1096          )
   1097          {
   \                     USB_Strd_Req_Set_Interface: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1098              uint8_t error = USBERR_NULL_CALLBACK;
   1099              UNUSED_ARGUMENT(data)
   1100              *size=0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x6018             STR      R0,[R3, #+0]
   1101          
   1102              /* Request type not for interface */
   1103              if ((setup_packet->request_type & 0x03) != 0x01) 
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD001             BEQ.N    ??USB_Strd_Req_Set_Interface_0
   1104              {
   1105                  return USB_STATUS_ERROR;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
   1106              }
   \                     ??USB_Strd_Req_Set_Interface_0: (+1)
   \   00000018   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001A   0x6883             LDR      R3,[R0, #+8]
   \   0000001C   0x0018             MOVS     R0,R3
   \   0000001E   0xD101             BNE.N    ??USB_Strd_Req_Set_Interface_1
   1107          
   1108              if(!usb_fw_ptr->desc_notify_callback->set_desc_interface)
   1109              {
   1110                  return error;
   \   00000020   0x20CA             MOVS     R0,#+202
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
   1111              }
   1112          
   1113              /* Get Interface and alternate interface from setup_packet */
   1114              error = usb_fw_ptr->desc_notify_callback->set_desc_interface((uint32_t)(usb_fw_ptr->desc_notify_param), 
   1115                  (uint8_t)setup_packet->index, (uint8_t)setup_packet->value); 
   \                     ??USB_Strd_Req_Set_Interface_1: (+1)
   \   00000024   0x886A             LDRH     R2,[R5, #+2]
   \   00000026   0x88A9             LDRH     R1,[R5, #+4]
   \   00000028   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0xB2C9             UXTB     R1,R1
   \   0000002E   0x4798             BLX      R3
   1116          
   1117              if (usb_fw_ptr->device_notify_callback != NULL)  
   \   00000030   0x69A3             LDR      R3,[R4, #+24]
   \   00000032   0x0018             MOVS     R0,R3
   \   00000034   0xD003             BEQ.N    ??USB_Strd_Req_Set_Interface_2
   1118              {
   1119                 usb_fw_ptr->device_notify_callback(USB_DEV_EVENT_INTERFACE_CHANGED, 
   1120                  (void *)&setup_packet->value, usb_fw_ptr->device_notify_param);   
   \   00000036   0x69E2             LDR      R2,[R4, #+28]
   \   00000038   0x1CA9             ADDS     R1,R5,#+2
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x4798             BLX      R3
   1121              }
   1122          
   1123              return USB_OK;
   \                     ??USB_Strd_Req_Set_Interface_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1124          }
   1125          
   1126          /**************************************************************************//*!
   1127           *
   1128           * @name  USB_Strd_Req_Sync_Frame
   1129           *
   1130           * @brief  This function is called in response to Sync Frame request
   1131           *
   1132           * @param setup_packet:     setup packet received
   1133           * @param data:             data to be send back
   1134           * @param size:             size to be returned 
   1135           *
   1136           * @return status:       
   1137           *                        USB_OK : When Successfully
   1138           *                        Others : When Error
   1139           *
   1140           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1141          static uint8_t USB_Strd_Req_Sync_Frame
   1142          (
   1143              usb_class_fw_object_struct_t* usb_fw_ptr,
   1144              usb_setup_struct_t * setup_packet, 
   1145              uint8_t * *data, 
   1146              uint32_t *size
   1147          )
   1148          {
   \                     USB_Strd_Req_Sync_Frame: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1149              uint8_t error;
   1150              UNUSED_ARGUMENT(setup_packet)
   1151          
   1152              *size=FRAME_SIZE;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x6018             STR      R0,[R3, #+0]
   \   00000008   0x4615             MOV      R5,R2
   1153              /* Get the frame number */
   1154              error = usb_device_get_status(usb_fw_ptr->dev_handle,
   1155                  (uint8_t)USB_STATUS_SOF_COUNT, 
   1156                  &usb_fw_ptr->std_framework_data);
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x4622             MOV      R2,R4
   \   0000000E   0x2105             MOVS     R1,#+5
   \   00000010   0x.... 0x....      BL       usb_device_get_status
   1157              usb_fw_ptr->std_framework_data = USB_SHORT_LE_TO_HOST(usb_fw_ptr->std_framework_data);
   1158              *data= (uint8_t *)&usb_fw_ptr->std_framework_data;      
   \   00000014   0x602C             STR      R4,[R5, #+0]
   1159          
   1160              return error;
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1161          }
   1162          
   1163          /**************************************************************************//*!
   1164           *
   1165           * @name  USB_Std_Req_Get_Descriptor
   1166           *
   1167           * @brief  This function is called in response to Get Descriptor request
   1168           *
   1169           * @param setup_packet:     setup packet received
   1170           * @param data:             data to be send back
   1171           * @param size:             size to be returned 
   1172           *
   1173           * @return status:       
   1174           *                        USB_OK : When Successfully
   1175           *                        Others : When Error
   1176           *
   1177           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1178          static uint8_t USB_Strd_Req_Get_Descriptor
   1179          (
   1180              usb_class_fw_object_struct_t* usb_fw_ptr,
   1181              usb_setup_struct_t * setup_packet, 
   1182              uint8_t * *data, 
   1183              uint32_t *size
   1184          )
   1185          {
   \                     USB_Strd_Req_Get_Descriptor: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1186              /*g_setup_packet.hValue*/
   1187              uint8_t type = (setup_packet->value >> 8) & 0xFF ;
   1188              uint16_t index = (uint8_t)USB_UNINITIALIZED_VAL_32;
   1189              uint8_t str_num = (uint8_t)USB_UNINITIALIZED_VAL_32;
   1190              uint8_t error = USBERR_NULL_CALLBACK;
   1191             
   1192              /* for string descriptor set the language and string number */ 
   1193              index = setup_packet->index;
   1194              /*g_setup_packet.lValue*/
   1195              str_num = setup_packet->value & 0xFF;
   1196          
   1197              if(!usb_fw_ptr->desc_notify_callback->get_desc)
   \   00000004   0x6A84             LDR      R4,[R0, #+40]
   \   00000006   0x6824             LDR      R4,[R4, #+0]
   \   00000008   0x0025             MOVS     R5,R4
   \   0000000A   0xD101             BNE.N    ??USB_Strd_Req_Get_Descriptor_0
   1198              {
   1199                  return error;
   \   0000000C   0x20CA             MOVS     R0,#+202
   \   0000000E   0xBD3E             POP      {R1-R5,PC}
   1200              }
   1201              /* Call descriptor class to get descriptor */
   1202              error = usb_fw_ptr->desc_notify_callback->get_desc((uint32_t)(usb_fw_ptr->desc_notify_param),
   1203                  type,str_num,index,data,size);  
   1204          
   1205              return error;
   \                     ??USB_Strd_Req_Get_Descriptor_0: (+1)
   \   00000010   0x884D             LDRH     R5,[R1, #+2]
   \   00000012   0x9301             STR      R3,[SP, #+4]
   \   00000014   0x9200             STR      R2,[SP, #+0]
   \   00000016   0xB2EA             UXTB     R2,R5
   \   00000018   0x888B             LDRH     R3,[R1, #+4]
   \   0000001A   0x6AC0             LDR      R0,[R0, #+44]
   \   0000001C   0x0A29             LSRS     R1,R5,#+8
   \   0000001E   0x47A0             BLX      R4
   \   00000020   0xBD3E             POP      {R1-R5,PC}       ;; return
   1206          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     g_validate_request
   1207          #if 0
   1208          /**************************************************************************//*!
   1209           *
   1210           * @name  USB_Framework_GetDesc
   1211           *
   1212           * @brief  This function is called in to get the descriptor as specified in cmd.
   1213           *
   1214           * @param handle:           USB framework handle. Received from
   1215           *                          USB_Framework_Init      
   1216           * @param cmd:              command for USB descriptor to get.
   1217           * @param in_data:          input to the Application functions.
   1218           * @param in_buff           buffer which will contain the descriptors.
   1219           * @return status:       
   1220           *                        USB_OK : When Successfully
   1221           *                        Others : When Error
   1222           *
   1223           *****************************************************************************/
   1224          static uint8_t USB_Framework_GetDesc
   1225          (
   1226              usb_class_fw_handle handle, /*[IN]*/
   1227              int32_t cmd,/*[IN]*/
   1228              uint8_t in_data,/*[IN]*/
   1229              uint8_t * * in_buff/*[OUT]*/
   1230          )
   1231          {
   1232              return 0;
   1233          }
   1234          
   1235          /**************************************************************************//*!
   1236           *
   1237           * @name  USB_Framework_SetDesc
   1238           *
   1239           * @brief  This function is called in to get the descriptor as specified in cmd.
   1240           *
   1241           * @param handle:           USB framework handle. Received from
   1242           *                          USB_Framework_Init      
   1243           * @param cmd:              command for USB descriptor to get.
   1244           * @param in_data:          input to the Application functions.
   1245           * @param outBuf           buffer which will contain the descriptors.
   1246           * @return status:       
   1247           *                        USB_OK : When Successfully
   1248           *                        Others : When Error
   1249           *
   1250           *****************************************************************************/
   1251          static uint8_t USB_Framework_SetDesc
   1252          (
   1253              usb_class_fw_handle handle,/*[IN]*/
   1254              int32_t cmd,/*[IN]*/
   1255              uint8_t input_data,/*[IN]*/
   1256              uint8_t * * outBuf/*[IN]*/
   1257          )
   1258          { 
   1259              return 0;
   1260          }
   1261          
   1262          /**************************************************************************//*!
   1263           *
   1264           * @name  USB_Framework_Remote_wakeup
   1265           *
   1266           * @brief  This function is called in to get the descriptor as specified in cmd.
   1267           *
   1268           * @param handle:           USB framework handle. Received from
   1269           *                          USB_Framework_Init      
   1270           * @param cmd:              command for USB descriptor to get.
   1271           * @param in_data:          input to the Application functions.
   1272           * @param in_buff           buffer which will contain the descriptors.
   1273           * @return status:       
   1274           *                        USB_OK : When Successfully
   1275           *                        Others : When Error
   1276           *
   1277           *****************************************************************************/
   1278          bool USB_Framework_Remote_wakeup
   1279          (
   1280              usb_class_fw_handle handle
   1281          )
   1282          { 
   1283              return 0;
   1284          }
   1285          #endif
   1286          
   1287          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   USB_Control_Service
        32   -- Indirect call
        32   -> USB_Control_Service_Handler
        32   -> _usb_device_set_address
        32   -> memcpy
        32   -> usb_device_get_status
        32   -> usb_device_recv_data
        32   -> usb_device_stall_endpoint
      16   USB_Control_Service_Handler
         0   -> usb_device_recv_data
        16   -> usb_device_send_data
         0   -> usb_device_stall_endpoint
       0   USB_Framework_Reset
      24   USB_Reset_Service
        24   -- Indirect call
        24   -> usb_device_init_endpoint
        24   -> usb_device_reset
      24   USB_Strd_Req_Feature
        24   -- Indirect call
        24   -> usb_device_stall_endpoint
        24   -> usb_device_unstall_endpoint
       0   USB_Strd_Req_Get_Config
      24   USB_Strd_Req_Get_Descriptor
        24   -- Indirect call
      16   USB_Strd_Req_Get_Interface
        16   -- Indirect call
      16   USB_Strd_Req_Get_Status
        16   -> usb_device_get_status
      16   USB_Strd_Req_Set_Address
        16   -> usb_device_set_status
      16   USB_Strd_Req_Set_Config
        16   -- Indirect call
        16   -> usb_device_set_status
      16   USB_Strd_Req_Set_Interface
        16   -- Indirect call
      16   USB_Strd_Req_Sync_Frame
        16   -> usb_device_get_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
     280  USB_Control_Service
      76  USB_Control_Service_Handler
       4  USB_Framework_Reset
      76  USB_Reset_Service
     152  USB_Strd_Req_Feature
      12  USB_Strd_Req_Get_Config
      34  USB_Strd_Req_Get_Descriptor
      36  USB_Strd_Req_Get_Interface
      88  USB_Strd_Req_Get_Status
      28  USB_Strd_Req_Set_Address
      68  USB_Strd_Req_Set_Config
      66  USB_Strd_Req_Set_Interface
      26  USB_Strd_Req_Sync_Frame
      92  g_validate_request
          g_standard_request

 
  92 bytes in section .data
 950 bytes in section .text
 
 950 bytes of CODE memory
  92 bytes of DATA memory

Errors: none
Warnings: none
