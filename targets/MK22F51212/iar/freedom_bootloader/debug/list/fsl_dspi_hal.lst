###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:54
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\dspi\hal\fsl_dspi_hal.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\dspi\hal\fsl_dspi_hal.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\fsl_dspi_hal.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\fsl_dspi_hal.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\dspi\hal\fsl_dspi_hal.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_dspi_hal.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint32_t const s_baudratePrescaler[4]
   \                     s_baudratePrescaler:
   \   00000000   0x00000002         DC32 2, 3, 5, 7
   \              0x00000003   
   \              0x00000005   
   \              0x00000007   

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint32_t const s_baudrateScaler[16]
   \                     s_baudrateScaler:
   \   00000000   0x00000002         DC32 2, 4, 6, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
   \              0x00000004   
   \              0x00000006   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \   00000038   0x00004000         DC32 16384, 32768
   \              0x00008000   

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dspi_hal_set_master_slave(SPI_Type *, dspi_master_slave_mode_t)
   \                     dspi_hal_set_master_slave: (+1)
   \   00000000   0x0140             LSLS     R0,R0,#+5
   \   00000002   0x....             LDR.N    R2,??DataTable11  ;; 0x4200007c
   \   00000004   0x5011             STR      R1,[R2, R0]
   \   00000006   0x4770             BX       LR               ;; return
     32          #include "device/fsl_device_registers.h"
     33          
     34          /*******************************************************************************
     35           * Definitions
     36           ******************************************************************************/
     37          
     38          /*******************************************************************************
     39           * Variables
     40           ******************************************************************************/
     41          
     42          /*******************************************************************************
     43           * Code
     44           ******************************************************************************/
     45          
     46          /*FUNCTION**********************************************************************
     47           *
     48           * Function Name : dspi_hal_master_init
     49           * Description   : Configure the DSPI peripheral in master mode.
     50           * This function will initialize the module to user defined settings and default settings in master
     51           * mode.  Here is an example demonstrating how to define the dspi_master_config_t structure and call
     52           * the dspi_hal_master_init function:
     53           *    dspi_master_config_t dspiConfig;
     54           *    dspiConfig.isEnabled = false;
     55           *    dspiConfig.whichCtar = kDspiCtar0;
     56           *    dspiConfig.bitsPerSec = 0;
     57           *    dspiConfig.sourceClockInHz = dspiSourceClock;
     58           *    dspiConfig.isSckContinuous = false;
     59           *    dspiConfig.whichPcs = kDspiPcs0;
     60           *    dspiConfig.pcsPolarity = kDspiPcs_ActiveLow;
     61           *    dspiConfig.masterInSample = kDspiSckToSin_0Clock;
     62           *    dspiConfig.isModifiedTimingFormatEnabled = false;
     63           *    dspiConfig.isTxFifoDisabled = false;
     64           *    dspiConfig.isRxFifoDisabled = false;
     65           *    dspiConfig.dataConfig.bitsPerFrame = 16;
     66           *    dspiConfig.dataConfig.clkPolarity = kDspiClockPolarity_ActiveHigh;
     67           *    dspiConfig.dataConfig.clkPhase = kDspiClockPhase_FirstEdge;
     68           *    dspiConfig.dataConfig.direction = kDspiMsbFirst;
     69           *    dspi_hal_master_init(baseAddr, &dspiConfig, calculatedBaudRate);
     70           *
     71           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          status_t dspi_hal_master_init(SPI_Type * baseAddr, const dspi_master_config_t * config,
     73                                 uint32_t * calculatedBaudRate)
     74          {
   \                     dspi_hal_master_init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
     75              /* Enable or disable the module. */
     76              /* Note, to enable the module, MDIS must be cleared.  However, the member isEnabled*/
     77              /* must be true (1) to enable module, hence we negate the value of isEnabled to properly*/
     78              /* configure the MDIS bit*/
     79              SPI_BWR_MCR_MDIS(baseAddr, ~(config->isEnabled == true));
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable11_1  ;; 0x42000038
   \   0000000A   0x0166             LSLS     R6,R4,#+5
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x5188             STR      R0,[R1, R6]
   \   00000010   0x4617             MOV      R7,R2
     80          
     81              /* Configure baud rate if a value is provided.*/
     82              if (config->bitsPerSec != 0U)
   \   00000012   0x686A             LDR      R2,[R5, #+4]
   \   00000014   0xB12A             CBZ.N    R2,??dspi_hal_master_init_0
     83              {
     84                  *calculatedBaudRate = dspi_hal_set_baud(baseAddr, config->whichCtar, config->bitsPerSec,
     85                                                         config->sourceClockInHz);
   \   00000016   0x68AB             LDR      R3,[R5, #+8]
   \   00000018   0x7869             LDRB     R1,[R5, #+1]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       dspi_hal_set_baud
   \   00000020   0xE000             B.N      ??dspi_hal_master_init_1
     86              }
     87              else
     88              {
     89                  *calculatedBaudRate = 0;
   \                     ??dspi_hal_master_init_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??dspi_hal_master_init_1: (+1)
   \   00000024   0x6038             STR      R0,[R7, #+0]
     90              }
     91          
     92              /* Set master or slave mode.*/
     93              dspi_hal_set_master_slave(baseAddr, kDspiMaster);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       dspi_hal_set_master_slave
     94          
     95              /* Configure data format.*/
     96              if (dspi_hal_configure_data_format(baseAddr, config->whichCtar, &config->dataConfig)
     97                  != kStatus_Success)
   \   0000002E   0x7869             LDRB     R1,[R5, #+1]
   \   00000030   0xF105 0x020C      ADD      R2,R5,#+12
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       dspi_hal_configure_data_format
   \   0000003A   0xB110             CBZ.N    R0,??dspi_hal_master_init_2
     98              {
     99                  return kStatus_DSPI_InvalidBitCount;
   \   0000003C   0xF240 0x1031      MOVW     R0,#+305
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}
    100              }
    101          
    102              /* Configure for continuous SCK operation*/
    103              dspi_hal_configure_continuous_sck(baseAddr, config->isSckContinuous);
   \                     ??dspi_hal_master_init_2: (+1)
   \   00000042   0x7D28             LDRB     R0,[R5, #+20]
   \   00000044   0x....             LDR.N    R1,??DataTable11_2  ;; 0x42000078
   \   00000046   0x5188             STR      R0,[R1, R6]
    104          
    105              /* Configure for peripheral chip select polarity*/
    106              dspi_hal_configure_pcs_polarity(baseAddr, config->whichPcs,config->pcsPolarity);
   \   00000048   0x7DAA             LDRB     R2,[R5, #+22]
   \   0000004A   0x7D69             LDRB     R1,[R5, #+21]
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       dspi_hal_configure_pcs_polarity
    107          
    108              /* Configure sample point for data in, master mode*/
    109              dspi_hal_set_datain_samplepoint(baseAddr, config->masterInSample);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x7DE9             LDRB     R1,[R5, #+23]
   \   00000056   0x0209             LSLS     R1,R1,#+8
   \   00000058   0xF420 0x7040      BIC      R0,R0,#0x300
   \   0000005C   0xF401 0x7140      AND      R1,R1,#0x300
   \   00000060   0x4308             ORRS     R0,R1,R0
   \   00000062   0x6020             STR      R0,[R4, #+0]
    110          
    111              /* Configure for modified timing format*/
    112              dspi_hal_configure_modified_timing_format(baseAddr, config->isModifiedTimingFormatEnabled);
   \   00000064   0x....             LDR.N    R1,??DataTable11_3  ;; 0x42000068
   \   00000066   0x7E28             LDRB     R0,[R5, #+24]
   \   00000068   0x5188             STR      R0,[R1, R6]
    113          
    114              /* Configure for fifo operation*/
    115              dspi_hal_configure_fifos(baseAddr, config->isTxFifoDisabled, config->isRxFifoDisabled);
   \   0000006A   0x7EAA             LDRB     R2,[R5, #+26]
   \   0000006C   0x7E69             LDRB     R1,[R5, #+25]
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       dspi_hal_configure_fifos
    116          
    117              /* finally, clear the DSPI CONFIGURATION (DCONF), even though this is cleared in some IPs*/
    118              /* by default and other bit settings are reserved*/
    119              SPI_CLR_MCR(baseAddr, SPI_MCR_DCONF_MASK);
   \   00000074   0x.... 0x....      BL       ?Subroutine0
    120          
    121              return kStatus_Success;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    122          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0xF020 0x5040      BIC      R0,R0,#0x30000000
   \   00000006   0x6020             STR      R0,[R4, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR
    123          
    124          /*FUNCTION**********************************************************************
    125           *
    126           * Function Name : dspi_hal_slave_init
    127           * Description   : Configure the DSPI peripheral in slave mode.
    128           * This function initializes the DSPI module for slave mode. Here is an example demonstrating how
    129           * to define the dspi_slave_config_t structure and call the dspi_hal_slave_init function:
    130           *    dspi_slave_config_t dspiConfig;
    131           *    dspiConfig.isEnabled = false;
    132           *    dspiConfig.isTxFifoDisabled = false;
    133           *    dspiConfig.isRxFifoDisabled = false;
    134           *    dspiConfig.dataConfig.bitsPerFrame = 16;
    135           *    dspiConfig.dataConfig.clkPolarity = kDspiClockPolarity_ActiveHigh;
    136           *    dspiConfig.dataConfig.clkPhase = kDspiClockPhase_FirstEdge;
    137           *    dspi_hal_slave_init(baseAddr, &dspiConfig);
    138           *
    139           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    140          status_t dspi_hal_slave_init(SPI_Type * baseAddr, const dspi_slave_config_t * config)
    141          {
   \                     dspi_hal_slave_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    142              /* Enable or disable the module.
    143               * Note, to enable the module, MDIS must be cleared.  However, the member isEnabled
    144               * must be true (1) to enable module, hence we negate the value of isEnabled to properly
    145               * configure the MDIS bit
    146               */
    147              SPI_BWR_MCR_MDIS(baseAddr, ~(config->isEnabled == true));
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x....             LDR.N    R2,??DataTable11_1  ;; 0x42000038
   \   0000000A   0x0161             LSLS     R1,R4,#+5
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x5050             STR      R0,[R2, R1]
    148          
    149              /* Set master or slave moe. */
    150              dspi_hal_set_master_slave(baseAddr, kDspiSlave);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       dspi_hal_set_master_slave
    151          
    152              /* Configure data format. For slave mode, only CTAR0 is available for use */
    153              if (dspi_hal_configure_data_format(baseAddr, kDspiCtar0, &config->dataConfig)
    154                  != kStatus_Success)
   \   00000018   0x1D2A             ADDS     R2,R5,#+4
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       dspi_hal_configure_data_format
   \   00000022   0xB110             CBZ.N    R0,??dspi_hal_slave_init_0
    155              {
    156                  return kStatus_DSPI_InvalidBitCount;
   \   00000024   0xF240 0x1031      MOVW     R0,#+305
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    157              }
    158          
    159              /* Configure for fifo operation */
    160              dspi_hal_configure_fifos(baseAddr, config->isTxFifoDisabled, config->isRxFifoDisabled);
   \                     ??dspi_hal_slave_init_0: (+1)
   \   0000002A   0x7B6A             LDRB     R2,[R5, #+13]
   \   0000002C   0x7B29             LDRB     R1,[R5, #+12]
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       dspi_hal_configure_fifos
    161          
    162              /* finally, clear the DSPI CONFIGURATION (DCONF), even though this is cleared in some IPs
    163               * by default and other bit settings are reserved
    164               */
    165              SPI_CLR_MCR(baseAddr, SPI_MCR_DCONF_MASK);
   \   00000034   0x.... 0x....      BL       ?Subroutine0
    166          
    167              return kStatus_Success;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    168          }
    169          
    170          /*FUNCTION**********************************************************************
    171           *
    172           * Function Name : dspi_hal_reset
    173           * Description   : Restore DSPI to reset configuration.
    174           * This function basically resets all of the DSPI registers to their default setting including
    175           * disabling the module.
    176           *
    177           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    178          void dspi_hal_reset(SPI_Type * baseAddr)
    179          {
   \                     dspi_hal_reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    180              /* first, make sure the module is enabled to allow writes to certain registers*/
    181              dspi_hal_enable(baseAddr);
    182          
    183              /* Halt all transfers*/
    184              SPI_WR_MCR(baseAddr, SPI_MCR_HALT_MASK);
    185          
    186              /* flush the fifos*/
    187              dspi_hal_flush_fifos(baseAddr, true, true);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   0000000C   0x6020             STR      R0,[R4, #+0]
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       dspi_hal_flush_fifos
    188          
    189              /* set the registers to their default states*/
    190              /* clear the status bits (write-1-to-clear)*/
    191              SPI_WR_SR(baseAddr, SPI_SR_TCF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK |
    192                                     SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK);
   \   0000001A   0x....             LDR.N    R0,??DataTable11_4  ;; 0x9a0a0000
   \   0000001C   0x62E0             STR      R0,[R4, #+44]
    193              SPI_WR_TCR(baseAddr, 0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x60A0             STR      R0,[R4, #+8]
    194              SPI_WR_CTAR(baseAddr, 0, 0); /* CTAR0*/
   \   00000022   0x60E0             STR      R0,[R4, #+12]
    195              SPI_WR_CTAR(baseAddr, 1, 0); /* CTAR1*/
   \   00000024   0x6120             STR      R0,[R4, #+16]
    196              SPI_WR_RSER(baseAddr, 0);
   \   00000026   0x6320             STR      R0,[R4, #+48]
    197              /* disable the module*/
    198              SPI_WR_MCR(baseAddr, SPI_MCR_MDIS_MASK | SPI_MCR_HALT_MASK);
   \   00000028   0xF244 0x0001      MOVW     R0,#+16385
   \   0000002C   0x6020             STR      R0,[R4, #+0]
    199          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    200          
    201          /*FUNCTION**********************************************************************
    202           *
    203           * Function Name : dspi_hal_set_baud
    204           * Description   : Set the DSPI baud rate in bits per second.
    205           * This function will take in the desired bitsPerSec (baud rate) and will calculate the nearest
    206           * possible baud rate without exceeding the desired baud rate, and will return the calculated
    207           * baud rate in bits-per-second. It requires that the caller also provide the frequency of the
    208           * module source clock (in Hz).
    209           *
    210           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    211          uint32_t dspi_hal_set_baud(SPI_Type * baseAddr, dspi_ctar_selection_t whichCtar, uint32_t bitsPerSec,
    212                                  uint32_t sourceClockInHz)
    213          {
   \                     dspi_hal_set_baud: (+1)
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
    214              /* for master mode configuration, if slave mode detected, return 0*/
    215              if (SPI_RD_MCR_MSTR(baseAddr) != 1)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
   \   00000008   0xD04A             BEQ.N    ??dspi_hal_set_baud_0
    216              {
    217                  return 0;
    218              }
    219          
    220              uint32_t prescaler, bestPrescaler;
    221              uint32_t scaler, bestScaler;
    222              uint32_t dbr, bestDbr;
    223              uint32_t realBaudrate, bestBaudrate;
    224              uint32_t diff, min_diff;
    225              uint32_t baudrate = bitsPerSec;
    226          
    227              /* find combination of prescaler and scaler resulting in baudrate closest to the */
    228              /* requested value */
    229              min_diff = 0xFFFFFFFFU;
   \   0000000A   0xF04F 0x35FF      MOV      R5,#-1
    230              bestPrescaler = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
    231              bestScaler = 0;
   \   00000010   0x2300             MOVS     R3,#+0
    232              bestDbr = 1;
   \   00000012   0x2401             MOVS     R4,#+1
    233              bestBaudrate = 0; /* required to avoid compilation warning */
   \   00000014   0x2000             MOVS     R0,#+0
    234          
    235              /* In all for loops, if min_diff = 0, the exit for loop*/
    236              for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x.... 0x....      ADR.W    R8,s_baudrateScaler
   \   0000001C   0x.... 0x....      ADR.W    R12,s_baudratePrescaler
    237              {
    238                  for (scaler = 0; (scaler < 16) && min_diff; scaler++)
   \                     ??dspi_hal_set_baud_1: (+1)
   \   00000020   0xF04F 0x0E00      MOV      LR,#+0
    239                  {
    240                      for (dbr = 1; (dbr < 3) && min_diff; dbr++)
   \                     ??dspi_hal_set_baud_2: (+1)
   \   00000024   0x2701             MOVS     R7,#+1
    241                      {
    242                          realBaudrate = ((sourceClockInHz * dbr) /
    243                                          (s_baudratePrescaler[prescaler] * (s_baudrateScaler[scaler])));
   \                     ??dspi_hal_set_baud_3: (+1)
   \   00000026   0xF8DD 0x9008      LDR      R9,[SP, #+8]
   \   0000002A   0xF85C 0xA026      LDR      R10,[R12, R6, LSL #+2]
   \   0000002E   0xF858 0xB02E      LDR      R11,[R8, LR, LSL #+2]
   \   00000032   0xFB07 0xF909      MUL      R9,R7,R9
   \   00000036   0xFB0B 0xFA0A      MUL      R10,R11,R10
   \   0000003A   0xFBB9 0xF9FA      UDIV     R9,R9,R10
    244          
    245                          /* calculate the baud rate difference based on the conditional statement*/
    246                          /* that states that the calculated baud rate must not exceed the desired baud rate*/
    247                          if (baudrate >= realBaudrate)
   \   0000003E   0x454A             CMP      R2,R9
   \   00000040   0xD308             BCC.N    ??dspi_hal_set_baud_4
    248                          {
    249                              diff = baudrate-realBaudrate;
   \   00000042   0xEBA2 0x0A09      SUB      R10,R2,R9
    250                              if (min_diff > diff)
   \   00000046   0x45AA             CMP      R10,R5
   \   00000048   0xD204             BCS.N    ??dspi_hal_set_baud_4
    251                              {
    252                                  /* a better match found */
    253                                  min_diff = diff;
   \   0000004A   0x4655             MOV      R5,R10
    254                                  bestPrescaler = prescaler;
   \   0000004C   0x4631             MOV      R1,R6
    255                                  bestScaler = scaler;
   \   0000004E   0x4673             MOV      R3,LR
    256                                  bestBaudrate = realBaudrate;
   \   00000050   0x4648             MOV      R0,R9
    257                                  bestDbr = dbr;
   \   00000052   0x463C             MOV      R4,R7
    258                              }
    259                          }
    260                      }
   \                     ??dspi_hal_set_baud_4: (+1)
   \   00000054   0x1C7F             ADDS     R7,R7,#+1
   \   00000056   0x2F03             CMP      R7,#+3
   \   00000058   0xD202             BCS.N    ??dspi_hal_set_baud_5
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD1E3             BNE.N    ??dspi_hal_set_baud_3
   \   0000005E   0xE00C             B.N      ??dspi_hal_set_baud_6
    261                  }
   \                     ??dspi_hal_set_baud_5: (+1)
   \   00000060   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000064   0xF1BE 0x0F10      CMP      LR,#+16
   \   00000068   0xD202             BCS.N    ??dspi_hal_set_baud_7
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD1DA             BNE.N    ??dspi_hal_set_baud_2
   \   0000006E   0xE004             B.N      ??dspi_hal_set_baud_6
    262              }
   \                     ??dspi_hal_set_baud_7: (+1)
   \   00000070   0x1C76             ADDS     R6,R6,#+1
   \   00000072   0x2E04             CMP      R6,#+4
   \   00000074   0xD201             BCS.N    ??dspi_hal_set_baud_6
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD1D2             BNE.N    ??dspi_hal_set_baud_1
   \                     ??dspi_hal_set_baud_6: (+1)
   \   0000007A   0x9A00             LDR      R2,[SP, #+0]
   \   0000007C   0xF89D 0x5004      LDRB     R5,[SP, #+4]
    263          
    264              uint32_t temp;
    265              /* write the best dbr, prescalar, and baud rate scalar to the CTAR*/
    266              temp = SPI_RD_CTAR(baseAddr, whichCtar); /* save register contents*/
    267              temp &= ~(SPI_CTAR_DBR_MASK| SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK);
    268              temp |= SPI_CTAR_DBR(bestDbr - 1) |
    269                      SPI_CTAR_PBR(bestPrescaler) |
    270                      SPI_CTAR_BR(bestScaler);
    271              SPI_WR_CTAR(baseAddr, whichCtar, temp);
   \   00000080   0x....             LDR.N    R6,??DataTable11_5  ;; 0x7ffcfff0
   \   00000082   0xEB02 0x0285      ADD      R2,R2,R5, LSL #+2
   \   00000086   0x1E64             SUBS     R4,R4,#+1
   \   00000088   0x68D5             LDR      R5,[R2, #+12]
   \   0000008A   0x4035             ANDS     R5,R6,R5
   \   0000008C   0x0409             LSLS     R1,R1,#+16
   \   0000008E   0xEA45 0x74C4      ORR      R4,R5,R4, LSL #+31
   \   00000092   0xF401 0x3140      AND      R1,R1,#0x30000
   \   00000096   0x4321             ORRS     R1,R1,R4
   \   00000098   0xF003 0x030F      AND      R3,R3,#0xF
   \   0000009C   0x4319             ORRS     R1,R3,R1
   \   0000009E   0x60D1             STR      R1,[R2, #+12]
    272          
    273              /* return the actual calculated baud rate*/
    274              return bestBaudrate;
   \                     ??dspi_hal_set_baud_0: (+1)
   \   000000A0   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    275          }
    276          
    277          /*FUNCTION**********************************************************************
    278           *
    279           * Function Name : dspi_hal_set_baud_divisors
    280           * Description   : Configure the baud rate divisors manually.
    281           * This function allows the caller to manually set the baud rate divisors in the event that
    282           * these dividers are known and the caller does not wish to call the dspi_hal_set_baud function.
    283           *
    284           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          void dspi_hal_set_baud_divisors(SPI_Type * baseAddr,
    286                                          dspi_ctar_selection_t whichCtar,
    287                                          const dspi_baud_rate_divisors_t * divisors)
    288          {
    289              uint32_t temp;
    290          
    291              /* these settings are only relevant in master mode*/
    292              if (SPI_RD_MCR_MSTR(baseAddr) == 1)
   \                     dspi_hal_set_baud_divisors: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0x0FDB             LSRS     R3,R3,#+31
   \   00000004   0xD011             BEQ.N    ??dspi_hal_set_baud_divisors_0
   \   00000006   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
    293              {
    294                  temp = SPI_RD_CTAR(baseAddr, whichCtar); /* save register contents*/
    295                  temp &= ~(SPI_CTAR_DBR_MASK | SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK); /* clear dividers*/
    296                  temp |= SPI_CTAR_DBR(divisors->doubleBaudRate) |
    297                          SPI_CTAR_PBR(divisors->prescaleDivisor) |
    298                          SPI_CTAR_BR(divisors->baudRateDivisor);
    299                  SPI_WR_CTAR(baseAddr, whichCtar, temp);
   \   0000000A   0x....             LDR.N    R3,??DataTable11_5  ;; 0x7ffcfff0
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x4019             ANDS     R1,R3,R1
   \   00000010   0x7813             LDRB     R3,[R2, #+0]
   \   00000012   0xEA41 0x71C3      ORR      R1,R1,R3, LSL #+31
   \   00000016   0x6853             LDR      R3,[R2, #+4]
   \   00000018   0x7A12             LDRB     R2,[R2, #+8]
   \   0000001A   0x041B             LSLS     R3,R3,#+16
   \   0000001C   0xF403 0x3340      AND      R3,R3,#0x30000
   \   00000020   0x4319             ORRS     R1,R3,R1
   \   00000022   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0x60C1             STR      R1,[R0, #+12]
    300              }
    301          }
   \                     ??dspi_hal_set_baud_divisors_0: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    302          
    303          /*FUNCTION**********************************************************************
    304           *
    305           * Function Name : dspi_hal_configure_pcs_polarity
    306           * Description   : Configure DSPI peripheral chip select polarity.
    307           * This function will take in the desired peripheral chip select (PCS) and it's
    308           * corresponding desired polarity and will configure the PCS signal to operate with the
    309           * desired characteristic.
    310           *
    311           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          void dspi_hal_configure_pcs_polarity(SPI_Type * baseAddr, dspi_which_pcs_config_t pcs,
    313                                               dspi_pcs_polarity_config_t activeLowOrHigh)
    314          {
    315              uint32_t temp;
    316          
    317              temp = SPI_RD_MCR_PCSIS(baseAddr);
   \                     dspi_hal_configure_pcs_polarity: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0xF3C3 0x4305      UBFX     R3,R3,#+16,#+6
    318          
    319              if (activeLowOrHigh == kDspiPcs_ActiveLow)
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF0C             ITE      EQ 
   \   0000000A   0x4319             ORREQ    R1,R1,R3
   \   0000000C   0xEA23 0x0101      BICNE    R1,R3,R1
    320              {
    321                  temp |= pcs;
    322              }
    323              else  /* kDspiPcsPolarity_ActiveHigh*/
    324              {
    325                  temp &= ~(unsigned)pcs;
    326              }
    327          
    328              SPI_BWR_MCR_PCSIS(baseAddr, temp);
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x0409             LSLS     R1,R1,#+16
   \   00000014   0xF422 0x127C      BIC      R2,R2,#0x3F0000
   \   00000018   0xF401 0x117C      AND      R1,R1,#0x3F0000
   \   0000001C   0x4311             ORRS     R1,R1,R2
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    329          }
   \   00000020   0x4770             BX       LR               ;; return
    330          
    331          
    332          /*FUNCTION**********************************************************************
    333           *
    334           * Function Name : dspi_hal_configure_fifos
    335           * Description   : Configure DSPI fifos.
    336           * This function with allow the caller to disable/enable the TX and RX FIFOs (independently).
    337           * Note that to disable, the caller must pass in a logic 1 (true) for the particular FIFO
    338           * configuration.  To enable, the caller must pass in a logic 0 (false).  For example, to enable
    339           * both the TX and RX FIFOs, the caller will make this function call (where baseAddr is the
    340           *
    341           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    342          void dspi_hal_configure_fifos(SPI_Type * baseAddr, bool disableTxFifo, bool disableRxFifo)
    343          {
   \                     dspi_hal_configure_fifos: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    344              /* first see if MDIS is set or cleared */
    345              uint32_t isMdisSet = SPI_RD_MCR_MDIS(baseAddr);
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0xF3C3 0x3380      UBFX     R3,R3,#+14,#+1
    346          
    347              if (isMdisSet)
   \   00000008   0xB11B             CBZ.N    R3,??dspi_hal_configure_fifos_0
    348              {
    349                  /* clear the MDIS bit to allow us to write to the fifo disables */
    350                  SPI_CLR_MCR(baseAddr, SPI_MCR_MDIS_MASK);
   \   0000000A   0x6804             LDR      R4,[R0, #+0]
   \   0000000C   0xF424 0x4480      BIC      R4,R4,#0x4000
   \   00000010   0x6004             STR      R4,[R0, #+0]
    351              }
    352          
    353              SPI_BWR_MCR_DIS_TXF(baseAddr, (disableTxFifo == true));
   \                     ??dspi_hal_configure_fifos_0: (+1)
   \   00000012   0x0144             LSLS     R4,R0,#+5
   \   00000014   0x....             LDR.N    R5,??DataTable11_6  ;; 0x42000034
   \   00000016   0x5129             STR      R1,[R5, R4]
    354              SPI_BWR_MCR_DIS_RXF(baseAddr, (disableRxFifo == true));
   \   00000018   0x....             LDR.N    R1,??DataTable11_7  ;; 0x42000030
   \   0000001A   0x510A             STR      R2,[R1, R4]
    355          
    356              /* set MDIS if it was set to begin with */
    357              if (isMdisSet)
   \   0000001C   0xB11B             CBZ.N    R3,??dspi_hal_configure_fifos_1
    358              {
    359                  SPI_SET_MCR(baseAddr, SPI_MCR_MDIS_MASK);
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000024   0x6001             STR      R1,[R0, #+0]
    360              }
    361          }
   \                     ??dspi_hal_configure_fifos_1: (+1)
   \   00000026   0xBD30             POP      {R4,R5,PC}       ;; return
    362          
    363          /*FUNCTION**********************************************************************
    364           *
    365           * Function Name : dspi_hal_flush_fifos
    366           * Description   : Flush DSPI fifos.
    367           *
    368           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    369          void dspi_hal_flush_fifos(SPI_Type * baseAddr, bool enableFlushTxFifo, bool enableFlushRxFifo)
    370          {
    371              SPI_BWR_MCR_CLR_TXF(baseAddr, (enableFlushTxFifo == true));
   \                     dspi_hal_flush_fifos: (+1)
   \   00000000   0x0140             LSLS     R0,R0,#+5
   \   00000002   0x....             LDR.N    R3,??DataTable11_8  ;; 0x4200002c
   \   00000004   0x5019             STR      R1,[R3, R0]
    372              SPI_BWR_MCR_CLR_RXF(baseAddr, (enableFlushRxFifo == true));
   \   00000006   0x....             LDR.N    R1,??DataTable11_9  ;; 0x42000028
   \   00000008   0x500A             STR      R2,[R1, R0]
    373          }
   \   0000000A   0x4770             BX       LR               ;; return
    374          
    375          /*FUNCTION**********************************************************************
    376           *
    377           * Function Name : dspi_hal_configure_data_format
    378           * Description   : Configure the data format for a particular CTAR.
    379           * This function configures the bits-per-frame, polarity, phase, and shift direction for a
    380           * particular CTAR. An example use case is as follows:
    381           *    dspi_data_format_config_t dataFormat;
    382           *    dataFormat.bitsPerFrame = 16;
    383           *    dataFormat.clkPolarity = kDspiClockPolarity_ActiveLow;
    384           *    dataFormat.clkPhase = kDspiClockPhase_FirstEdge;
    385           *    dataFormat.direction = kDspiMsbFirst;
    386           *    dspi_hal_configure_data_format(baseAddr, kDspiCtar0, &dataFormat);
    387           *
    388           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    389          status_t dspi_hal_configure_data_format(SPI_Type * baseAddr,
    390                                                  dspi_ctar_selection_t whichCtar,
    391                                                  const dspi_data_format_config_t * config)
    392          {
   \                     dspi_hal_configure_data_format: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    393              /* check bits-per-frame value to make sure it it within the proper range*/
    394              /* in either master or slave mode*/
    395              if ((config->bitsPerFrame < 4) ||
    396                  ((config->bitsPerFrame > 16) && (SPI_RD_MCR_MSTR(baseAddr) == 1)) ||
    397                  ((config->bitsPerFrame > 32) && (SPI_RD_MCR_MSTR(baseAddr) == 0)))
   \   00000002   0x6815             LDR      R5,[R2, #+0]
   \   00000004   0x2D04             CMP      R5,#+4
   \   00000006   0xD309             BCC.N    ??dspi_hal_configure_data_format_0
   \   00000008   0x2D11             CMP      R5,#+17
   \   0000000A   0xD302             BCC.N    ??dspi_hal_configure_data_format_1
   \   0000000C   0x6803             LDR      R3,[R0, #+0]
   \   0000000E   0x0FDB             LSRS     R3,R3,#+31
   \   00000010   0xD104             BNE.N    ??dspi_hal_configure_data_format_0
   \                     ??dspi_hal_configure_data_format_1: (+1)
   \   00000012   0x2D21             CMP      R5,#+33
   \   00000014   0xD305             BCC.N    ??dspi_hal_configure_data_format_2
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x0FDB             LSRS     R3,R3,#+31
   \   0000001A   0xD102             BNE.N    ??dspi_hal_configure_data_format_2
    398              {
    399                  return kStatus_DSPI_InvalidBitCount;
   \                     ??dspi_hal_configure_data_format_0: (+1)
   \   0000001C   0xF240 0x1031      MOVW     R0,#+305
   \   00000020   0xBD30             POP      {R4,R5,PC}
    400              }
    401          
    402              uint32_t temp;
    403          
    404              /* for master mode configuration*/
    405              if (SPI_RD_MCR_MSTR(baseAddr) == 1)
   \                     ??dspi_hal_configure_data_format_2: (+1)
   \   00000022   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \   00000026   0x1E6D             SUBS     R5,R5,#+1
   \   00000028   0x7953             LDRB     R3,[R2, #+5]
   \   0000002A   0x7914             LDRB     R4,[R2, #+4]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x06ED             LSLS     R5,R5,#+27
   \   00000030   0x065B             LSLS     R3,R3,#+25
   \   00000032   0x06A4             LSLS     R4,R4,#+26
   \   00000034   0x0FC0             LSRS     R0,R0,#+31
   \   00000036   0x68C8             LDR      R0,[R1, #+12]
   \   00000038   0xF003 0x7300      AND      R3,R3,#0x2000000
   \   0000003C   0xF004 0x6480      AND      R4,R4,#0x4000000
   \   00000040   0xD00C             BEQ.N    ??dspi_hal_configure_data_format_3
    406              {
    407                  temp = SPI_RD_CTAR(baseAddr, whichCtar); /* save register contents*/
    408                  temp &= ~(SPI_CTAR_FMSZ_MASK| SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
    409                  temp |= SPI_CTAR_FMSZ(config->bitsPerFrame - 1) |
    410                          SPI_CTAR_CPOL(config->clkPolarity) |
    411                          SPI_CTAR_CPHA(config->clkPhase) |
    412                          SPI_CTAR_LSBFE(config->direction);
    413                  SPI_WR_CTAR(baseAddr, whichCtar, temp);
   \   00000042   0xF020 0x40FE      BIC      R0,R0,#0x7F000000
   \   00000046   0xF005 0x45F0      AND      R5,R5,#0x78000000
   \   0000004A   0x7992             LDRB     R2,[R2, #+6]
   \   0000004C   0x4328             ORRS     R0,R5,R0
   \   0000004E   0x4320             ORRS     R0,R4,R0
   \   00000050   0x0612             LSLS     R2,R2,#+24
   \   00000052   0x4318             ORRS     R0,R3,R0
   \   00000054   0xF002 0x7280      AND      R2,R2,#0x1000000
   \   00000058   0x4310             ORRS     R0,R2,R0
   \   0000005A   0xE004             B.N      ??dspi_hal_configure_data_format_4
    414              }
    415              else /* for slave mode configuration*/
    416              {
    417                  temp = SPI_RD_CTAR_SLAVE(baseAddr, whichCtar); /* save register contents*/
    418                  temp &= ~(SPI_CTAR_FMSZ_MASK| SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK);
    419                  temp |= SPI_CTAR_SLAVE_FMSZ(config->bitsPerFrame - 1) |
    420                          SPI_CTAR_SLAVE_CPOL(config->clkPolarity) |
    421                          SPI_CTAR_SLAVE_CPHA(config->clkPhase);
    422                  SPI_WR_CTAR_SLAVE(baseAddr, whichCtar, temp);
   \                     ??dspi_hal_configure_data_format_3: (+1)
   \   0000005C   0xF020 0x40FC      BIC      R0,R0,#0x7E000000
   \   00000060   0x4328             ORRS     R0,R5,R0
   \   00000062   0x4320             ORRS     R0,R4,R0
   \   00000064   0x4318             ORRS     R0,R3,R0
   \                     ??dspi_hal_configure_data_format_4: (+1)
   \   00000066   0x60C8             STR      R0,[R1, #+12]
    423              }
    424              return kStatus_Success;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD30             POP      {R4,R5,PC}       ;; return
    425          }
    426          
    427          /*FUNCTION**********************************************************************
    428           *
    429           * Function Name : dspi_hal_configure_delays
    430           * Description   : Configure the delays for a particular CTAR, master mode only.
    431           * This function configures the PCS to SCK delay prescalar (PCSSCK),
    432           * the PCS to SCK Delay scalar (CSSCK),
    433           * the After SCK delay prescalar (PASC),
    434           * the After SCK delay scalar (ASC),
    435           * the Delay after transfer prescalar (PDT),
    436           * and the Delay after transfer scalar (DT).
    437           * The following is an example use case of this function:
    438           *    dspi_delay_settings_config_t delayConfig;
    439           *    delayConfig.pcsToSckPre = 0x3;
    440           *    delayConfig.pcsToSck = 0xF;
    441           *    delayConfig.afterSckPre = 0x2;
    442           *    delayConfig.afterSck = 0xA;
    443           *    delayConfig.afterTransferPre = 0x1;
    444           *    delayConfig.afterTransfer = 0x5;
    445           *    dspi_hal_configure_delays(baseAddr, kDspiCtar0, &delayConfig);
    446           *
    447           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    448          void dspi_hal_configure_delays(SPI_Type * baseAddr,
    449                                         dspi_ctar_selection_t whichCtar,
    450                                         const dspi_delay_settings_config_t * config)
    451          {
    452              uint32_t temp;
    453          
    454              /* these settings are only relevant in master mode*/
    455              if (SPI_RD_MCR_MSTR(baseAddr) == 1)
   \                     dspi_hal_configure_delays: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0x0FDB             LSRS     R3,R3,#+31
   \   00000004   0xD023             BEQ.N    ??dspi_hal_configure_delays_0
   \   00000006   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
    456              {
    457                  temp = SPI_RD_CTAR(baseAddr, whichCtar); /* save register contents*/
    458                  temp &= ~(SPI_CTAR_PCSSCK_MASK | SPI_CTAR_PASC_MASK | SPI_CTAR_PDT_MASK |
    459                            SPI_CTAR_CSSCK_MASK| SPI_CTAR_ASC_MASK | SPI_CTAR_DT_MASK);
    460                  temp |= SPI_CTAR_PCSSCK(config->pcsToSckPre) |
    461                          SPI_CTAR_PASC(config->afterSckPre) |
    462                          SPI_CTAR_PDT(config->afterTransferPre) |
    463                          SPI_CTAR_CSSCK(config->pcsToSck) |
    464                          SPI_CTAR_ASC(config->afterSck) |
    465                          SPI_CTAR_DT(config->afterTransfer);
    466                  SPI_WR_CTAR(baseAddr, whichCtar, temp);
   \   0000000A   0x....             LDR.N    R3,??DataTable11_10  ;; 0xff03000f
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x4019             ANDS     R1,R3,R1
   \   00000010   0x6813             LDR      R3,[R2, #+0]
   \   00000012   0x059B             LSLS     R3,R3,#+22
   \   00000014   0xF403 0x0340      AND      R3,R3,#0xC00000
   \   00000018   0x4319             ORRS     R1,R3,R1
   \   0000001A   0x6893             LDR      R3,[R2, #+8]
   \   0000001C   0x051B             LSLS     R3,R3,#+20
   \   0000001E   0xF403 0x1340      AND      R3,R3,#0x300000
   \   00000022   0x4319             ORRS     R1,R3,R1
   \   00000024   0x6913             LDR      R3,[R2, #+16]
   \   00000026   0x049B             LSLS     R3,R3,#+18
   \   00000028   0xF403 0x2340      AND      R3,R3,#0xC0000
   \   0000002C   0x4319             ORRS     R1,R3,R1
   \   0000002E   0x6853             LDR      R3,[R2, #+4]
   \   00000030   0x031B             LSLS     R3,R3,#+12
   \   00000032   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000036   0x4319             ORRS     R1,R3,R1
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0x6952             LDR      R2,[R2, #+20]
   \   0000003C   0x021B             LSLS     R3,R3,#+8
   \   0000003E   0xF403 0x6370      AND      R3,R3,#0xF00
   \   00000042   0x0112             LSLS     R2,R2,#+4
   \   00000044   0x4319             ORRS     R1,R3,R1
   \   00000046   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   0000004A   0x4311             ORRS     R1,R2,R1
   \   0000004C   0x60C1             STR      R1,[R0, #+12]
    467              }
    468          }
   \                     ??dspi_hal_configure_delays_0: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
    469          
    470          /*FUNCTION**********************************************************************
    471           *
    472           * Function Name : dspi_hal_configure_dma
    473           * Description   : Configure transmit and receive DMA requests.
    474           * This function configures the FIFOs to generate a DMA or interrupt request.
    475           *
    476           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    477          void dspi_hal_configure_dma(SPI_Type * baseAddr, bool enableTransmit, bool enableReceive)
    478          {
    479              SPI_BWR_RSER_TFFF_DIRS(baseAddr, enableTransmit);
   \                     dspi_hal_configure_dma: (+1)
   \   00000000   0x3030             ADDS     R0,R0,#+48
   \   00000002   0x0140             LSLS     R0,R0,#+5
   \   00000004   0x....             LDR.N    R3,??DataTable11_11  ;; 0x42000060
   \   00000006   0x5019             STR      R1,[R3, R0]
    480              SPI_BWR_RSER_RFDF_DIRS(baseAddr, enableReceive);
   \   00000008   0x....             LDR.N    R1,??DataTable11_12  ;; 0x42000040
   \   0000000A   0x500A             STR      R2,[R1, R0]
    481          }
   \   0000000C   0x4770             BX       LR               ;; return
    482          
    483          /*FUNCTION**********************************************************************
    484           *
    485           * Function Name : dspi_hal_configure_interrupt
    486           * Description   : Configure DSPI interrupts.
    487           * This function will configure the various interrupt sources of the DSPI.  The parameters to pass
    488           * in are baseAddr, interrupt source, and enable/disable setting.
    489           * The interrupt source will be of a typedef enum whose value will be the bit position of the
    490           * interrupt source setting within the RSER register.  In the DSPI, all of the interrupt
    491           * configuration settings reside within the one register.  The typedef enum will equate each
    492           * interrupt source to the bit position defined in the device header file.
    493           * The function will use these bit positions in its algorithm to enable/disable the
    494           * interrupt source, where interrupt source is of type dspi_status_and_interrupt_request_t.
    495           *    temp = (SPI_RD_RSER(baseAddr) & ~interruptSrc) | (enable << interruptSrc);
    496           *    SPI_WR_RSER(baseAddr, temp);
    497           *
    498           *    dspi_hal_configure_interrupt(baseAddr, kDspiTxComplete, true); <- example use-case
    499           *
    500           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    501          void dspi_hal_configure_interrupt(SPI_Type * baseAddr,
    502                                            dspi_status_and_interrupt_request_t interruptSrc,
    503                                            bool enable)
    504          {
   \                     dspi_hal_configure_interrupt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    505              uint32_t temp;
    506          
    507              temp = (SPI_RD_RSER(baseAddr) & ~(0x1U << interruptSrc)) | ((uint32_t)enable << interruptSrc);
    508              SPI_WR_RSER(baseAddr, temp);
   \   00000002   0x6B03             LDR      R3,[R0, #+48]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000E   0x4319             ORRS     R1,R1,R3
   \   00000010   0x6301             STR      R1,[R0, #+48]
    509          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    510          
    511          /*FUNCTION**********************************************************************
    512           *
    513           * Function Name : dspi_hal_get_fifo_data
    514           * Description   : Read fifo registers for debug purposes.
    515           *
    516           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    517          uint32_t dspi_hal_get_fifo_data(SPI_Type * baseAddr, dspi_fifo_t whichFifo, uint32_t whichFifoEntry)
    518          {
    519              if (whichFifo == kDspiTxFifo)
   \                     dspi_hal_get_fifo_data: (+1)
   \   00000000   0x303C             ADDS     R0,R0,#+60
   \   00000002   0xB959             CBNZ.N   R1,??dspi_hal_get_fifo_data_0
    520              {
    521                  if (whichFifoEntry == 0)
   \   00000004   0xB90A             CBNZ.N   R2,??dspi_hal_get_fifo_data_1
    522                  {
    523                      return SPI_RD_TXFR0(baseAddr);
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4770             BX       LR
    524                  }
    525                  else if (whichFifoEntry == 1)
   \                     ??dspi_hal_get_fifo_data_1: (+1)
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD101             BNE.N    ??dspi_hal_get_fifo_data_2
    526                  {
    527                      return SPI_RD_TXFR1(baseAddr);
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x4770             BX       LR
    528                  }
    529                  else if (whichFifoEntry == 2)
   \                     ??dspi_hal_get_fifo_data_2: (+1)
   \   00000012   0x2A02             CMP      R2,#+2
   \   00000014   0xBF0C             ITE      EQ 
   \   00000016   0x6880             LDREQ    R0,[R0, #+8]
   \   00000018   0x68C0             LDRNE    R0,[R0, #+12]
    530                  {
    531                      return SPI_RD_TXFR2(baseAddr);
    532                  }
    533                  else
    534                  {
    535                      return SPI_RD_TXFR3(baseAddr);
   \   0000001A   0x4770             BX       LR
    536                  }
    537              }
    538              else
    539              {
    540                  if (whichFifoEntry == 0)
   \                     ??dspi_hal_get_fifo_data_0: (+1)
   \   0000001C   0xB90A             CBNZ.N   R2,??dspi_hal_get_fifo_data_3
    541                  {
    542                      return SPI_RD_RXFR0(baseAddr);
   \   0000001E   0x6C00             LDR      R0,[R0, #+64]
   \   00000020   0x4770             BX       LR
    543                  }
    544                  else if (whichFifoEntry == 1)
   \                     ??dspi_hal_get_fifo_data_3: (+1)
   \   00000022   0x2A01             CMP      R2,#+1
   \   00000024   0xD101             BNE.N    ??dspi_hal_get_fifo_data_4
    545                  {
    546                      return SPI_RD_RXFR1(baseAddr);
   \   00000026   0x6C40             LDR      R0,[R0, #+68]
   \   00000028   0x4770             BX       LR
    547                  }
    548                  else if (whichFifoEntry == 2)
   \                     ??dspi_hal_get_fifo_data_4: (+1)
   \   0000002A   0x2A02             CMP      R2,#+2
   \   0000002C   0xBF0C             ITE      EQ 
   \   0000002E   0x6C80             LDREQ    R0,[R0, #+72]
   \   00000030   0x6CC0             LDRNE    R0,[R0, #+76]
    549                  {
    550                      return SPI_RD_RXFR2(baseAddr);
    551                  }
    552                  else
    553                  {
    554                      return SPI_RD_RXFR3(baseAddr);
   \   00000032   0x4770             BX       LR
    555                  }
    556              }
    557          }
    558          
    559          /*FUNCTION**********************************************************************
    560           *
    561           * Function Name : dspi_hal_write_data_master_mode
    562           * Description   : Write data into the data buffer, master mode.
    563           * In master mode, the 16-bit data is appended with the 16-bit command info. The command portion
    564           * provides characteristics of the data being sent such as: optional continuous chip select
    565           * operation between transfers, the desired Clock and Transfer Attributes register to use for the
    566           * associated SPI frame, the desired PCS signal to use for the data transfer, whether the current
    567           * transfer is the last in the queue, and whether to clear the transfer count (normally needed when
    568           * sending the first frame of a data packet). An example use case is as follows:
    569           *    dspi_command_config_t commandConfig;
    570           *    commandConfig.isChipSelectContinuous = true;
    571           *    commandConfig.whichCtar = kDspiCtar0;
    572           *    commandConfig.whichPcs = kDspiPcs1;
    573           *    commandConfig.clearTransferCount = false;
    574           *    commandConfig.isEndOfQueue = false;
    575           *    dspi_hal_write_data_master_mode(baseAddr, &commandConfig, dataWord);
    576           *
    577           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    578          void dspi_hal_write_data_master_mode(SPI_Type * baseAddr,
    579                                               dspi_command_config_t * command,
    580                                               uint16_t data)
    581          {
   \                     dspi_hal_write_data_master_mode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    582              uint32_t temp;
    583          
    584              temp = SPI_PUSHR_CONT(command->isChipSelectContinuous) |
    585                     SPI_PUSHR_CTAS(command->whichCtar) |
    586                     SPI_PUSHR_PCS(command->whichPcs) |
    587                     SPI_PUSHR_EOQ(command->isEndOfQueue) |
    588                     SPI_PUSHR_CTCNT(command->clearTransferCount) |
    589                     SPI_PUSHR_TXDATA(data);
    590          
    591              SPI_WR_PUSHR(baseAddr, temp);
   \   00000002   0x784C             LDRB     R4,[R1, #+1]
   \   00000004   0x780B             LDRB     R3,[R1, #+0]
   \   00000006   0x0724             LSLS     R4,R4,#+28
   \   00000008   0xF004 0x44E0      AND      R4,R4,#0x70000000
   \   0000000C   0xEA44 0x73C3      ORR      R3,R4,R3, LSL #+31
   \   00000010   0x788C             LDRB     R4,[R1, #+2]
   \   00000012   0x0424             LSLS     R4,R4,#+16
   \   00000014   0xF404 0x147C      AND      R4,R4,#0x3F0000
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0x78CC             LDRB     R4,[R1, #+3]
   \   0000001C   0x7909             LDRB     R1,[R1, #+4]
   \   0000001E   0xEA43 0x63C4      ORR      R3,R3,R4, LSL #+27
   \   00000022   0xEA43 0x6181      ORR      R1,R3,R1, LSL #+26
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0x6341             STR      R1,[R0, #+52]
    592          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x4200007C         DC32     0x4200007c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x42000038         DC32     0x42000038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x42000078         DC32     0x42000078

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x42000068         DC32     0x42000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x9A0A0000         DC32     0x9a0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x7FFCFFF0         DC32     0x7ffcfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x42000034         DC32     0x42000034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x42000030         DC32     0x42000030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x4200002C         DC32     0x4200002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x42000028         DC32     0x42000028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0xFF03000F         DC32     0xff03000f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x42000060         DC32     0x42000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x42000040         DC32     0x42000040
    593          
    594          /*******************************************************************************
    595           * EOF
    596           ******************************************************************************/
    597          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   dspi_hal_configure_data_format
       0   dspi_hal_configure_delays
       0   dspi_hal_configure_dma
      12   dspi_hal_configure_fifos
       8   dspi_hal_configure_interrupt
       0   dspi_hal_configure_pcs_polarity
       0   dspi_hal_flush_fifos
       0   dspi_hal_get_fifo_data
      24   dspi_hal_master_init
        24   -> dspi_hal_configure_data_format
        24   -> dspi_hal_configure_fifos
        24   -> dspi_hal_configure_pcs_polarity
        24   -> dspi_hal_set_baud
        24   -> dspi_hal_set_master_slave
       8   dspi_hal_reset
         8   -> dspi_hal_flush_fifos
      48   dspi_hal_set_baud
       0   dspi_hal_set_baud_divisors
       0   dspi_hal_set_master_slave
      16   dspi_hal_slave_init
        16   -> dspi_hal_configure_data_format
        16   -> dspi_hal_configure_fifos
        16   -> dspi_hal_set_master_slave
       8   dspi_hal_write_data_master_mode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      12  ?Subroutine0
     108  dspi_hal_configure_data_format
      80  dspi_hal_configure_delays
      14  dspi_hal_configure_dma
      40  dspi_hal_configure_fifos
      20  dspi_hal_configure_interrupt
      34  dspi_hal_configure_pcs_polarity
      12  dspi_hal_flush_fifos
      52  dspi_hal_get_fifo_data
     122  dspi_hal_master_init
      48  dspi_hal_reset
     164  dspi_hal_set_baud
      44  dspi_hal_set_baud_divisors
       8  dspi_hal_set_master_slave
      58  dspi_hal_slave_init
      44  dspi_hal_write_data_master_mode
      16  s_baudratePrescaler
      64  s_baudrateScaler

 
 992 bytes in section .text
 
 992 bytes of CODE memory

Errors: none
Warnings: none
