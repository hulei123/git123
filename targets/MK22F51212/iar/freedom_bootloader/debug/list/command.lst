###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:15
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\command.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\command.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\command.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\command.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\command.c
      1          /*
      2           * Copyright (c) 2013-2014, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "bootloader/bootloader.h"
     33          #include "memory/memory.h"
     34          #include "sbloader/sbloader.h"
     35          #include "property/property.h"
     36          #include "utilities/fsl_assert.h"
     37          #include <string.h>
     38          #include <stdint.h>
     39          
     40          #if !defined(BOOTLOADER_HOST)
     41          #include "flash/flash.h"
     42          #include "device/fsl_device_registers.h"
     43          #if BL_HAS_QSPI_MODULE
     44          #include "qspi/qspi.h"
     45          #endif // #if BL_HAS_QSPI_MODULE
     46          #endif
     47          
     48          //! @addtogroup command
     49          //! @{
     50          
     51          //! @name State machine
     52          //@{
     53          static status_t handle_command(uint8_t * packet, uint32_t packetLength);
     54          static status_t handle_data(bool * hasMoreData);
     55          //@}
     56          
     57          //! @name Command handlers
     58          //@{
     59          void handle_reset(uint8_t * packet, uint32_t packetLength);
     60          void handle_flash_erase_all(uint8_t * packet, uint32_t packetLength);
     61          void handle_flash_erase_all_unsecure(uint8_t * packet, uint32_t packetLength);
     62          void handle_flash_erase_region(uint8_t * packet, uint32_t packetLength);
     63          void handle_receive_sb_file(uint8_t * packet, uint32_t packetLength);
     64          void handle_read_memory(uint8_t * packet, uint32_t packetLength);
     65          void handle_fill_memory(uint8_t * packet, uint32_t packetLength);
     66          void handle_set_property(uint8_t * packet, uint32_t packetLength);
     67          void handle_get_property(uint8_t * packet, uint32_t packetLength);
     68          void handle_write_memory(uint8_t * packet, uint32_t packetLength);
     69          void handle_execute(uint8_t * packet, uint32_t packetLength);
     70          void handle_call(uint8_t * packet, uint32_t packetLength);
     71          void handle_flash_security_disable(uint8_t * packet, uint32_t packetLength);
     72          void handle_flash_program_once(uint8_t * packet, uint32_t length);
     73          void handle_flash_read_once(uint8_t * packet, uint32_t length);
     74          void handle_flash_read_resource(uint8_t * packet, uint32_t length);
     75          void handle_configure_quadspi(uint8_t * packet, uint32_t packetLength);
     76          //@}
     77          
     78          //! @name Command responses
     79          //@{
     80          void send_read_memory_response(uint32_t commandStatus, uint32_t length);
     81          void send_generic_response(uint32_t commandStatus, uint32_t commandTag);
     82          void send_get_property_response(uint32_t commandStatus, uint32_t * value, uint32_t numValues);
     83          void send_flash_read_once_response(uint32_t commandStatus, uint32_t * value, uint32_t byteCount);
     84          void send_flash_read_resource_response(uint32_t commandStatus, uint32_t length);
     85          //@}
     86          
     87          //! @name Data phase
     88          //@{
     89          static void reset_data_phase(void);
     90          void finalize_data_phase(status_t status);
     91          status_t handle_data_producer(bool * hasMoreData);
     92          status_t handle_data_consumer(bool * hasMoreData);
     93          //@}
     94          
     95          ////////////////////////////////////////////////////////////////////////////////
     96          // Definitions
     97          ////////////////////////////////////////////////////////////////////////////////
     98          
     99          //#define TEST_SENDER_ABORT
    100          //#define TEST_RECEIVER_ABORT
    101          
    102          enum _secure_commands {
    103              //! @brief Bitmask of commands allowed when flash security is enabled.
    104              //!
    105              //! This bitmask uses the same format as the AvailableCommands property. This is,
    106              //! the bit number for a given command is the command's tag value minus one.
    107              kCommandsAllowedWhenSecure =    (
    108                                              HAS_CMD(kCommandTag_FlashSecurityDisable) |
    109                                              HAS_CMD(kCommandTag_GetProperty) |
    110                                              HAS_CMD(kCommandTag_Reset) |
    111                                              HAS_CMD(kCommandTag_SetProperty) |
    112                                              HAS_CMD(kCommandTag_FlashEraseAllUnsecure) |
    113                                              HAS_CMD(kCommandTag_ReceiveSbFile)
    114                                              )
    115          };
    116          
    117          ////////////////////////////////////////////////////////////////////////////////
    118          // Variables
    119          ////////////////////////////////////////////////////////////////////////////////
    120          
    121          //! @brief Command handler table.

   \                                 In section .rodata, align 4, keep-with-next
    122          const command_handler_entry_t g_commandHandlerTable[] = {
   \                     g_commandHandlerTable:
   \   00000000   0x........         DC32 handle_flash_erase_all, 0H, handle_flash_erase_region, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000010   0x........         DC32 handle_read_memory, handle_data_producer, handle_write_memory
   \              0x........   
   \              0x........   
   \   0000001C   0x........         DC32 handle_data_consumer, handle_fill_memory, 0H
   \              0x........   
   \              0x00000000   
   \   00000028   0x........         DC32 handle_flash_security_disable, 0H, handle_get_property, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000038   0x........         DC32 handle_receive_sb_file, handle_data_consumer, handle_execute, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \   00000048   0x........         DC32 handle_call, 0H, handle_reset, 0H, handle_set_property, 0H, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000068   0x........         DC32 handle_flash_program_once, 0H, handle_flash_read_once, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000078   0x........         DC32 handle_flash_read_resource, handle_data_producer, 0H
   \              0x........   
   \              0x00000000   
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    123              // cmd handler              // data handler or NULL
    124          #if !BL_MIN_PROFILE
    125              { handle_flash_erase_all,     NULL },                   // kCommandTag_FlashEraseAll = 0x01
    126              { handle_flash_erase_region,  NULL },                   // kCommandTag_FlashEraseRegion = 0x02
    127              { handle_read_memory,         handle_data_producer },   // kCommandTag_ReadMemory = 0x03
    128              { handle_write_memory,        handle_data_consumer },   // kCommandTag_WriteMemory = 0x04
    129              { handle_fill_memory,         NULL },                   // kCommandTag_FillMemory = 0x05
    130              { handle_flash_security_disable,  NULL },               // kCommandTag_FlashSecurityDisable = 0x06
    131              { handle_get_property,        NULL },                   // kCommandTag_GetProperty = 0x07
    132              { handle_receive_sb_file,     handle_data_consumer },   // kCommandTag_ReceiveSbFile = 0x08
    133              { handle_execute,             NULL },                   // kCommandTag_Execute = 0x09
    134              { handle_call,                NULL },                   // kCommandTag_Call = 0x0a
    135              { handle_reset,               NULL },                   // kCommandTag_Reset = 0x0b
    136              { handle_set_property,        NULL },                   // kCommandTag_SetProperty = 0x0c
    137          #if BL_HAS_MASS_ERASE
    138              { handle_flash_erase_all_unsecure, NULL },              // kCommandTag_FlashEraseAllUnsecure = 0x0d
    139          #else // BL_HAS_MASS_ERASE
    140              { 0 },                                                  // kCommandTag_FlashEraseAllUnsecure = 0x0d
    141          #endif // BL_HAS_MASS_ERASE
    142              { handle_flash_program_once,  NULL  },                  // kCommandTag_ProgramOnce = 0x0e
    143              { handle_flash_read_once,     NULL  },                  // kCommandTag_ReadOnce = 0x0f
    144              { handle_flash_read_resource, handle_data_producer  },  // kCommandTag_ReadResource = 0x10
    145          #if BL_HAS_QSPI_MODULE
    146              { handle_configure_quadspi,    NULL  },                 // kCommandTag_ConfigureQuadSpi = 0x11
    147          #else // BL_HAS_QSPI_MODULE
    148              { 0 },                                                  // kCommandTag_ConfigureQuadSpi = 0x11
    149          #endif // BL_HAS_QSPI_MODULE
    150          
    151          #else // BL_MIN_PROFILE
    152              { handle_flash_erase_all,     NULL },                   // kCommandTag_FlashEraseAll = 0x01
    153              { handle_flash_erase_region,  NULL },                   // kCommandTag_FlashEraseRegion = 0x02
    154          #if BL_FEATURE_READ_MEMORY
    155              { handle_read_memory,         handle_data_producer },   // kCommandTag_ReadMemory = 0x03
    156          #else // BL_FEATURE_READ_MEMORY
    157              { 0 },                                                  // kCommandTag_ReadMemory = 0x03
    158          #endif
    159              { handle_write_memory,        handle_data_consumer },   // kCommandTag_WriteMemory = 0x04
    160          #if BL_FEATURE_FILL_MEMORY    
    161              { handle_fill_memory,         NULL },                   // kCommandTag_FillMemory = 0x05
    162          #else
    163              { 0 },
    164          #endif //BL_FEATURE_FILL_MEMORY    
    165              { handle_flash_security_disable,  NULL },               // kCommandTag_FlashSecurityDisable = 0x06
    166              { handle_get_property,        NULL },                   // kCommandTag_GetProperty = 0x07
    167              { 0 },                                                  // kCommandTag_ReceiveSbFile = 0x08
    168              { handle_execute,             NULL },                   // kCommandTag_Execute = 0x09
    169              { 0 },                                                  // kCommandTag_Call = 0x0a
    170              { handle_reset,               NULL },                   // kCommandTag_Reset = 0x0b
    171              { handle_set_property,        NULL },                   // kCommandTag_SetProperty = 0x0c
    172          #if BL_HAS_MASS_ERASE
    173              { handle_flash_erase_all_unsecure, NULL },              // kCommandTag_FlashEraseAllUnsecure = 0x0d
    174          #else // BL_HAS_MASS_ERASE
    175              { 0 },                                                  // kCommandTag_FlashEraseAllUnsecure = 0x0d
    176          #endif // BL_HAS_MASS_ERASE
    177              { 0 },                                                  // kCommandTag_ProgramOnce = 0x0e
    178              { 0 },                                                  // kCommandTag_ReadOnce = 0x0f
    179              { 0 },                                                  // kCommandTag_ReadResource = 0x10
    180              { 0 },                                                  // kCommandTag_ConfigureQuadSpi = 0x11
    181          #endif // BL_MIN_PROFILE
    182          };
    183          
    184          //! @brief Command processor state data.

   \                                 In section .bss, align 4
    185          command_processor_data_t g_commandData;
   \                     g_commandData:
   \   00000000                      DS8 36
    186          
    187          // See command.h for documentation on this interface.

   \                                 In section .data, align 4
    188          command_interface_t g_commandInterface = {
   \                     g_commandInterface:
   \   00000000   0x........         DC32 bootloader_command_init, bootloader_command_pump
   \              0x........   
   \   00000008   0x........         DC32 g_commandHandlerTable, g_commandData
   \              0x........   
    189              bootloader_command_init,
    190              bootloader_command_pump,
    191              (command_handler_entry_t *)&g_commandHandlerTable,
    192              &g_commandData
    193          };
    194          
    195          ////////////////////////////////////////////////////////////////////////////////
    196          // Code
    197          ////////////////////////////////////////////////////////////////////////////////
    198          
    199          // See command.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    200          status_t bootloader_command_init()
    201          {
    202              command_processor_data_t * data = g_bootloaderContext.commandInterface->stateData;
    203          
    204              data->state = kCommandState_CommandPhase;
   \                     bootloader_command_init: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000004   0x68C9             LDR      R1,[R1, #+12]
   \   00000006   0x68C9             LDR      R1,[R1, #+12]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    205              return kStatus_Success;
   \   0000000C   0x4770             BX       LR               ;; return
    206          }
    207          
    208          // See command.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    209          status_t bootloader_command_pump()
    210          {
   \                     bootloader_command_pump: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    211              status_t status = kStatus_Success;
    212              bool hasMoreData = false;
    213          
    214              if (g_bootloaderContext.activePeripheral->packetInterface)
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable20
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x69E8             LDR      R0,[R5, #+28]
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xF88D 0x4001      STRB     R4,[SP, #+1]
   \   00000012   0x6946             LDR      R6,[R0, #+20]
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD061             BEQ.N    ??bootloader_command_pump_0
   \   00000018   0x68E9             LDR      R1,[R5, #+12]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x2A01             CMP      R2,#+1
   \   00000020   0xD04B             BEQ.N    ??bootloader_command_pump_1
    215              {
    216                  switch (g_bootloaderContext.commandInterface->stateData->state)
    217                  {
    218                      default:
    219                      case kCommandState_CommandPhase:
    220                          status = g_bootloaderContext.activePeripheral->packetInterface->readPacket(
    221                                  g_bootloaderContext.activePeripheral,
    222                                  &g_bootloaderContext.commandInterface->stateData->packet,
    223                                  &g_bootloaderContext.commandInterface->stateData->packetLength, kPacketType_Command);
   \   00000022   0xF101 0x0208      ADD      R2,R1,#+8
   \   00000026   0x6874             LDR      R4,[R6, #+4]
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x1D09             ADDS     R1,R1,#+4
   \   0000002C   0x47A0             BLX      R4
   \   0000002E   0x0004             MOVS     R4,R0
    224                          if ((status != kStatus_Success) &&
    225                                  (status != kStatus_AbortDataPhase) &&
    226                                  (status != kStatus_Ping))
   \   00000030   0xBF1F             ITTTT    NE 
   \   00000032   0xF242 0x7012      MOVWNE   R0,#+10002
   \   00000036   0x4284             CMPNE    R4,R0
   \   00000038   0xF242 0x7013      MOVWNE   R0,#+10003
   \   0000003C   0x4284             CMPNE    R4,R0
   \   0000003E   0xD14D             BNE.N    ??bootloader_command_pump_0
    227                          {
    228                              debug_printf("Error: readPacket returned status 0x%x\r\n", status);
    229                              break;
    230                          }
    231                          if (g_bootloaderContext.commandInterface->stateData->packetLength == 0)
   \   00000040   0x68E8             LDR      R0,[R5, #+12]
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0xF8D1 0x8008      LDR      R8,[R1, #+8]
   \   00000048   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004C   0xD046             BEQ.N    ??bootloader_command_pump_0
    232                          {
    233                              // No command packet is available. Return success.
    234                              break;
    235                          }
    236                          status = handle_command(g_bootloaderContext.commandInterface->stateData->packet,
    237                                  g_bootloaderContext.commandInterface->stateData->packetLength);
   \   0000004E   0x684E             LDR      R6,[R1, #+4]
   \   00000050   0x7837             LDRB     R7,[R6, #+0]
   \   00000052   0xB137             CBZ.N    R7,??bootloader_command_pump_2
   \   00000054   0x2F12             CMP      R7,#+18
   \   00000056   0xDA04             BGE.N    ??bootloader_command_pump_2
   \   00000058   0x6880             LDR      R0,[R0, #+8]
   \   0000005A   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \   0000005E   0x3808             SUBS     R0,R0,#+8
   \   00000060   0xE000             B.N      ??bootloader_command_pump_3
   \                     ??bootloader_command_pump_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??bootloader_command_pump_3: (+1)
   \   00000064   0x6208             STR      R0,[R1, #+32]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xBF1C             ITT      NE 
   \   0000006A   0x6800             LDRNE    R0,[R0, #+0]
   \   0000006C   0x2800             CMPNE    R0,#+0
   \   0000006E   0xD01B             BEQ.N    ??bootloader_command_pump_4
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000076   0x.... 0x....      BL       flash_get_security_state
   \   0000007A   0x0004             MOVS     R4,R0
   \   0000007C   0xD116             BNE.N    ??bootloader_command_pump_5
   \   0000007E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000082   0xB140             CBZ.N    R0,??bootloader_command_pump_6
   \   00000084   0xF44F 0x50E7      MOV      R0,#+7392
   \   00000088   0x1E79             SUBS     R1,R7,#+1
   \   0000008A   0x40C8             LSRS     R0,R0,R1
   \   0000008C   0x07C0             LSLS     R0,R0,#+31
   \   0000008E   0xBF58             IT       PL 
   \   00000090   0xF242 0x7411      MOVWPL   R4,#+10001
   \   00000094   0xD50A             BPL.N    ??bootloader_command_pump_5
   \                     ??bootloader_command_pump_6: (+1)
   \   00000096   0x68EA             LDR      R2,[R5, #+12]
   \   00000098   0x68D2             LDR      R2,[R2, #+12]
   \   0000009A   0x6A12             LDR      R2,[R2, #+32]
   \   0000009C   0x6812             LDR      R2,[R2, #+0]
   \   0000009E   0x4641             MOV      R1,R8
   \   000000A0   0x4630             MOV      R0,R6
   \   000000A2   0x4790             BLX      R2
   \   000000A4   0x2400             MOVS     R4,#+0
   \   000000A6   0xE006             B.N      ??bootloader_command_pump_7
   \                     ??bootloader_command_pump_4: (+1)
   \   000000A8   0xF242 0x7410      MOVW     R4,#+10000
   \                     ??bootloader_command_pump_5: (+1)
   \   000000AC   0x4639             MOV      R1,R7
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       send_generic_response
    238                          if (status != kStatus_Success)
   \   000000B4   0xB994             CBNZ.N   R4,??bootloader_command_pump_0
    239                          {
    240                              debug_printf("Error: handle_command returned status 0x%x\r\n", status);
    241                              break;
    242                          }
    243                          g_bootloaderContext.commandInterface->stateData->state = kCommandState_DataPhase;
   \                     ??bootloader_command_pump_7: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xE00D             B.N      ??bootloader_command_pump_8
    244                          break;
    245          
    246                      case kCommandState_DataPhase:
    247                          status = handle_data(&hasMoreData);
   \                     ??bootloader_command_pump_1: (+1)
   \   000000BA   0x6A08             LDR      R0,[R1, #+32]
   \   000000BC   0xB148             CBZ.N    R0,??bootloader_command_pump_9
   \   000000BE   0x6841             LDR      R1,[R0, #+4]
   \   000000C0   0x0008             MOVS     R0,R1
   \   000000C2   0xD003             BEQ.N    ??bootloader_command_pump_10
   \   000000C4   0xF10D 0x0001      ADD      R0,SP,#+1
   \   000000C8   0x4788             BLX      R1
   \   000000CA   0x4604             MOV      R4,R0
    248                          if (status != kStatus_Success)
   \                     ??bootloader_command_pump_10: (+1)
   \   000000CC   0xB10C             CBZ.N    R4,??bootloader_command_pump_9
    249                          {
    250                              debug_printf("Error: handle_data returned status 0x%x\r\n", status);
    251                              g_bootloaderContext.commandInterface->stateData->state = kCommandState_CommandPhase;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xE001             B.N      ??bootloader_command_pump_8
    252                              break;
    253                          }
    254                          g_bootloaderContext.commandInterface->stateData->state = hasMoreData ? kCommandState_DataPhase : kCommandState_CommandPhase;
   \                     ??bootloader_command_pump_9: (+1)
   \   000000D2   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \                     ??bootloader_command_pump_8: (+1)
   \   000000D6   0x68E9             LDR      R1,[R5, #+12]
   \   000000D8   0x68C9             LDR      R1,[R1, #+12]
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    255                          break;
    256                  }
    257              }
    258          
    259              return status;
   \                     ??bootloader_command_pump_0: (+1)
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    260          }
    261          
    262          //! @brief Find command handler entry.
    263          //!
    264          //! @retval NULL if no entry found.
    265          static const command_handler_entry_t * find_entry(uint8_t tag)
    266          {
    267              if (tag < kFirstCommandTag || tag > kLastCommandTag)
    268              {
    269                  return 0;   // invalid command
    270              }
    271              const command_handler_entry_t * entry = &g_bootloaderContext.commandInterface->handlerTable[(tag - kFirstCommandTag)];
    272          
    273              return entry;
    274          }
    275          
    276          //! @brief Handle a command transaction.
    277          static status_t handle_command(uint8_t * packet, uint32_t packetLength)
    278          {
    279              command_packet_t * commandPacket = (command_packet_t *)packet;
    280              uint8_t commandTag = commandPacket->commandTag;
    281              status_t status = kStatus_Success;
    282          
    283              // Look up the handler entry and save it for the data phaase.
    284              g_bootloaderContext.commandInterface->stateData->handlerEntry = find_entry(commandTag);
    285          
    286              if (g_bootloaderContext.commandInterface->stateData->handlerEntry &&
    287                  g_bootloaderContext.commandInterface->stateData->handlerEntry->handleCommand)
    288              {
    289          #if !BOOTLOADER_HOST
    290                  // Get flash security state.
    291                  flash_security_state_t securityState;
    292                  status = flash_get_security_state(&g_bootloaderContext.flashState, &securityState);
    293          
    294                  if (status == kStatus_Success)
    295                  {
    296                      // If flash security is enabled, make sure the command is one that is allowed. If
    297                      // it's not, then we return an error response.
    298                      if ((securityState != kFlashNotSecure) && !IS_CMD_AVAILABLE(kCommandsAllowedWhenSecure, commandTag))
    299                      {
    300                          // Security is enabled and the command is not one of the few that can be
    301                          // run, so return a security violation error.
    302                          debug_printf("Error: command 0x%x not available due to flash security\r\n", commandPacket->commandTag);
    303                          status = kStatus_SecurityViolation;
    304                      }
    305                      else
    306                      {
    307          #endif // BOOTLOADER_HOST
    308                          // Process the command normally.
    309                          g_bootloaderContext.commandInterface->stateData->handlerEntry->handleCommand(packet, packetLength);
    310                          return kStatus_Success;
    311          #if !BOOTLOADER_HOST
    312                      }
    313                  }
    314          #endif // BOOTLOADER_HOST
    315              }
    316              else
    317              {
    318                  // We don't recognize this command, so return an error response.
    319                  debug_printf("unknown command 0x%x\r\n", commandPacket->commandTag);
    320                  status = kStatus_UnknownCommand;
    321              }
    322          
    323              // Should only get to this point if an error occurred before running the command handler.
    324              send_generic_response(status, commandTag);
    325              return status;
    326          }
    327          
    328          //! @brief Handle a data transaction.
    329          static status_t handle_data(bool * hasMoreData)
    330          {
    331              if (g_bootloaderContext.commandInterface->stateData->handlerEntry)
    332              {
    333                  // Run data phase if present, otherwise just return success.
    334                  *hasMoreData = 0;
    335                  return g_bootloaderContext.commandInterface->stateData->handlerEntry->handleData ?
    336                      g_bootloaderContext.commandInterface->stateData->handlerEntry->handleData(hasMoreData)
    337                      : kStatus_Success;
    338              }
    339          
    340              debug_printf("Error: no handler entry for data phase\r\n");
    341              return kStatus_Success;
    342          }
    343          
    344          ////////////////////////////////////////////////////////////////////////////////
    345          // Command Handlers
    346          ////////////////////////////////////////////////////////////////////////////////
    347          
    348          //! @brief Reset command handler.

   \                                 In section .text, align 2, keep-with-next
    349          void handle_reset(uint8_t * packet, uint32_t packetLength)
    350          {
   \                     handle_reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    351              command_packet_t * commandPacket = (command_packet_t *)packet;
    352              send_generic_response(kStatus_Success, commandPacket->commandTag);
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       send_generic_response
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000000E   0x69C0             LDR      R0,[R0, #+28]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x6909             LDR      R1,[R1, #+16]
    353          
    354          #if !defined(BOOTLOADER_HOST)
    355              // Wait for the ack from the host to the generic response
    356              g_bootloaderContext.activePeripheral->packetInterface->finalize(g_bootloaderContext.activePeripheral);
   \   00000014   0x4788             BLX      R1
    357          
    358              // Prepare for shutdown.
    359              shutdown_cleanup(kShutdownType_Reset);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       shutdown_cleanup
    360          
    361              NVIC_SystemReset();
   \   0000001C   0xF3BF 0x8F4F      DSB      
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_1  ;; 0xe000ed0c
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable20_2  ;; 0x5fa0004
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000002E   0x4311             ORRS     R1,R2,R1
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0xF3BF 0x8F4F      DSB      
   \                     ??handle_reset_0: (+1)
   \   00000036   0xE7FE             B.N      ??handle_reset_0
    362              // Does not get here.
    363              assert(0);
    364          #endif // BOOTLOADER_HOST
    365          }
    366          
    367          //! @brief Reset data phase variables.

   \                                 In section .text, align 2, keep-with-next
    368          static void reset_data_phase()
    369          {
    370              memset(&g_bootloaderContext.commandInterface->stateData->dataPhase, 0,
    371                     sizeof(g_bootloaderContext.commandInterface->stateData->dataPhase));
   \                     reset_data_phase: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x300C             ADDS     R0,R0,#+12
   \   0000000C   0x.... 0x....      B.W      __aeabi_memclr4
    372          }
    373          
    374          //! @brief Flash Erase All command handler.

   \                                 In section .text, align 2, keep-with-next
    375          void handle_flash_erase_all(uint8_t * packet, uint32_t packetLength)
    376          {
   \                     handle_flash_erase_all: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    377              flash_erase_all_packet_t * commandPacket = (flash_erase_all_packet_t *)packet;
    378              status_t status = kStatus_Success;
    379          
    380              // Call flash erase all implementation.
    381          #ifdef BOOTLOADER_HOST
    382                  host_flash_erase_all();
    383          #else
    384              // For target without QSPI module, ignore the memory identifier
    385          #if (!BL_HAS_QSPI_MODULE)
    386                  status = flash_mem_erase_all();
   \   00000004   0x.... 0x....      BL       flash_mem_erase_all
    387          #else
    388              switch(commandPacket->memoryId)
    389              {
    390              case kFlashMemInternal:
    391                  status = flash_mem_erase_all();
    392                  break;
    393              case kFlashMemQuadSpi0:
    394                  status = qspi_mem_erase_all();
    395                  break;
    396              default:
    397                  status = kStatus_InvalidArgument;
    398                  break;
    399              }
    400          #endif // #if (!BL_HAS_QSPI_MODULE)
    401          #endif // #ifdef BOOTLOADER_HOST
    402          
    403              send_generic_response(status, commandPacket->commandPacket.commandTag);
   \   00000008   0x....             B.N      ?Subroutine0
    404          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x7821             LDRB     R1,[R4, #+0]
   \   00000002   0xE8BD 0x4010      POP      {R4,LR}
   \   00000006   0x....             B.N      send_generic_response
    405          
    406          //! @brief Flash Erase All Unsecure command handler.

   \                                 In section .text, align 2, keep-with-next
    407          void handle_flash_erase_all_unsecure(uint8_t * packet, uint32_t packetLength)
    408          {
   \                     handle_flash_erase_all_unsecure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    409              command_packet_t * commandPacket = (command_packet_t *)packet;
    410              status_t status = kStatus_Success;
    411          
    412              // Call flash erase all unsecure implementation.
    413          #ifdef BOOTLOADER_HOST
    414              host_flash_erase_all_unsecure();
    415          #else
    416              status = flash_mem_erase_all_unsecure();
   \   00000004   0x.... 0x....      BL       flash_mem_erase_all_unsecure
    417          #endif
    418          
    419              send_generic_response(status, commandPacket->commandTag);
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    420          }
    421          
    422          //! @brief Flash Erase Region command handler.

   \                                 In section .text, align 2, keep-with-next
    423          void handle_flash_erase_region(uint8_t * packet, uint32_t packetLength)
    424          {
   \                     handle_flash_erase_region: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    425              flash_erase_region_packet_t * command = (flash_erase_region_packet_t *)packet;
    426              status_t status = kStatus_Success;
    427          
    428              // Call flash erase region implementation.
    429          #ifdef BOOTLOADER_HOST
    430              host_flash_erase_region(command->startAddress, command->byteCount);
    431          #else
    432              status = g_bootloaderContext.memoryInterface->erase(command->startAddress, command->byteCount);
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable20
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x6952             LDR      R2,[R2, #+20]
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x68A1             LDR      R1,[R4, #+8]
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x4790             BLX      R2
    433          #endif
    434          
    435              send_generic_response(status, command->commandPacket.commandTag);
   \   00000012   0x....             B.N      ?Subroutine0
    436          }
    437          
    438          //! @brief Receive SB File command handler.

   \                                 In section .text, align 2, keep-with-next
    439          void handle_receive_sb_file(uint8_t * packet, uint32_t packetLength)
    440          {
   \                     handle_receive_sb_file: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    441              receive_sb_file_packet_t * command = (receive_sb_file_packet_t *)packet;
    442          
    443              // Start the data phase.
    444              reset_data_phase();
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000000A   0x68C0             LDR      R0,[R0, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x6861             LDR      R1,[R4, #+4]
   \   00000010   0x6101             STR      R1,[R0, #+16]
    445              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
    446              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_ReceiveSbFile;
   \   00000012   0x2108             MOVS     R1,#+8
   \   00000014   0x7701             STRB     R1,[R0, #+28]
    447              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7821             LDRB     R1,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       send_generic_response
    448          
    449              // Initialize the SB file loader state machine
    450              sbloader_init();
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      sbloader_init
    451          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x....             B.N      reset_data_phase
    452          
    453          //! @brief Get Property command handler.

   \                                 In section .text, align 2, keep-with-next
    454          void handle_get_property(uint8_t * packet, uint32_t packetLength)
    455          {
   \                     handle_get_property: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    456              get_property_packet_t * command = (get_property_packet_t *)packet;
    457          
    458              uint32_t * value = NULL;
    459              uint32_t valueSize = 0;
    460              status_t status = g_bootloaderContext.propertyInterface->get(command->propertyTag, 
    461                                                                           command->memoryId, (const void **)&value, &valueSize);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable20
   \   00000008   0x68A5             LDR      R5,[R4, #+8]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x9101             STR      R1,[SP, #+4]
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0x466B             MOV      R3,SP
   \   00000012   0x6881             LDR      R1,[R0, #+8]
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x68AD             LDR      R5,[R5, #+8]
   \   00000018   0xAA01             ADD      R2,SP,#+4
   \   0000001A   0xB2C9             UXTB     R1,R1
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x47A8             BLX      R5
    462          
    463              // Make sure the property's size is no more than the size of the max number of return parameters.
    464              assert(valueSize <= (kMaxPropertyReturnValues * sizeof(uint32_t)));
    465          
    466              // Currently there are no property responses that contain a data phase.
    467              g_bootloaderContext.commandInterface->stateData->dataPhase.count = 0;
   \   00000020   0x68E2             LDR      R2,[R4, #+12]
   \   00000022   0x68D2             LDR      R2,[R2, #+12]
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6111             STR      R1,[R2, #+16]
    468              send_get_property_response(status, value, (valueSize / sizeof(uint32_t)));
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x088A             LSRS     R2,R1,#+2
   \   0000002C   0x9901             LDR      R1,[SP, #+4]
   \   0000002E   0x.... 0x....      BL       send_get_property_response
    469          }
   \   00000032   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    470          
    471          //! @brief Set Property command handler.

   \                                 In section .text, align 2, keep-with-next
    472          void handle_set_property(uint8_t * packet, uint32_t packetLength)
    473          {
   \                     handle_set_property: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    474              set_property_packet_t * command = (set_property_packet_t *)packet;
    475          
    476              status_t status = g_bootloaderContext.propertyInterface->set_uint32(command->propertyTag, command->propertyValue);
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable20
   \   00000006   0x6892             LDR      R2,[R2, #+8]
   \   00000008   0x68D2             LDR      R2,[R2, #+12]
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x68A1             LDR      R1,[R4, #+8]
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x4790             BLX      R2
    477          
    478              send_generic_response(status, command->commandPacket.commandTag);
   \   00000014   0x....             B.N      ?Subroutine0
    479          }
    480          
    481          #if BL_HAS_QSPI_MODULE
    482          //! @brief Configure QuadSpi command handler.
    483          void handle_configure_quadspi(uint8_t * packet, uint32_t packetLength)
    484          {
    485              configure_quadspi_packet_t * command = (configure_quadspi_packet_t *)packet;
    486              status_t status = kStatus_Success;
    487          
    488              uint32_t startAddr = command->configBlockAddress;
    489              uint32_t endAddr = startAddr + sizeof(qspi_config_t) - 1;
    490          
    491              // Validate parameters.
    492              if ((command->flashMemId != kFlashMemQuadSpi0) ||
    493                  (!is_valid_application_location(startAddr)) ||
    494                  (!is_valid_application_location(endAddr)))
    495              {
    496                  status = kStatus_InvalidArgument;
    497              }
    498          
    499              // Call configure quadspi implementation.
    500              if (status == kStatus_Success)
    501              {
    502          #ifdef BOOTLOADER_HOST
    503          #else
    504                  status = qspi_otfad_init((void *)startAddr);
    505                  if (status == kStatus_Success)
    506                  {
    507                      // Re-init memory interface to intialize qspi memory interface
    508                      g_bootloaderContext.memoryInterface->init();
    509                  }
    510                  g_bootloaderContext.propertyInterface->store->qspiInitStatus = status;
    511          #endif
    512              }
    513          
    514              send_generic_response(status, command->commandPacket.commandTag);
    515          }
    516          #endif // BL_HAS_QSPI_MODULE
    517          
    518          //! @brief Write Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    519          void handle_write_memory(uint8_t * packet, uint32_t packetLength)
    520          {
   \                     handle_write_memory: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    521              write_memory_packet_t * command = (write_memory_packet_t *)packet;
    522          
    523              // Start the data phase.
    524              reset_data_phase();
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine6
    525              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
    526              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
    527              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_WriteMemory;
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x7701             STRB     R1,[R0, #+28]
    528              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             B.N      ?Subroutine0
    529          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x68A1             LDR      R1,[R4, #+8]
   \   0000000A   0x6101             STR      R1,[R0, #+16]
   \   0000000C   0x6861             LDR      R1,[R4, #+4]
   \   0000000E   0x6141             STR      R1,[R0, #+20]
   \   00000010   0x4770             BX       LR
    530          
    531          //! @brief Read Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    532          void handle_read_memory(uint8_t * packet, uint32_t packetLength)
    533          {
   \                     handle_read_memory: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    534              read_memory_packet_t * command = (read_memory_packet_t *)packet;
    535          
    536              // Start the data phase.
    537              reset_data_phase();
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine6
    538              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
    539              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
    540              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_ReadMemory;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x7701             STRB     R1,[R0, #+28]
    541              send_read_memory_response(kStatus_Success, command->byteCount);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x68A1             LDR      R1,[R4, #+8]
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x....             B.N      send_read_memory_response
    542          }
    543          
    544          //! @brief Complete the data phase, optionally send a response.

   \                                 In section .text, align 2, keep-with-next
    545          void finalize_data_phase(status_t status)
    546          {
   \                     finalize_data_phase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    547              g_bootloaderContext.commandInterface->stateData->dataPhase.address = 0;
   \   00000002   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6141             STR      R1,[R0, #+20]
    548              g_bootloaderContext.commandInterface->stateData->dataPhase.count = 0;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    549          
    550              // Force to write cached data to target memory
    551              if (g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_WriteMemory)
   \   0000000C   0x7F00             LDRB     R0,[R0, #+28]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD104             BNE.N    ??finalize_data_phase_0
    552              {
    553                  assert(g_bootloaderContext.memoryInterface->flush);
    554                  status_t flushStatus = g_bootloaderContext.memoryInterface->flush();
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6900             LDR      R0,[R0, #+16]
   \   00000016   0x4780             BLX      R0
    555          
    556                  // Update status only if the last operation result is successfull in order to reflect
    557                  // real result of the write operation.
    558                  if (status == kStatus_Success)
   \   00000018   0xB904             CBNZ.N   R4,??finalize_data_phase_0
    559                  {
    560                      status = flushStatus;
   \   0000001A   0x4604             MOV      R4,R0
    561                  }
    562              }
    563          
    564              // Send final response packet.
    565              send_generic_response(status, g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag);
   \                     ??finalize_data_phase_0: (+1)
   \   0000001C   0x68E8             LDR      R0,[R5, #+12]
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x7F01             LDRB     R1,[R0, #+28]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       send_generic_response
    566          
    567          #if !BL_MIN_PROFILE
    568              if ((status == kStatus_AbortDataPhase) &&
    569                  g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_ReceiveSbFile)
   \   00000028   0xF242 0x7012      MOVW     R0,#+10002
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD108             BNE.N    ??finalize_data_phase_1
   \   00000030   0x68E8             LDR      R0,[R5, #+12]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x7F00             LDRB     R0,[R0, #+28]
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xBF04             ITT      EQ 
    570              {
    571                  // Aborting due to sb loader jump command.
    572                  // If jump successful, this will not return.
    573                  sbloader_finalize_jump();
   \   0000003A   0xE8BD 0x4031      POPEQ    {R0,R4,R5,LR}
   \   0000003E   0x.... 0x....      BEQ.W    sbloader_finalize_jump
    574              }
    575          #endif // !BL_MIN_PROFILE
    576          
    577          }
   \                     ??finalize_data_phase_1: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R5,??DataTable20
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x68E8             LDR      R0,[R5, #+12]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x4770             BX       LR
    578          
    579          //! @brief Handle data phase with data consumer (read from host).

   \                                 In section .text, align 2, keep-with-next
    580          status_t handle_data_consumer(bool * hasMoreData)
    581          {
   \                     handle_data_consumer: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    582              if (g_bootloaderContext.commandInterface->stateData->dataPhase.count == 0)
   \   00000004   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000008   0x6901             LDR      R1,[R0, #+16]
   \   0000000A   0xB921             CBNZ.N   R1,??handle_data_consumer_0
    583              {
    584                  // No data phase.
    585                  *hasMoreData = false;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    586                  finalize_data_phase(kStatus_Success);
   \   00000010   0x.... 0x....      BL       finalize_data_phase
    587                  return kStatus_Success;
   \   00000014   0xE05A             B.N      ??handle_data_consumer_1
    588              }
    589          
    590              *hasMoreData = true;
   \                     ??handle_data_consumer_0: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x7021             STRB     R1,[R4, #+0]
    591              uint32_t remaining = g_bootloaderContext.commandInterface->stateData->dataPhase.count;
   \   0000001A   0x6906             LDR      R6,[R0, #+16]
    592              uint32_t dataAddress = g_bootloaderContext.commandInterface->stateData->dataPhase.address;
   \   0000001C   0x6947             LDR      R7,[R0, #+20]
    593              uint8_t * packet;
    594              uint32_t packetLength = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x9000             STR      R0,[SP, #+0]
    595              status_t status;
    596          
    597              // Read the data packet.
    598              status = g_bootloaderContext.activePeripheral->packetInterface->readPacket(
    599                  g_bootloaderContext.activePeripheral, &packet, &packetLength, kPacketType_Data);
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x69E8             LDR      R0,[R5, #+28]
   \   00000026   0xF8D0 0xC014      LDR      R12,[R0, #+20]
   \   0000002A   0xF8DC 0xC004      LDR      R12,[R12, #+4]
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0x47E0             BLX      R12
   \   00000034   0xEA5F 0x0800      MOVS     R8,R0
    600              if (status != kStatus_Success)
   \   00000038   0xD005             BEQ.N    ??handle_data_consumer_2
    601              {
    602                  // Abort data phase due to error.
    603                  debug_printf("consumer abort data phase due to status 0x%x\r\n", status);
    604                  g_bootloaderContext.activePeripheral->packetInterface->abortDataPhase(
    605                      g_bootloaderContext.activePeripheral);
   \   0000003A   0x69E8             LDR      R0,[R5, #+28]
   \   0000003C   0x6941             LDR      R1,[R0, #+20]
   \   0000003E   0x68C9             LDR      R1,[R1, #+12]
   \   00000040   0x4788             BLX      R1
    606                  finalize_data_phase(status);
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0xE003             B.N      ??handle_data_consumer_3
    607                  *hasMoreData = false;
    608                  return kStatus_Success;
    609              }
    610              if (packetLength == 0)
   \                     ??handle_data_consumer_2: (+1)
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0xB930             CBNZ.N   R0,??handle_data_consumer_4
    611              {
    612                  // Sender requested data phase abort.
    613                  debug_printf("Data phase aborted by sender\r\n");
    614                  finalize_data_phase(kStatus_AbortDataPhase);
   \   0000004A   0xF242 0x7012      MOVW     R0,#+10002
   \                     ??handle_data_consumer_3: (+1)
   \   0000004E   0x.... 0x....      BL       finalize_data_phase
    615                  *hasMoreData = false;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    616                  return kStatus_Success;
   \   00000056   0xE03A             B.N      ??handle_data_consumer_5
    617              }
    618          
    619              //
    620              // Write the data to the destination address.
    621              //
    622          
    623              packetLength = MIN(packetLength, remaining);
   \                     ??handle_data_consumer_4: (+1)
   \   00000058   0x42B0             CMP      R0,R6
   \   0000005A   0xBF88             IT       HI 
   \   0000005C   0x4630             MOVHI    R0,R6
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x68E8             LDR      R0,[R5, #+12]
   \   00000062   0x68C0             LDR      R0,[R0, #+12]
   \   00000064   0x7F01             LDRB     R1,[R0, #+28]
   \   00000066   0x2908             CMP      R1,#+8
   \   00000068   0xD113             BNE.N    ??handle_data_consumer_6
    624          
    625          #if !BL_MIN_PROFILE
    626              if (g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_ReceiveSbFile)
    627              {
    628                  // Consumer is sb loader state machine
    629                  g_bootloaderContext.commandInterface->stateData->dataPhase.data = packet;
   \   0000006A   0x9901             LDR      R1,[SP, #+4]
   \   0000006C   0x60C1             STR      R1,[R0, #+12]
    630                  g_bootloaderContext.commandInterface->stateData->dataPhase.dataBytesAvailable = packetLength;
   \   0000006E   0x9900             LDR      R1,[SP, #+0]
   \   00000070   0x6181             STR      R1,[R0, #+24]
    631          
    632                  status = sbloader_pump(packet, packetLength);
   \   00000072   0x9801             LDR      R0,[SP, #+4]
   \   00000074   0x9900             LDR      R1,[SP, #+0]
   \   00000076   0x.... 0x....      BL       sbloader_pump
   \   0000007A   0x4680             MOV      R8,R0
    633          
    634                  // kStatusRomLdrDataUnderrun means need more data
    635                  // kStatusRomLdrSectionOverrun means we reached the end of the sb file processing
    636                  // either of these are OK
    637                  if ((status == kStatusRomLdrDataUnderrun) ||
    638                      (status == kStatusRomLdrSectionOverrun))
   \   0000007C   0xF242 0x707D      MOVW     R0,#+10109
   \   00000080   0x4580             CMP      R8,R0
   \   00000082   0xBF1C             ITT      NE 
   \   00000084   0xF242 0x7074      MOVWNE   R0,#+10100
   \   00000088   0x4580             CMPNE    R8,R0
   \   0000008A   0xD10B             BNE.N    ??handle_data_consumer_7
    639                  {
    640                      status = kStatus_Success;
   \   0000008C   0xF04F 0x0800      MOV      R8,#+0
   \   00000090   0xE008             B.N      ??handle_data_consumer_7
    641                  }
    642              }
    643              else
    644          #endif // !BL_MIN_PROFILE
    645              {
    646                  // Consumer is memory interface.
    647                  status = g_bootloaderContext.memoryInterface->write(dataAddress, packetLength, packet);
   \                     ??handle_data_consumer_6: (+1)
   \   00000092   0x682B             LDR      R3,[R5, #+0]
   \   00000094   0x9A01             LDR      R2,[SP, #+4]
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x689B             LDR      R3,[R3, #+8]
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x4798             BLX      R3
   \   0000009E   0x4680             MOV      R8,R0
    648                  dataAddress += packetLength;
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x19C7             ADDS     R7,R0,R7
    649              }
    650          
    651              remaining -= packetLength;
   \                     ??handle_data_consumer_7: (+1)
   \   000000A4   0x9800             LDR      R0,[SP, #+0]
   \   000000A6   0x1A36             SUBS     R6,R6,R0
    652          
    653          #ifdef TEST_RECEIVER_ABORT
    654              status = kStatus_Fail;
    655          #endif
    656          
    657              if (remaining == 0)
   \   000000A8   0xD006             BEQ.N    ??handle_data_consumer_8
    658              {
    659                  finalize_data_phase(status);
    660                  *hasMoreData = false;
    661              }
    662              else if (status != kStatus_Success)
   \   000000AA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AE   0xD009             BEQ.N    ??handle_data_consumer_9
    663              {
    664                  // Abort data phase due to error.
    665                  debug_printf("Data phase error 0x%x, aborting\r\n", status);
    666                  g_bootloaderContext.activePeripheral->packetInterface->abortDataPhase(
    667                      g_bootloaderContext.activePeripheral);
   \   000000B0   0x69E8             LDR      R0,[R5, #+28]
   \   000000B2   0x6941             LDR      R1,[R0, #+20]
   \   000000B4   0x68C9             LDR      R1,[R1, #+12]
   \   000000B6   0x4788             BLX      R1
    668                  finalize_data_phase(status);
   \                     ??handle_data_consumer_8: (+1)
   \   000000B8   0x4640             MOV      R0,R8
   \   000000BA   0x.... 0x....      BL       finalize_data_phase
    669                  *hasMoreData = false;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x7020             STRB     R0,[R4, #+0]
   \   000000C2   0xE003             B.N      ??handle_data_consumer_1
    670              }
   \                     ??handle_data_consumer_9: (+1)
   \   000000C4   0x68E8             LDR      R0,[R5, #+12]
   \   000000C6   0x68C0             LDR      R0,[R0, #+12]
   \   000000C8   0x6106             STR      R6,[R0, #+16]
    671              else
    672              {
    673                  g_bootloaderContext.commandInterface->stateData->dataPhase.count = remaining;
    674                  g_bootloaderContext.commandInterface->stateData->dataPhase.address = dataAddress;
   \   000000CA   0x6147             STR      R7,[R0, #+20]
    675              }
    676          
    677              return kStatus_Success;
   \                     ??handle_data_consumer_1: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \                     ??handle_data_consumer_5: (+1)
   \   000000CE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    678          }
    679          
    680          //! @brief Handle data phase with data producer (send to host).

   \                                 In section .text, align 2, keep-with-next
    681          status_t handle_data_producer(bool * hasMoreData)
    682          {
   \                     handle_data_producer: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    683              if (g_bootloaderContext.commandInterface->stateData->dataPhase.count == 0)
   \   00000004   0x....             LDR.N    R5,??DataTable20
   \   00000006   0xB08A             SUB      SP,SP,#+40
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x68E8             LDR      R0,[R5, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x6901             LDR      R1,[R0, #+16]
   \   00000010   0xB921             CBNZ.N   R1,??handle_data_producer_0
    684              {
    685                  // No data phase.
    686                  *hasMoreData = false;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    687                  finalize_data_phase(kStatus_Success);
   \   00000016   0x.... 0x....      BL       finalize_data_phase
    688                  return kStatus_Success;
   \   0000001A   0xE04E             B.N      ??handle_data_producer_1
    689              }
    690          
    691              *hasMoreData = true;
   \                     ??handle_data_producer_0: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7021             STRB     R1,[R4, #+0]
    692              uint32_t remaining = g_bootloaderContext.commandInterface->stateData->dataPhase.count;
   \   00000020   0x6906             LDR      R6,[R0, #+16]
    693              uint32_t dataAddress = g_bootloaderContext.commandInterface->stateData->dataPhase.address;
   \   00000022   0x6947             LDR      R7,[R0, #+20]
    694              uint8_t * data = g_bootloaderContext.commandInterface->stateData->dataPhase.data;
   \   00000024   0x68C1             LDR      R1,[R0, #+12]
    695              uint8_t commandTag = g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag;
   \   00000026   0x7F02             LDRB     R2,[R0, #+28]
    696              status_t status = kStatus_Success;
    697          
    698              // Initialize the data packet to send.
    699              uint32_t packetSize;
    700              uint8_t packet[kMinPacketBufferSize];
    701          
    702              // Copy the data into the data packet.
    703              packetSize = MIN(kMinPacketBufferSize, remaining);
   \   00000028   0x2E21             CMP      R6,#+33
   \   0000002A   0xBF2C             ITE      CS 
   \   0000002C   0xF04F 0x0820      MOVCS    R8,#+32
   \   00000030   0x46B0             MOVCC    R8,R6
    704              if (data)
   \   00000032   0xB1A9             CBZ.N    R1,??handle_data_producer_2
    705              {
    706                  // Copy data using compiler-generated memcpy.
    707                  memcpy(packet, data, packetSize);
   \   00000034   0x4642             MOV      R2,R8
   \   00000036   0xA801             ADD      R0,SP,#+4
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    708                  data += packetSize;
    709                  status = kStatus_Success;
    710              }
    711              else
    712              {
    713                  if (commandTag == kCommandTag_ReadMemory)
    714                  {
    715                      // Copy data using memory interface.
    716                      status = g_bootloaderContext.memoryInterface->read(dataAddress, packetSize, packet);
    717                  }
    718                  else if (commandTag == kCommandTag_FlashReadResource)
    719                  {
    720                      // Read data from special-purpose flash memory
    721          #if !defined (BOOTLOADER_HOST)
    722                      flash_read_resource_option_t option = (flash_read_resource_option_t)g_bootloaderContext.commandInterface->stateData->dataPhase.option;
    723                      status = flash_read_resource(&g_bootloaderContext.flashState, dataAddress, (uint32_t*)packet, packetSize, option);
    724          #endif // BOOTLOADER_HOST
    725                  }
    726                  dataAddress += packetSize;
    727              }
    728              if (status != kStatus_Success)
    729              {
    730                  debug_printf("Error: %s returned status 0x%x, abort data phase\r\n",
    731                               (commandTag == kCommandTag_ReadMemory) ? "read memory" : "flash read resource", status);
    732                  // Send zero length packet to tell host we are aborting data phase
    733                  g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    734                      g_bootloaderContext.activePeripheral, (const uint8_t *)packet, 0, kPacketType_Data);
    735                  finalize_data_phase(status);
    736                  *hasMoreData = false;
    737                  return kStatus_Success;
    738              }
    739              remaining -= packetSize;
    740          
    741          #ifdef TEST_SENDER_ABORT
    742          #ifndef WIN32
    743          // Disble IAR "statement is unreachable" error
    744          #pragma diag_suppress=Pe111
    745          #endif // WIN32
    746              // Send zero length packet to abort data phase.
    747              g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    748                  g_bootloaderContext.activePeripheral, (const uint8_t *)packet, 0, kPacketType_Data);
    749              finalize_data_phase(kStatus_AbortDataPhase);
    750              *hasMoreData = false;
    751              return kStatus_Success;
    752          #endif // TEST_SENDER_ABORT;
    753          
    754              status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    755                          g_bootloaderContext.activePeripheral,
    756                           (const uint8_t *)packet, packetSize, kPacketType_Data);
   \                     ??handle_data_producer_3: (+1)
   \   0000003C   0x69E8             LDR      R0,[R5, #+28]
   \   0000003E   0xF8D0 0xC014      LDR      R12,[R0, #+20]
   \   00000042   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x4642             MOV      R2,R8
   \   0000004A   0xA901             ADD      R1,SP,#+4
   \   0000004C   0x47E0             BLX      R12
   \   0000004E   0xEBA6 0x0608      SUB      R6,R6,R8
    757          
    758              if (remaining == 0)
   \   00000052   0xB106             CBZ.N    R6,??handle_data_producer_4
    759              {
    760                  finalize_data_phase(status);
    761                  *hasMoreData = false;
    762              }
    763              else if (status != kStatus_Success)
   \   00000054   0xB368             CBZ.N    R0,??handle_data_producer_5
    764              {
    765                  debug_printf("writePacket aborted due to status 0x%x\r\n", status);
    766                  finalize_data_phase(status);
   \                     ??handle_data_producer_4: (+1)
   \   00000056   0x.... 0x....      BL       finalize_data_phase
    767                  *hasMoreData = false;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7020             STRB     R0,[R4, #+0]
   \   0000005E   0xE02C             B.N      ??handle_data_producer_1
    768              }
   \                     ??handle_data_producer_2: (+1)
   \   00000060   0x2A03             CMP      R2,#+3
   \   00000062   0xEB08 0x0907      ADD      R9,R8,R7
   \   00000066   0xD106             BNE.N    ??handle_data_producer_6
   \   00000068   0x682B             LDR      R3,[R5, #+0]
   \   0000006A   0x685B             LDR      R3,[R3, #+4]
   \   0000006C   0xAA01             ADD      R2,SP,#+4
   \   0000006E   0x4641             MOV      R1,R8
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x4798             BLX      R3
   \   00000074   0xE00C             B.N      ??handle_data_producer_7
   \                     ??handle_data_producer_6: (+1)
   \   00000076   0x2A10             CMP      R2,#+16
   \   00000078   0xBF18             IT       NE 
   \   0000007A   0x464F             MOVNE    R7,R9
   \   0000007C   0xD1DE             BNE.N    ??handle_data_producer_3
   \   0000007E   0x7F40             LDRB     R0,[R0, #+29]
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0x4643             MOV      R3,R8
   \   00000084   0xAA01             ADD      R2,SP,#+4
   \   00000086   0x4639             MOV      R1,R7
   \   00000088   0xF105 0x0020      ADD      R0,R5,#+32
   \   0000008C   0x.... 0x....      BL       flash_read_resource
   \                     ??handle_data_producer_7: (+1)
   \   00000090   0xEA5F 0x0A00      MOVS     R10,R0
   \   00000094   0x464F             MOV      R7,R9
   \   00000096   0xD0D1             BEQ.N    ??handle_data_producer_3
   \   00000098   0x69E8             LDR      R0,[R5, #+28]
   \   0000009A   0x6945             LDR      R5,[R0, #+20]
   \   0000009C   0x68AD             LDR      R5,[R5, #+8]
   \   0000009E   0x2301             MOVS     R3,#+1
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0xA901             ADD      R1,SP,#+4
   \   000000A4   0x47A8             BLX      R5
   \   000000A6   0x4650             MOV      R0,R10
   \   000000A8   0x.... 0x....      BL       finalize_data_phase
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x7020             STRB     R0,[R4, #+0]
   \   000000B0   0xE004             B.N      ??handle_data_producer_8
   \                     ??handle_data_producer_5: (+1)
   \   000000B2   0x68E8             LDR      R0,[R5, #+12]
   \   000000B4   0x68C0             LDR      R0,[R0, #+12]
   \   000000B6   0x6106             STR      R6,[R0, #+16]
    769              else
    770              {
    771                  g_bootloaderContext.commandInterface->stateData->dataPhase.count = remaining;
    772                  g_bootloaderContext.commandInterface->stateData->dataPhase.address = dataAddress;
   \   000000B8   0x6147             STR      R7,[R0, #+20]
    773              }
    774          
    775              return kStatus_Success;
   \                     ??handle_data_producer_1: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??handle_data_producer_8: (+1)
   \   000000BC   0xB00A             ADD      SP,SP,#+40
   \   000000BE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    776          }
    777          
    778          //! @brief Fill Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    779          void handle_fill_memory(uint8_t * packet, uint32_t packetLength)
    780          {
   \                     handle_fill_memory: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    781              fill_memory_packet_t * command = (fill_memory_packet_t *)packet;
    782          
    783              status_t status = g_bootloaderContext.memoryInterface->fill(command->startAddress, command->byteCount, command->patternWord);
   \   00000002   0x....             LDR.N    R3,??DataTable20
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x68DB             LDR      R3,[R3, #+12]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x68E2             LDR      R2,[R4, #+12]
   \   0000000C   0x68A1             LDR      R1,[R4, #+8]
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x4798             BLX      R3
    784          
    785              send_generic_response(status, command->commandPacket.commandTag);
   \   00000012   0x....             B.N      ?Subroutine0
    786          }
    787          
    788          //! @brief Execute command handler.

   \                                 In section .text, align 2, keep-with-next
    789          void handle_execute(uint8_t * packet, uint32_t packetLength)
    790          {
   \                     handle_execute: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
    791              execute_call_packet_t * command = (execute_call_packet_t *)packet;
    792          
    793          #if !defined(BOOTLOADER_HOST)
    794              static uint32_t s_addr = 0;
    795              uint32_t call_address = command->callAddress;
    796              uint32_t argument_word = command->argumentWord;
    797              s_addr = command->stackpointer;
   \   00000006   0x....             LDR.N    R4,??DataTable20_3
   \   00000008   0x686E             LDR      R6,[R5, #+4]
   \   0000000A   0xF8D5 0x8008      LDR      R8,[R5, #+8]
   \   0000000E   0x68E8             LDR      R0,[R5, #+12]
    798              status_t responseStatus = kStatus_Success;
    799          
    800              // Get RAM address ranges
    801              const memory_map_entry_t * map = &g_bootloaderContext.memoryMap[kIndexSRAM];
   \   00000010   0x....             LDR.N    R1,??DataTable20
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \   00000014   0x2700             MOVS     R7,#+0
   \   00000016   0x6849             LDR      R1,[R1, #+4]
   \   00000018   0x310C             ADDS     R1,R1,#+12
    802          
    803              // Validate stack pointer address. It must either be 0 or within the RAM range.
    804              if (!((s_addr == 0) ||
    805                    ((s_addr >= map->startAddress) && (s_addr <= map->endAddress + 1))))
   \   0000001A   0xB130             CBZ.N    R0,??handle_execute_0
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xBF23             ITTTE    CS 
   \   00000022   0x6849             LDRCS    R1,[R1, #+4]
   \   00000024   0x1C49             ADDCS    R1,R1,#+1
   \   00000026   0x4281             CMPCS    R1,R0
   \   00000028   0x2704             MOVCC    R7,#+4
    806              {
    807                  // Invalid stack pointer value, respond with kStatus_InvalidArgument.
    808                  responseStatus = kStatus_InvalidArgument;
    809              }
    810          
    811              // Validate call address.
    812              if (!is_valid_application_location(call_address))
   \                     ??handle_execute_0: (+1)
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       is_valid_application_location
   \   00000030   0xB900             CBNZ.N   R0,??handle_execute_1
    813              {
    814                  // Invalid address, respond with kStatus_InvalidArgument.
    815                  responseStatus = kStatus_InvalidArgument;
   \   00000032   0x2704             MOVS     R7,#+4
    816              }
    817          
    818              // Send response immediately since call may not return
    819              send_generic_response(responseStatus, command->commandPacket.commandTag);
   \                     ??handle_execute_1: (+1)
   \   00000034   0x7829             LDRB     R1,[R5, #+0]
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       send_generic_response
    820          
    821              if (responseStatus == kStatus_Success)
   \   0000003C   0xB99F             CBNZ.N   R7,??handle_execute_2
    822              {
    823                  static call_function_t s_callFunction = 0;
    824                  s_callFunction = (call_function_t)call_address;
   \   0000003E   0x6066             STR      R6,[R4, #+4]
    825          
    826                  // Prepare for shutdown.
    827                  shutdown_cleanup(kShutdownType_Shutdown);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       shutdown_cleanup
    828          
    829                  // Static variables are needed since we are changing the stack pointer out from under the compiler
    830                  // we need to ensure the values we are using are not stored on the previous stack
    831                  static uint32_t s_argument = 0;
    832                  s_argument = argument_word;
    833          
    834                  if (s_addr)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xF8C4 0x8008      STR      R8,[R4, #+8]
   \   0000004C   0xB118             CBZ.N    R0,??handle_execute_3
    835                  {
    836                      // Set main stack pointer and process stack pointer
    837                      __set_MSP(s_addr);
   \   0000004E   0xF380 0x8808      MSR      MSP,R0
    838                      __set_PSP(s_addr);
   \   00000052   0xF380 0x8809      MSR      PSP,R0
    839                  }
    840          
    841                  s_callFunction(s_argument);
   \                     ??handle_execute_3: (+1)
   \   00000056   0x6861             LDR      R1,[R4, #+4]
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x4788             BLX      R1
    842                  // Dummy fcuntion call, should never go to this fcuntion call
    843                  shutdown_cleanup(kShutdownType_Shutdown);
   \   0000005C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      B.W      shutdown_cleanup
    844              }
    845          #else
    846              // Just send a successful response.
    847              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
    848          #endif // BOOTLOADER_HOST
    849          }
   \                     ??handle_execute_2: (+1)
   \   00000066   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??s_addr:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
    850          
    851          //! @brief Call command handler.

   \                                 In section .text, align 2, keep-with-next
    852          void handle_call(uint8_t * packet, uint32_t packetLength)
    853          {
   \                     handle_call: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    854              execute_call_packet_t * command = (execute_call_packet_t *)packet;
    855              status_t responseStatus = kStatus_Success;
    856          
    857          #if !defined(BOOTLOADER_HOST)
    858              // Validate call address.
    859              if (!is_valid_application_location(command->callAddress))
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x.... 0x....      BL       is_valid_application_location
   \   0000000A   0xB908             CBNZ.N   R0,??handle_call_0
    860              {
    861                  // Invalid address, respond with kStatus_InvalidArgument.
    862                  responseStatus = kStatus_InvalidArgument;
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xE005             B.N      ??handle_call_1
    863              }
    864              else
    865              {
    866                  call_function_t callFunction = (call_function_t)command->callAddress;
   \                     ??handle_call_0: (+1)
   \   00000010   0x6865             LDR      R5,[R4, #+4]
    867                  shutdown_cleanup(kShutdownType_Cleanup);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       shutdown_cleanup
    868                  responseStatus = callFunction(command->argumentWord);
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x47A8             BLX      R5
    869              }
    870          #endif // BOOTLOADER_HOST
    871          
    872              send_generic_response(responseStatus, command->commandPacket.commandTag);
   \                     ??handle_call_1: (+1)
   \   0000001C   0x7821             LDRB     R1,[R4, #+0]
   \   0000001E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000022   0x....             B.N      send_generic_response
    873          }
    874          
    875          //! @brief Flash Security Disable command handler.

   \                                 In section .text, align 2, keep-with-next
    876          void handle_flash_security_disable(uint8_t * packet, uint32_t packetLength)
    877          {
   \                     handle_flash_security_disable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    878              flash_security_disable_packet_t * command = (flash_security_disable_packet_t *)packet;
    879          
    880              status_t status = kStatus_Success;
    881          #if !defined(BOOTLOADER_HOST)
    882              // Flash interface wants little endian, so just send two uint32s.
    883              status = flash_security_bypass(&g_bootloaderContext.flashState, (uint8_t *)&command->keyLow);
   \   00000004   0x1D21             ADDS     R1,R4,#+4
   \   00000006   0x....             LDR.N    R0,??DataTable20_4
   \   00000008   0x.... 0x....      BL       flash_security_bypass
    884          #endif // BOOTLOADER_HOST
    885          
    886              send_generic_response(status, command->commandPacket.commandTag);
   \   0000000C   0x....             B.N      ?Subroutine0
    887          }
    888          
    889          
    890          //! @brief  Flash Program Once command handler

   \                                 In section .text, align 2, keep-with-next
    891          void handle_flash_program_once(uint8_t * packet, uint32_t length)
    892          {
   \                     handle_flash_program_once: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    893              flash_program_once_packet_t * command = (flash_program_once_packet_t *)packet;
    894          
    895              status_t status = kStatus_Success;
    896          
    897          #if !defined (BOOTLOADER_HOST)
    898              status = flash_program_once(&g_bootloaderContext.flashState, command->index, &command->data[0], command->byteCount);
   \   00000004   0x68A3             LDR      R3,[R4, #+8]
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x....             LDR.N    R0,??DataTable20_4
   \   0000000A   0xF104 0x020C      ADD      R2,R4,#+12
   \   0000000E   0x.... 0x....      BL       flash_program_once
    899          #endif // BOOTLOADER_HOST
    900          
    901              send_generic_response(status, command->commandPacket.commandTag);
   \   00000012   0x....             B.N      ?Subroutine0
    902          }
    903          
    904          //! @brief  Flash Read Once command handler

   \                                 In section .text, align 2, keep-with-next
    905          void handle_flash_read_once(uint8_t * packet, uint32_t length)
    906          {
   \                     handle_flash_read_once: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    907              flash_read_once_packet_t * command = (flash_read_once_packet_t *)packet;
    908          
    909              uint32_t readOnceItemData[2] = {0};
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xC006             STM      R0!,{R1,R2}
    910          
    911              status_t status = kStatus_Success;
    912          
    913          #if !defined (BOOTLOADER_HOST)
    914              status = flash_read_once(&g_bootloaderContext.flashState, command->index, &readOnceItemData[0], command->byteCount);
   \   0000000C   0x68A3             LDR      R3,[R4, #+8]
   \   0000000E   0x6861             LDR      R1,[R4, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable20_4
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x.... 0x....      BL       flash_read_once
    915          #endif // BOOTLOADER_HOST
    916          
    917              send_flash_read_once_response(status, readOnceItemData, command->byteCount);
   \   00000018   0x68A2             LDR      R2,[R4, #+8]
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x.... 0x....      BL       send_flash_read_once_response
    918          
    919          }
   \   00000020   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    920          
    921          //! @brief  Flash Read Resource command handler

   \                                 In section .text, align 2, keep-with-next
    922          void handle_flash_read_resource(uint8_t * packet, uint32_t length)
    923          {
   \                     handle_flash_read_resource: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    924              flash_read_resource_packet_t * command = (flash_read_resource_packet_t *)packet;
    925          
    926              // Start the data phase.
    927              reset_data_phase();
    928              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable20
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0x68C9             LDR      R1,[R1, #+12]
   \   0000000C   0x68A2             LDR      R2,[R4, #+8]
   \   0000000E   0x610A             STR      R2,[R1, #+16]
    929              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
   \   00000010   0x6862             LDR      R2,[R4, #+4]
   \   00000012   0x614A             STR      R2,[R1, #+20]
    930              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_FlashReadResource;
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x770A             STRB     R2,[R1, #+28]
    931              g_bootloaderContext.commandInterface->stateData->dataPhase.option = (uint8_t)command->option;
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x68E1             LDR      R1,[R4, #+12]
   \   0000001E   0x7741             STRB     R1,[R0, #+29]
    932              send_flash_read_resource_response(kStatus_Success, command->byteCount);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x68A1             LDR      R1,[R4, #+8]
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x....             B.N      send_flash_read_resource_response
    933          }
    934          
    935          //! @brief Send a generic response packet.

   \                                 In section .text, align 2, keep-with-next
    936          void send_generic_response(uint32_t commandStatus, uint32_t commandTag)
    937          {
   \                     send_generic_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    938              generic_response_packet_t responsePacket;
    939              responsePacket.commandPacket.commandTag = kCommandTag_GenericResponse;
   \   00000004   0x22A0             MOVS     R2,#+160
    940              responsePacket.commandPacket.flags = 0;
    941              responsePacket.commandPacket.reserved = 0;
    942              responsePacket.commandPacket.parameterCount = 2;
    943              responsePacket.status = commandStatus;
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   0000000C   0x2200             MOVS     R2,#+0
    944              responsePacket.commandTag = commandTag;
   \   0000000E   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000012   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   00000016   0x9102             STR      R1,[SP, #+8]
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6944             LDR      R4,[R0, #+20]
   \   00000022   0x68A4             LDR      R4,[R4, #+8]
   \   00000024   0x220C             MOVS     R2,#+12
   \   00000026   0x....             B.N      ??Subroutine9_0
    945          
    946              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    947                                      g_bootloaderContext.activePeripheral,
    948                                      (const uint8_t *)&responsePacket,
    949                                      sizeof(responsePacket), kPacketType_Command);
    950              if (status != kStatus_Success)
    951              {
    952                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
    953              }
    954          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine9_0: (+1)
   \   00000000   0x4669             MOV      R1,SP
   \   00000002   0x47A0             BLX      R4
   \   00000004   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   00000008   0x4770             BX       LR
    955          
    956          //! @brief Send a get property response packet.

   \                                 In section .text, align 2, keep-with-next
    957          void send_get_property_response(uint32_t commandStatus, uint32_t * value, uint32_t numValues)
    958          {
   \                     send_get_property_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    959              get_property_response_packet_t responsePacket;
    960              responsePacket.commandPacket.commandTag = kCommandTag_GetPropertyResponse;
   \   00000004   0x23A7             MOVS     R3,#+167
   \   00000006   0x.... 0x....      BL       ?Subroutine4
    961              responsePacket.commandPacket.flags = 0;
    962              responsePacket.commandPacket.reserved = 0;
    963              responsePacket.commandPacket.parameterCount = 1 + numValues;    // status + value words
    964              responsePacket.status = commandStatus;
    965          
    966              for (int i = 0; i < (int)numValues; ++i)
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x1C53             ADDS     R3,R2,#+1
   \   0000000E   0xF88D 0x3003      STRB     R3,[SP, #+3]
   \   00000012   0xE006             B.N      ??send_get_property_response_0
    967              {
    968                  responsePacket.propertyValue[i] = value[i];
   \                     ??send_get_property_response_1: (+1)
   \   00000014   0x466C             MOV      R4,SP
   \   00000016   0xF851 0x3020      LDR      R3,[R1, R0, LSL #+2]
   \   0000001A   0xEB04 0x0480      ADD      R4,R4,R0, LSL #+2
    969              }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x60A3             STR      R3,[R4, #+8]
   \                     ??send_get_property_response_0: (+1)
   \   00000022   0x4290             CMP      R0,R2
   \   00000024   0xDBF6             BLT.N    ??send_get_property_response_1
   \   00000026   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x....             B.N      ?Subroutine2
    970          
    971              uint32_t packetSize = sizeof(responsePacket.commandPacket) +
    972                  (responsePacket.commandPacket.parameterCount * sizeof(uint32_t));
    973          
    974              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    975                                      g_bootloaderContext.activePeripheral,
    976                                      (const uint8_t *)&responsePacket,
    977                                      packetSize, kPacketType_Command);
    978              if (status != kStatus_Success)
    979              {
    980                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
    981              }
    982          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4669             MOV      R1,SP
   \   00000002   0x47A0             BLX      R4
   \   00000004   0xB008             ADD      SP,SP,#+32
   \   00000006   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000008   0x6944             LDR      R4,[R0, #+20]
   \   0000000A   0x68A4             LDR      R4,[R4, #+8]
   \   0000000C   0x0089             LSLS     R1,R1,#+2
   \   0000000E   0x1D0A             ADDS     R2,R1,#+4
   \   00000010   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xF88D 0x3000      STRB     R3,[SP, #+0]
   \   00000004   0x9001             STR      R0,[SP, #+4]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xF88D 0x3001      STRB     R3,[SP, #+1]
   \   0000000C   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \   00000010   0x4770             BX       LR
    983          
    984          //! @brief Send a read memory response packet.

   \                                 In section .text, align 2, keep-with-next
    985          void send_read_memory_response(uint32_t commandStatus, uint32_t length)
    986          {
   \                     send_read_memory_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    987              read_memory_response_packet_t responsePacket;
    988              responsePacket.commandPacket.commandTag = kCommandTag_ReadMemoryResponse;
   \   00000004   0x22A3             MOVS     R2,#+163
   \   00000006   0x....             B.N      ?Subroutine1
    989              responsePacket.commandPacket.flags = kCommandFlag_HasDataPhase;
    990              responsePacket.commandPacket.reserved = 0;
    991              responsePacket.commandPacket.parameterCount = 2;
    992              responsePacket.status = commandStatus;
    993              responsePacket.dataByteCount = length;
    994          
    995              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    996                                      g_bootloaderContext.activePeripheral,
    997                                      (const uint8_t *)&responsePacket,
    998                                      sizeof(responsePacket), kPacketType_Command);
    999              if (status != kStatus_Success)
   1000              {
   1001                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1002              }
   1003          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000004   0x9001             STR      R0,[SP, #+4]
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000000C   0x9102             STR      R1,[SP, #+8]
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \   0000001C   0x220C             MOVS     R2,#+12
   \   0000001E   0x6944             LDR      R4,[R0, #+20]
   \   00000020   0x68A4             LDR      R4,[R4, #+8]
   \   00000022                      REQUIRE ??Subroutine9_0
   \   00000022                      ;; // Fall through to label ??Subroutine9_0
   1004          
   1005          //! @brief Send a flash read once resposne packet.

   \                                 In section .text, align 2, keep-with-next
   1006          void send_flash_read_once_response(uint32_t commandStatus, uint32_t * value, uint32_t byteCount)
   1007          {
   \                     send_flash_read_once_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1008              flash_read_once_response_packet_t responsePacket;
   1009              responsePacket.commandPacket.commandTag = kCommandTag_FlashReadOnceResponse;
   \   00000004   0x23AF             MOVS     R3,#+175
   \   00000006   0x.... 0x....      BL       ?Subroutine4
   1010              responsePacket.commandPacket.flags = 0;
   1011              responsePacket.commandPacket.reserved = 0;
   1012              responsePacket.commandPacket.parameterCount = 2; // always includes two parameters: status and byte count
   1013              responsePacket.status = commandStatus;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000000A   0x2302             MOVS     R3,#+2
   \   0000000C   0xF88D 0x3003      STRB     R3,[SP, #+3]
   1014          
   1015              if (commandStatus == kStatus_Success)
   \   00000010   0xB940             CBNZ.N   R0,??send_flash_read_once_response_0
   1016              {
   1017                  responsePacket.commandPacket.parameterCount +=  byteCount / sizeof(uint32_t); // add parameter: data
   \   00000012   0x0890             LSRS     R0,R2,#+2
   \   00000014   0x1C80             ADDS     R0,R0,#+2
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1018                  responsePacket.byteCount = byteCount;
   \   0000001A   0x9202             STR      R2,[SP, #+8]
   1019                  memcpy(responsePacket.data, value, byteCount);
   \   0000001C   0xA803             ADD      R0,SP,#+12
   \   0000001E   0x.... 0x....      BL       __aeabi_memcpy4
   1020              }
   \   00000022   0xE001             B.N      ??send_flash_read_once_response_1
   1021              else
   1022              {
   1023                  responsePacket.byteCount = 0;
   \                     ??send_flash_read_once_response_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9002             STR      R0,[SP, #+8]
   \                     ??send_flash_read_once_response_1: (+1)
   \   00000028   0x2300             MOVS     R3,#+0
   1024              }
   \   0000002A   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000002E                      REQUIRE ?Subroutine2
   \   0000002E                      ;; // Fall through to label ?Subroutine2
   1025          
   1026              uint32_t packetSize = sizeof(responsePacket.commandPacket) +
   1027                  (responsePacket.commandPacket.parameterCount * sizeof(uint32_t));
   1028          
   1029              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1030                                      g_bootloaderContext.activePeripheral,
   1031                                      (const uint8_t *)&responsePacket,
   1032                                      packetSize, kPacketType_Command);
   1033              if (status != kStatus_Success)
   1034              {
   1035                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1036              }
   1037          }
   1038          
   1039          //! @brief Send a flash read resource memory response packet.

   \                                 In section .text, align 2, keep-with-next
   1040          void send_flash_read_resource_response(uint32_t commandStatus, uint32_t length)
   1041          {
   \                     send_flash_read_resource_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1042              flash_read_resource_response_packet_t responsePacket;
   1043              responsePacket.commandPacket.commandTag = kCommandTag_FlashReadResourceResponse;
   \   00000004   0x22B0             MOVS     R2,#+176
   \   00000006                      REQUIRE ?Subroutine1
   \   00000006                      ;; // Fall through to label ?Subroutine1
   1044              responsePacket.commandPacket.flags = kCommandFlag_HasDataPhase;
   1045              responsePacket.commandPacket.reserved = 0;
   1046              responsePacket.commandPacket.parameterCount = 2;
   1047              responsePacket.status = commandStatus;
   1048              responsePacket.dataByteCount = length;
   1049          
   1050              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1051                                      g_bootloaderContext.activePeripheral,
   1052                                      (const uint8_t *)&responsePacket,
   1053                                      sizeof(responsePacket), kPacketType_Command);
   1054              if (status != kStatus_Success)
   1055              {
   1056                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1057              }
   1058          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     ??s_addr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   1059          
   1060          //! @}
   1061          
   1062          ////////////////////////////////////////////////////////////////////////////////
   1063          // EOF
   1064          ////////////////////////////////////////////////////////////////////////////////
   1065          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   bootloader_command_init
      32   bootloader_command_pump
        32   -- Indirect call
        32   -> flash_get_security_state
        32   -> send_generic_response
      16   finalize_data_phase
        16   -- Indirect call
        16   -> sbloader_finalize_jump
        16   -> send_generic_response
      16   handle_call
        16   -- Indirect call
        16   -> is_valid_application_location
         0   -> send_generic_response
        16   -> shutdown_cleanup
      32   handle_data_consumer
        32   -- Indirect call
        32   -> finalize_data_phase
        32   -> sbloader_pump
      72   handle_data_producer
        72   -- Indirect call
        72   -> __aeabi_memcpy
        72   -> finalize_data_phase
        72   -> flash_read_resource
      24   handle_execute
        24   -- Indirect call
        24   -> is_valid_application_location
        24   -> send_generic_response
         0   -> shutdown_cleanup
        24   -> shutdown_cleanup
       8   handle_fill_memory
         8   -- Indirect call
         0   -> send_generic_response
       8   handle_flash_erase_all
         8   -> flash_mem_erase_all
         0   -> send_generic_response
       8   handle_flash_erase_all_unsecure
         8   -> flash_mem_erase_all_unsecure
         0   -> send_generic_response
       8   handle_flash_erase_region
         8   -- Indirect call
         0   -> send_generic_response
       8   handle_flash_program_once
         8   -> flash_program_once
         0   -> send_generic_response
      16   handle_flash_read_once
        16   -> flash_read_once
        16   -> send_flash_read_once_response
       8   handle_flash_read_resource
         8   -> reset_data_phase
         0   -> send_flash_read_resource_response
       8   handle_flash_security_disable
         8   -> flash_security_bypass
         0   -> send_generic_response
      24   handle_get_property
        24   -- Indirect call
        24   -> send_get_property_response
       8   handle_read_memory
         8   -> reset_data_phase
         0   -> send_read_memory_response
       8   handle_receive_sb_file
         8   -> reset_data_phase
         0   -> sbloader_init
         8   -> send_generic_response
       8   handle_reset
         8   -- Indirect call
         8   -> send_generic_response
         8   -> shutdown_cleanup
       8   handle_set_property
         8   -- Indirect call
         0   -> send_generic_response
       8   handle_write_memory
         8   -> reset_data_phase
         0   -> send_generic_response
       0   reset_data_phase
         0   -> __aeabi_memclr4
      40   send_flash_read_once_response
        40   -- Indirect call
        40   -> __aeabi_memcpy4
      24   send_flash_read_resource_response
        24   -- Indirect call
      24   send_generic_response
        24   -- Indirect call
      40   send_get_property_response
        40   -- Indirect call
      24   send_read_memory_response
        24   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       6  ??Subroutine9_0
       8  ?Subroutine0
      34  ?Subroutine1
       8  ?Subroutine2
      10  ?Subroutine3
      18  ?Subroutine4
      18  ?Subroutine5
      18  ?Subroutine6
       4  ?Subroutine7
      10  ?Subroutine8
       8  ?_0
      14  bootloader_command_init
     226  bootloader_command_pump
      68  finalize_data_phase
      36  g_commandData
     136  g_commandHandlerTable
      16  g_commandInterface
      36  handle_call
     210  handle_data_consumer
     194  handle_data_producer
     106  handle_execute
      20  handle_fill_memory
      10  handle_flash_erase_all
       8  handle_flash_erase_all_unsecure
      20  handle_flash_erase_region
      20  handle_flash_program_once
      34  handle_flash_read_once
      42  handle_flash_read_resource
      14  handle_flash_security_disable
      52  handle_get_property
      24  handle_read_memory
      38  handle_receive_sb_file
      56  handle_reset
      22  handle_set_property
      18  handle_write_memory
      16  reset_data_phase
      12  s_addr
          s_callFunction
          s_argument
      46  send_flash_read_once_response
       6  send_flash_read_resource_response
      40  send_generic_response
      46  send_get_property_response
       8  send_read_memory_response

 
    48 bytes in section .bss
    16 bytes in section .data
   144 bytes in section .rodata
 1 548 bytes in section .text
 
 1 548 bytes of CODE  memory
   144 bytes of CONST memory
    64 bytes of DATA  memory

Errors: none
Warnings: none
