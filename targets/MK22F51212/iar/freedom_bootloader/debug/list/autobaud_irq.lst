###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:45:52
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\autobaud\src\autobaud_irq.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\autobaud\src\autobaud_irq.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\autobaud_irq.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\autobaud_irq.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\autobaud\src\autobaud_irq.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_platform_common.h"
     32          #include "fsl_device_registers.h"
     33          #include "autobaud/autobaud.h"
     34          #include "microseconds/microseconds.h"
     35          #include "bootloader_common.h"
     36          
     37          ////////////////////////////////////////////////////////////////////////////////
     38          // Definitions
     39          ////////////////////////////////////////////////////////////////////////////////
     40          
     41          enum _autobaud_counts
     42          {
     43              //! the number of falling edge transitions being counted
     44              //! for 0x5A
     45              kFirstByteRequiredFallingEdges = 4,
     46              //! the number of falling edge transitions being counted
     47              //! for 0xA6
     48              kSecondByteRequiredFallingEdges = 3,
     49              //! the number of bits being measured for the baud rate
     50              //! for 0x5A we have the start bit + 7 bits to the last falling edge = 8 bits
     51              kNumberOfBitsForFirstByteMeasured = 8,
     52              //! for 0xA6 we have the start bit + 6 bits to the last falling edge = 7 bits
     53              kNumberOfBitsForSecondByteMeasured = 7,
     54              //! Time in microseconds that we will wait in between toggles before restarting detection
     55              //! Make this value 8 bits at 100 baud worth of time = 80000 microseconds
     56              kMaximumTimeBetweenFallingEdges = 80000,
     57              //! Autobaud baud step size that our calculation will be rounded to, this is to ensure
     58              //! that we can use a valid multiplier in the UART configuration which runs into problems
     59              //! at higher baud rates with slightly off baud rates (e.g. if we measure 115458 vs 115200)
     60              //! a calculation of UartClock at 48MHz gives an SBR calculation of 48000000/ (16 * 115458) = 25
     61              //! giving a baud rate calculation of 48000000/(16 * 25) = 120000 baud
     62              //! which is out of spec and fails
     63              kAutobaudStepSize = 1200
     64          };
     65          
     66          ////////////////////////////////////////////////////////////////////////////////
     67          // Prototypes
     68          ////////////////////////////////////////////////////////////////////////////////
     69          void instance_transition_callback(unsigned int instance);
     70          
     71          ////////////////////////////////////////////////////////////////////////////////
     72          // Variables
     73          ////////////////////////////////////////////////////////////////////////////////
     74          

   \                                 In section .bss, align 8
     75          static uint32_t s_transitionCount;
     76          static uint64_t s_firstByteTotalTicks;
   \                     s_firstByteTotalTicks:
   \   00000000                      DS8 8
   \   00000008                      DS8 8
   \   00000010                      DS8 8
   \   00000018                      DS8 4
   \   0000001C                      DS8 4
   \   00000020                      DS8 4
     77          static uint64_t s_secondByteTotalTicks;
     78          static uint64_t s_lastToggleTicks;
     79          static uint32_t s_ticksBetweenFailure;
     80          static uint32_t s_instanceMeasured;
     81          
     82          ////////////////////////////////////////////////////////////////////////////////
     83          // Code
     84          ////////////////////////////////////////////////////////////////////////////////
     85          

   \                                 In section .text, align 2, keep-with-next
     86          void autobaud_init(unsigned int instance)
     87          {
   \                     autobaud_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     88              s_transitionCount = 0;
   \   00000004   0x....             LDR.N    R5,??DataTable2
   \   00000006   0x2000             MOVS     R0,#+0
     89              s_firstByteTotalTicks = 0;
   \   00000008   0xE9C5 0x0000      STRD     R0,R0,[R5, #+0]
     90              s_secondByteTotalTicks = 0;
   \   0000000C   0xE9C5 0x0002      STRD     R0,R0,[R5, #+8]
     91              s_lastToggleTicks = 0;
   \   00000010   0xE9C5 0x0004      STRD     R0,R0,[R5, #+16]
   \   00000014   0x61A8             STR      R0,[R5, #+24]
     92              s_instanceMeasured = 0;
   \   00000016   0x6228             STR      R0,[R5, #+32]
     93              s_ticksBetweenFailure = microseconds_convert_to_ticks(kMaximumTimeBetweenFallingEdges);
   \   00000018   0x....             LDR.N    R0,??DataTable2_1  ;; 0x13880
   \   0000001A   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   0000001E   0x61E8             STR      R0,[R5, #+28]
     94              enable_autobaud_pin_irq(instance, instance_transition_callback);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000026   0x.... 0x....      ADR.W    R1,instance_transition_callback
   \   0000002A   0x.... 0x....      B.W      enable_autobaud_pin_irq
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          void autobaud_deinit(unsigned int instance)
     98          {
     99              disable_autobaud_pin_irq(instance);
   \                     autobaud_deinit: (+1)
   \   00000000   0x.... 0x....      B.W      disable_autobaud_pin_irq
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          status_t autobaud_get_rate(unsigned int instance, unsigned int * rate)
    103          {
   \                     autobaud_get_rate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    104              if ((s_transitionCount == (kFirstByteRequiredFallingEdges + kSecondByteRequiredFallingEdges)) &&
    105                  (instance == s_instanceMeasured))
   \   00000002   0x....             LDR.N    R5,??DataTable2
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x69A9             LDR      R1,[R5, #+24]
   \   00000008   0x2907             CMP      R1,#+7
   \   0000000A   0xBF04             ITT      EQ 
   \   0000000C   0x6A29             LDREQ    R1,[R5, #+32]
   \   0000000E   0x4288             CMPEQ    R0,R1
   \   00000010   0xD11A             BNE.N    ??autobaud_get_rate_0
    106              {
    107                  unsigned int calculatedBaud = (microseconds_get_clock() * (kNumberOfBitsForFirstByteMeasured + kNumberOfBitsForSecondByteMeasured)) / (uint32_t)(s_firstByteTotalTicks + s_secondByteTotalTicks);
   \   00000012   0x.... 0x....      BL       microseconds_get_clock
    108          
    109                  // Round the rate to the nearest step size
    110                  // rounded = stepSize * (value/stepSize + .5)
    111                  // multiplying by 10 since we can't work with floats
    112                  *rate = ((((calculatedBaud * 10) / kAutobaudStepSize) + 5) / 10) * kAutobaudStepSize;
   \   00000016   0xEBC0 0x1600      RSB      R6,R0,R0, LSL #+4
   \   0000001A   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \   0000001E   0xE9D5 0x2302      LDRD     R2,R3,[R5, #+8]
   \   00000022   0x1810             ADDS     R0,R2,R0
   \   00000024   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   00000028   0x210A             MOVS     R1,#+10
   \   0000002A   0x4348             MULS     R0,R1,R0
   \   0000002C   0xF44F 0x6196      MOV      R1,#+1200
   \   00000030   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000034   0x1D40             ADDS     R0,R0,#+5
   \   00000036   0x210A             MOVS     R1,#+10
   \   00000038   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000003C   0xF44F 0x6196      MOV      R1,#+1200
   \   00000040   0x4348             MULS     R0,R1,R0
   \   00000042   0x6020             STR      R0,[R4, #+0]
    113          
    114                  return kStatus_Success;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD70             POP      {R4-R6,PC}
    115              }
    116              else
    117              {
    118                  // no baud rate yet/inactive
    119                  return kStatus_Fail;
   \                     ??autobaud_get_rate_0: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    120              }
    121          }
    122          

   \                                 In section .text, align 4, keep-with-next
    123          void instance_transition_callback(unsigned int instance)
    124          {
   \                     instance_transition_callback: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
    125              uint64_t ticks = microseconds_get_ticks();
   \   00000006   0x.... 0x....      BL       microseconds_get_ticks
    126              s_transitionCount++;
   \   0000000A   0x....             LDR.N    R7,??DataTable2
   \   0000000C   0x4604             MOV      R4,R0
    127          
    128              uint64_t delta = ticks - s_lastToggleTicks;
    129          
    130              // The last toggle was longer than we allow so treat this as the first one
    131              if(delta > s_ticksBetweenFailure)
   \   0000000E   0xE9D7 0x5904      LDRD     R5,R9,[R7, #+16]
   \   00000012   0x4688             MOV      R8,R1
   \   00000014   0x69B8             LDR      R0,[R7, #+24]
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x1C42             ADDS     R2,R0,#+1
   \   0000001A   0x1B65             SUBS     R5,R4,R5
   \   0000001C   0xEB68 0x0909      SBC      R9,R8,R9
   \   00000020   0x69F8             LDR      R0,[R7, #+28]
   \   00000022   0x4549             CMP      R1,R9
   \   00000024   0xD802             BHI.N    ??instance_transition_callback_0
   \   00000026   0xBF2C             ITE      CS 
   \   00000028   0x42A8             CMPCS    R0,R5
   \   0000002A   0x2201             MOVCC    R2,#+1
    132              {
    133                  s_transitionCount = 1;
    134              }
    135          
    136              switch(s_transitionCount)
   \                     ??instance_transition_callback_0: (+1)
   \   0000002C   0x2A01             CMP      R2,#+1
   \   0000002E   0x61BA             STR      R2,[R7, #+24]
   \   00000030   0xD006             BEQ.N    ??instance_transition_callback_1
   \   00000032   0x2A04             CMP      R2,#+4
   \   00000034   0xD008             BEQ.N    ??instance_transition_callback_2
   \   00000036   0x2A05             CMP      R2,#+5
   \   00000038   0xD00E             BEQ.N    ??instance_transition_callback_3
   \   0000003A   0x2A07             CMP      R2,#+7
   \   0000003C   0xD00F             BEQ.N    ??instance_transition_callback_4
   \   0000003E   0xE018             B.N      ??instance_transition_callback_5
    137              {
    138                  case 1:
    139                      // This is our first falling edge, store the initial ticks temporarily in firstByteTicks
    140                      // and save the instance that we are measuring
    141                      s_firstByteTotalTicks = ticks;
   \                     ??instance_transition_callback_1: (+1)
   \   00000040   0xE9C7 0x4800      STRD     R4,R8,[R7, #+0]
    142                      s_instanceMeasured = instance;
   \   00000044   0x623E             STR      R6,[R7, #+32]
    143                      break;
   \   00000046   0xE014             B.N      ??instance_transition_callback_5
    144          
    145                  case kFirstByteRequiredFallingEdges:
    146                      // We reached the end of our measurable first byte, subtract the current ticks from the initial
    147                      // first byte ticks
    148                      s_firstByteTotalTicks = ticks - s_firstByteTotalTicks;
   \                     ??instance_transition_callback_2: (+1)
   \   00000048   0xE9D7 0x0100      LDRD     R0,R1,[R7, #+0]
   \   0000004C   0x1A20             SUBS     R0,R4,R0
   \   0000004E   0xEB68 0x0101      SBC      R1,R8,R1
   \   00000052   0xE9C7 0x0100      STRD     R0,R1,[R7, #+0]
    149                      break;
   \   00000056   0xE00C             B.N      ??instance_transition_callback_5
    150          
    151                  case (kFirstByteRequiredFallingEdges + 1):
    152                      // We hit our first falling edge of the second byte, store the initial ticks temporarily in secondByteTicks
    153                      s_secondByteTotalTicks = ticks;
   \                     ??instance_transition_callback_3: (+1)
   \   00000058   0xE9C7 0x4802      STRD     R4,R8,[R7, #+8]
    154                      break;
   \   0000005C   0xE009             B.N      ??instance_transition_callback_5
    155          
    156                  case (kFirstByteRequiredFallingEdges + kSecondByteRequiredFallingEdges):
    157                      // We reached the end of our measurable second byte, subtract the current ticks from the initial
    158                      // second byte ticks
    159                      s_secondByteTotalTicks = ticks - s_secondByteTotalTicks;
   \                     ??instance_transition_callback_4: (+1)
   \   0000005E   0xE9D7 0x0102      LDRD     R0,R1,[R7, #+8]
   \   00000062   0x1A20             SUBS     R0,R4,R0
   \   00000064   0xEB68 0x0101      SBC      R1,R8,R1
   \   00000068   0xE9C7 0x0102      STRD     R0,R1,[R7, #+8]
    160                      disable_autobaud_pin_irq(instance);
   \   0000006C   0x4630             MOV      R0,R6
   \   0000006E   0x.... 0x....      BL       disable_autobaud_pin_irq
    161                      break;
    162              }
    163          
    164              s_lastToggleTicks = ticks;
   \                     ??instance_transition_callback_5: (+1)
   \   00000072   0xE9C7 0x4804      STRD     R4,R8,[R7, #+16]
    165          }
   \   00000076   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s_firstByteTotalTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x00013880         DC32     0x13880
    166          
    167          ////////////////////////////////////////////////////////////////////////////////
    168          // EOF
    169          ////////////////////////////////////////////////////////////////////////////////
    170          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   autobaud_deinit
         0   -> disable_autobaud_pin_irq
      16   autobaud_get_rate
        16   -> microseconds_get_clock
      16   autobaud_init
         0   -> enable_autobaud_pin_irq
        16   -> microseconds_convert_to_ticks
      32   instance_transition_callback
        32   -> disable_autobaud_pin_irq
        32   -> microseconds_get_ticks


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  autobaud_deinit
      76  autobaud_get_rate
      46  autobaud_init
     122  instance_transition_callback
      36  s_firstByteTotalTicks
          s_secondByteTotalTicks
          s_lastToggleTicks
          s_transitionCount
          s_ticksBetweenFailure
          s_instanceMeasured

 
  36 bytes in section .bss
 256 bytes in section .text
 
 256 bytes of CODE memory
  36 bytes of DATA memory

Errors: none
Warnings: none
