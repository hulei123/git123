###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:37
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\memory\src\flash_memory.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\memory\src\flash_memory.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\flash_memory.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\flash_memory.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\memory\src\flash_memory.c
      1          /*
      2           * Copyright (c) 2013-2014, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "memory/memory.h"
     33          #include "flash_memory.h"
     34          #include "normal_memory.h"
     35          #include "flash/flash.h"
     36          #include "bootloader/context.h"
     37          #include "device/fsl_device_registers.h"
     38          #include "utilities/fsl_rtos_abstraction.h"
     39          #include "utilities/fsl_assert.h"
     40          #include <string.h>
     41          
     42          ////////////////////////////////////////////////////////////////////////////////
     43          // Definitions
     44          ////////////////////////////////////////////////////////////////////////////////
     45          
     46          // If the bootloader is running from flash, then we need to make sure that all
     47          // interrupts are disabled during the execution of a flash operation, so that
     48          // no code is unexpectedly run from flash (which would cause a hard fault).
     49          //
     50          // If we're running from ROM or RAM, then we neither need to nor want to disable
     51          // interrupts during flash operations.
     52          #if !BL_TARGET_FLASH
     53              #define lock_release() (void)sizeof(0)
     54              #define lock_acquire() (void)sizeof(0)
     55          #endif // BL_TARGET_FLASH
     56          
     57          //! @brief Flash Memory constants.
     58          enum _flash_memory_constants {
     59              kFlashMemory_ErasedValue = ~0
     60          };
     61          
     62          ////////////////////////////////////////////////////////////////////////////////
     63          // Variables
     64          ////////////////////////////////////////////////////////////////////////////////
     65          
     66          //! @brief Interface to flash memory operations.

   \                                 In section .rodata, align 4, keep-with-next
     67          const memory_region_interface_t g_flashMemoryInterface = {
   \                     g_flashMemoryInterface:
   \   00000000   0x........         DC32 flash_mem_init, flash_mem_read, flash_mem_write, flash_mem_fill
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x00000000         DC32 0H, flash_mem_erase
   \              0x........   
     68              .init = &flash_mem_init,
     69              .read = &flash_mem_read,
     70              .write = &flash_mem_write,
     71          #if !BL_MIN_PROFILE || BL_FEATURE_FILL_MEMORY
     72              .fill = &flash_mem_fill,
     73          #endif // !BL_MIN_PROFILE
     74              .flush = NULL,
     75              .erase = flash_mem_erase,
     76          };
     77          
     78          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
     79          //! @brief It is used for indicating if an XA controlled region is unlocked to program state

   \                                 In section .bss, align 1
     80          bool isFlashRegionUnlocked = false;
   \                     isFlashRegionUnlocked:
   \   00000000                      DS8 1
     81          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
     82          
     83          ////////////////////////////////////////////////////////////////////////////////
     84          // Prototypes
     85          ////////////////////////////////////////////////////////////////////////////////
     86          //! @brief check if a flash region is in an XA controlled region or contains an XA controlled region.
     87          //         and try to open flash program state by calling verify_erase_all command if needed.
     88          status_t flash_preprocess_execute_only_region(uint32_t address, uint32_t length, flash_execute_only_access_state_t *state);
     89          
     90          ////////////////////////////////////////////////////////////////////////////////
     91          // Code
     92          ////////////////////////////////////////////////////////////////////////////////
     93          
     94          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
     95          status_t flash_mem_init(void)
     96          {
   \                     flash_mem_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     97              // Update address range of flash
     98              memory_map_entry_t * map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
   \   00000002   0x....             LDR.N    R4,??DataTable8
   \   00000004   0x6865             LDR      R5,[R4, #+4]
     99              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_FlashBlockBaseAddr, &map->startAddress);
   \   00000006   0x462A             MOV      R2,R5
   \   00000008   0x2104             MOVS     R1,#+4
   \   0000000A   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000000E   0x.... 0x....      BL       flash_get_property
    100              uint32_t tmp;
    101              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_TotalFlashSize, &tmp);
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000001A   0x.... 0x....      BL       flash_get_property
    102              map->endAddress = map->startAddress + tmp - 1;
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0x1808             ADDS     R0,R1,R0
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x6068             STR      R0,[R5, #+4]
    103          
    104              return kStatus_Success;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          
    108          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    109          status_t flash_mem_read(uint32_t address, uint32_t length, uint8_t * restrict buffer)
    110          {
   \                     flash_mem_read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    111          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    112              flash_execute_only_access_state_t access_state;
    113              uint32_t alignedAddress = ALIGN_DOWN(address, g_bootloaderContext.flashState.PFlashAccessSegmentSize);
   \   00000004   0x....             LDR.N    R0,??DataTable8
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x6B41             LDR      R1,[R0, #+52]
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x424A             RSBS     R2,R1,#+0
   \   0000000E   0xEA02 0x0104      AND      R1,R2,R4
    114              uint32_t updatedLength = address - alignedAddress + length;
    115              uint32_t alignedLength = ALIGN_UP(updatedLength, g_bootloaderContext.flashState.PFlashAccessSegmentSize);
    116              status_t status = flash_is_execute_only(&g_bootloaderContext.flashState, alignedAddress, alignedLength,  &access_state);
   \   00000012   0x1A67             SUBS     R7,R4,R1
   \   00000014   0x19EF             ADDS     R7,R5,R7
   \   00000016   0x427F             RSBS     R7,R7,#+0
   \   00000018   0x403A             ANDS     R2,R2,R7
   \   0000001A   0x466B             MOV      R3,SP
   \   0000001C   0x4252             RSBS     R2,R2,#+0
   \   0000001E   0x3020             ADDS     R0,R0,#+32
   \   00000020   0x.... 0x....      BL       flash_is_execute_only
    117              if (status != kStatus_Success)
   \   00000024   0xB948             CBNZ.N   R0,??flash_mem_read_0
    118              {
    119                  return status;
    120              }
    121          
    122              if (access_state != kFlashAccess_UnLimited)
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xB108             CBZ.N    R0,??flash_mem_read_1
    123              {
    124                  return kStatus_FlashRegionExecuteOnly;
   \   0000002C   0x206C             MOVS     R0,#+108
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
    125              }
    126          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    127          
    128              return normal_mem_read(address, length, buffer);
   \                     ??flash_mem_read_1: (+1)
   \   00000030   0x4632             MOV      R2,R6
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       normal_mem_read
   \                     ??flash_mem_read_0: (+1)
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    129          }
    130          
    131          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    132          status_t flash_mem_write(uint32_t address, uint32_t length, const uint8_t * buffer)
    133          {
   \                     flash_mem_write: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    134              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_write().
    135              assert(length);
    136              assert(buffer);
    137          
    138              // Align length to whole words.
    139              uint32_t alignedLength = ALIGN_DOWN(length, sizeof(uint8_t)*FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    140              uint32_t extraBytes = length - alignedLength;
    141              assert(extraBytes < sizeof(uint8_t)*FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    142          
    143          #if !BL_FLASH_VERIFY_DISABLE
    144              bool verifyWrites = g_bootloaderContext.propertyInterface->store->verifyWrites;
   \   00000004   0x.... 0x....      LDR.W    R8,??DataTable8
   \   00000008   0xB087             SUB      SP,SP,#+28
   \   0000000A   0x4681             MOV      R9,R0
   \   0000000C   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000010   0x6900             LDR      R0,[R0, #+16]
   \   00000012   0x6B04             LDR      R4,[R0, #+48]
   \   00000014   0x460D             MOV      R5,R1
   \   00000016   0x08AE             LSRS     R6,R5,#+2
   \   00000018   0x00B6             LSLS     R6,R6,#+2
   \   0000001A   0x4692             MOV      R10,R2
   \   0000001C   0x1BAF             SUBS     R7,R5,R6
   \   0000001E   0xB104             CBZ.N    R4,??flash_mem_write_0
   \   00000020   0x2401             MOVS     R4,#+1
    145          #endif // BL_FLASH_VERIFY_DISABLE
    146          
    147              // Pre-fill word buffer with flash erased value.
    148          #if (FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE == 4)
    149              uint32_t extraData;
    150              extraData = (uint32_t)kFlashMemory_ErasedValue;
   \                     ??flash_mem_write_0: (+1)
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0x9004             STR      R0,[SP, #+16]
    151          #elif (FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE == 8)
    152              uint64_t extraData;
    153              extraData = (uint64_t)kFlashMemory_ErasedValue;
    154          #else
    155              #error "Untreated program unit size"
    156          #endif
    157              if (extraBytes)
   \   00000028   0xB12F             CBZ.N    R7,??flash_mem_write_1
    158              {
    159                  // Copy extra bytes to word buffer.
    160                  memcpy((uint8_t *)&extraData, &buffer[alignedLength], extraBytes);
   \   0000002A   0x463A             MOV      R2,R7
   \   0000002C   0xEB06 0x010A      ADD      R1,R6,R10
   \   00000030   0xA804             ADD      R0,SP,#+16
   \   00000032   0x.... 0x....      BL       __aeabi_memcpy
    161              }
    162          
    163              status_t status = kStatus_Success;
    164          
    165              lock_acquire();
   \                     ??flash_mem_write_1: (+1)
   \   00000036   0x.... 0x....      BL       lock_acquire
    166          
    167          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    168              // If a target flash location is in an execute-only protected segment, these program commands are not
    169              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    170              flash_execute_only_access_state_t access_state;
    171          
    172              uint32_t actualLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    173              status = flash_preprocess_execute_only_region(address, actualLength, &access_state);
   \   0000003A   0x4268             RSBS     R0,R5,#+0
   \   0000003C   0x0880             LSRS     R0,R0,#+2
   \   0000003E   0x0080             LSLS     R0,R0,#+2
   \   00000040   0x4241             RSBS     R1,R0,#+0
   \   00000042   0xAA03             ADD      R2,SP,#+12
   \   00000044   0x4648             MOV      R0,R9
   \   00000046   0x.... 0x....      BL       flash_preprocess_execute_only_region
   \   0000004A   0x0005             MOVS     R5,R0
    174              if (status != kStatus_Success)
   \   0000004C   0xD002             BEQ.N    ??flash_mem_write_2
    175              {
    176                  lock_release();
   \   0000004E   0x.... 0x....      BL       lock_release
   \   00000052   0xE03D             B.N      ??flash_mem_write_3
    177                  return status;
    178              }
    179          
    180          #if !BL_FLASH_VERIFY_DISABLE
    181              if (access_state != kFlashAccess_UnLimited)
   \                     ??flash_mem_write_2: (+1)
   \   00000054   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000058   0xB100             CBZ.N    R0,??flash_mem_write_4
    182              {
    183                  verifyWrites = false;
   \   0000005A   0x2400             MOVS     R4,#+0
    184              }
    185          #endif // BL_FLASH_VERIFY_DISABLE
    186          
    187          #endif  // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    188          
    189              // Program whole words from the user's buffer.
    190              if (alignedLength)
   \                     ??flash_mem_write_4: (+1)
   \   0000005C   0xEB06 0x0B09      ADD      R11,R6,R9
   \   00000060   0xB146             CBZ.N    R6,??flash_mem_write_5
    191              {
    192                  status = flash_program(&g_bootloaderContext.flashState, address, (uint32_t *)buffer, alignedLength);
   \   00000062   0x4633             MOV      R3,R6
   \   00000064   0x4652             MOV      R2,R10
   \   00000066   0x4649             MOV      R1,R9
   \   00000068   0xF108 0x0020      ADD      R0,R8,#+32
   \   0000006C   0x.... 0x....      BL       flash_program
   \   00000070   0x0005             MOVS     R5,R0
    193              }
    194              if ((status == kStatus_Success) && extraBytes)
   \   00000072   0xD108             BNE.N    ??flash_mem_write_6
   \                     ??flash_mem_write_5: (+1)
   \   00000074   0xB13F             CBZ.N    R7,??flash_mem_write_6
    195              {
    196                  // Program trailing word.
    197                  status = flash_program(&g_bootloaderContext.flashState, address + alignedLength, (uint32_t *)&extraData, sizeof(extraData));
   \   00000076   0x2304             MOVS     R3,#+4
   \   00000078   0xAA04             ADD      R2,SP,#+16
   \   0000007A   0x4659             MOV      R1,R11
   \   0000007C   0xF108 0x0020      ADD      R0,R8,#+32
   \   00000080   0x.... 0x....      BL       flash_program
   \   00000084   0x4605             MOV      R5,R0
    198              }
    199              lock_release();
   \                     ??flash_mem_write_6: (+1)
   \   00000086   0x.... 0x....      BL       lock_release
    200              if (status != kStatus_Success)
   \   0000008A   0xBB0D             CBNZ.N   R5,??flash_mem_write_3
    201              {
    202                  return status;
    203              }
    204          
    205          #if !BL_FLASH_VERIFY_DISABLE
    206          
    207              if (verifyWrites)
   \   0000008C   0xB2E4             UXTB     R4,R4
   \   0000008E   0xB30C             CBZ.N    R4,??flash_mem_write_7
    208              {
    209                  uint32_t failedAddress;
    210                  uint32_t  failedData;
    211          
    212                  lock_acquire();
   \   00000090   0x.... 0x....      BL       lock_acquire
    213                  if (alignedLength)
   \   00000094   0xB176             CBZ.N    R6,??flash_mem_write_8
    214                  {
    215                      status = flash_verify_program(&g_bootloaderContext.flashState,
    216                                          address, alignedLength, (uint8_t *)buffer,
    217                                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin,
    218                                          &failedAddress, &failedData);
   \   00000096   0xA805             ADD      R0,SP,#+20
   \   00000098   0x9002             STR      R0,[SP, #+8]
   \   0000009A   0x4653             MOV      R3,R10
   \   0000009C   0xA806             ADD      R0,SP,#+24
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0x4632             MOV      R2,R6
   \   000000A2   0x.... 0x....      BL       ?Subroutine0
    219                  }
   \                     ??CrossCallReturnLabel_0: (+1)
   \   000000A6   0x4649             MOV      R1,R9
   \   000000A8   0xF108 0x0020      ADD      R0,R8,#+32
   \   000000AC   0x.... 0x....      BL       flash_verify_program
   \   000000B0   0x0005             MOVS     R5,R0
    220                  if ((status == kStatus_Success) && extraBytes)
   \   000000B2   0xD10A             BNE.N    ??flash_mem_write_9
   \                     ??flash_mem_write_8: (+1)
   \   000000B4   0xB14F             CBZ.N    R7,??flash_mem_write_9
    221                  {
    222                      status = flash_verify_program(&g_bootloaderContext.flashState,
    223                                          address + alignedLength,
    224                                          sizeof(extraData), (uint8_t *)&extraData,
    225                                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin,
    226                                          &failedAddress, &failedData);
   \   000000B6   0x.... 0x....      BL       ?Subroutine1
    227                  }
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000000BA   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000BE   0x4659             MOV      R1,R11
   \   000000C0   0xF108 0x0020      ADD      R0,R8,#+32
   \   000000C4   0x.... 0x....      BL       flash_verify_program
   \   000000C8   0x4605             MOV      R5,R0
    228                  lock_release();
   \                     ??flash_mem_write_9: (+1)
   \   000000CA   0x.... 0x....      BL       lock_release
    229                  if (status != kStatus_Success)
   \   000000CE   0xB10D             CBZ.N    R5,??flash_mem_write_7
    230                  {
    231                      debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
    232                      return status;
   \                     ??flash_mem_write_3: (+1)
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0xE000             B.N      ??flash_mem_write_10
    233                  }
    234              }
    235          #endif // !BL_FLASH_VERIFY_DISABLE
    236          
    237              return kStatus_Success;
   \                     ??flash_mem_write_7: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_write_10: (+1)
   \   000000D6   0xB007             ADD      SP,SP,#+28
   \   000000D8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    238          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x6D80             LDR      R0,[R0, #+88]
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xA805             ADD      R0,SP,#+20
   \   00000002   0x9002             STR      R0,[SP, #+8]
   \   00000004   0xAB04             ADD      R3,SP,#+16
   \   00000006   0xA806             ADD      R0,SP,#+24
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x2204             MOVS     R2,#+4
   \   0000000C   0x4770             BX       LR
    239          
    240          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    241          status_t flash_mem_fill(uint32_t address, uint32_t length, uint32_t pattern)
    242          {
   \                     flash_mem_fill: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    243              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_fill().
    244              assert(length);
    245          
    246              // Align end of buffer to the next word. The pattern will be written to the entire last word.
    247              uint32_t alignedLength;
    248          
    249          #if !BL_FLASH_VERIFY_DISABLE
    250              bool verifyWrites = g_bootloaderContext.propertyInterface->store->verifyWrites;
   \   00000004   0x....             LDR.N    R5,??DataTable8
   \   00000006   0xB088             SUB      SP,SP,#+32
   \   00000008   0x4680             MOV      R8,R0
   \   0000000A   0x68A8             LDR      R0,[R5, #+8]
   \   0000000C   0x6900             LDR      R0,[R0, #+16]
   \   0000000E   0x6B06             LDR      R6,[R0, #+48]
   \   00000010   0xB106             CBZ.N    R6,??flash_mem_fill_0
   \   00000012   0x2601             MOVS     R6,#+1
    251          #endif // BL_FLASH_VERIFY_DISABLE
    252          
    253          #if (FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE == 4)
    254              uint32_t patternBuffer = pattern;
    255              alignedLength = ALIGN_UP(length, sizeof(uint32_t));
   \                     ??flash_mem_fill_0: (+1)
   \   00000014   0x4248             RSBS     R0,R1,#+0
   \   00000016   0x0880             LSRS     R0,R0,#+2
   \   00000018   0x9204             STR      R2,[SP, #+16]
   \   0000001A   0x0080             LSLS     R0,R0,#+2
   \   0000001C   0x4247             RSBS     R7,R0,#+0
    256          #elif (FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE == 8)
    257              uint64_t patternBuffer = pattern;
    258              patternBuffer <<= 32;
    259              patternBuffer += pattern;
    260              uint32_t extraBytes = 0;
    261              if ((length % FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE) > 4)
    262              {
    263                  alignedLength = ALIGN_UP(length, sizeof(uint64_t));
    264              }
    265              else
    266              {
    267                  alignedLength = ALIGN_DOWN(length, sizeof(uint64_t));
    268                  extraBytes = length - alignedLength;
    269              }
    270          #else
    271              #error "Untreated write-unit size"
    272          #endif
    273          
    274              status_t status;
    275          
    276          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    277              // If a target flash location is in an execute-only protected segment, these program commands are not
    278              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    279              flash_execute_only_access_state_t access_state;
    280          
    281              uint32_t actualLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    282              status = flash_preprocess_execute_only_region(address, actualLength, &access_state);
   \   0000001E   0xAA03             ADD      R2,SP,#+12
   \   00000020   0x4639             MOV      R1,R7
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       flash_preprocess_execute_only_region
   \   00000028   0x0004             MOVS     R4,R0
    283              if (status != kStatus_Success)
   \   0000002A   0xD12A             BNE.N    ??flash_mem_fill_1
    284              {
    285                  return status;
    286              }
    287          
    288          #if !BL_FLASH_VERIFY_DISABLE
    289              if (access_state != kFlashAccess_UnLimited)
   \   0000002C   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000030   0xB120             CBZ.N    R0,??flash_mem_fill_2
    290              {
    291                  verifyWrites = false;
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0xE002             B.N      ??flash_mem_fill_2
    292              }
    293          #endif // BL_FLASH_VERIFY_DISABLE
    294          
    295          #endif  // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    296          
    297              while (alignedLength)
    298              {
    299                  lock_acquire();
    300                  status = flash_program(&g_bootloaderContext.flashState, address, (uint32_t *)&patternBuffer, sizeof(patternBuffer));
    301                  lock_release();
    302                  if (status != kStatus_Success)
    303                  {
    304                      return status;
    305                  }
    306          
    307          #if !BL_FLASH_VERIFY_DISABLE
    308                  // Verify flash program
    309                  if (verifyWrites)
    310                  {
    311                      uint32_t failedAddress;
    312                      uint32_t  failedData;
    313          
    314                      lock_acquire();
    315                      status = flash_verify_program(&g_bootloaderContext.flashState,
    316                                        address, sizeof(patternBuffer), (uint8_t *)&patternBuffer,
    317                                        (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin,
    318                                        &failedAddress, &failedData);
    319                      lock_release();
    320                      if (status != kStatus_Success)
    321                      {
    322                          debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
    323                          return status;
    324                      }
    325                  }
    326          #endif // !BL_FLASH_VERIFY_DISABLE
    327          
    328                  address += sizeof(patternBuffer);
   \                     ??flash_mem_fill_3: (+1)
   \   00000036   0xF108 0x0804      ADD      R8,R8,#+4
    329                  alignedLength -= sizeof(patternBuffer);
   \   0000003A   0x1F3F             SUBS     R7,R7,#+4
   \                     ??flash_mem_fill_2: (+1)
   \   0000003C   0xB31F             CBZ.N    R7,??flash_mem_fill_4
   \   0000003E   0x.... 0x....      BL       lock_acquire
   \   00000042   0x2304             MOVS     R3,#+4
   \   00000044   0xAA04             ADD      R2,SP,#+16
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0xF105 0x0020      ADD      R0,R5,#+32
   \   0000004C   0x.... 0x....      BL       flash_program
   \   00000050   0x4604             MOV      R4,R0
   \   00000052   0x.... 0x....      BL       lock_release
   \   00000056   0xB9A4             CBNZ.N   R4,??flash_mem_fill_1
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD0EC             BEQ.N    ??flash_mem_fill_3
   \   0000005C   0x.... 0x....      BL       lock_acquire
   \   00000060   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000064   0x68A8             LDR      R0,[R5, #+8]
   \   00000066   0x6900             LDR      R0,[R0, #+16]
   \   00000068   0x6D80             LDR      R0,[R0, #+88]
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0x4641             MOV      R1,R8
   \   00000070   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000074   0x.... 0x....      BL       flash_verify_program
   \   00000078   0x4604             MOV      R4,R0
   \   0000007A   0x.... 0x....      BL       lock_release
   \   0000007E   0x2C00             CMP      R4,#+0
   \   00000080   0xD0D9             BEQ.N    ??flash_mem_fill_3
   \                     ??flash_mem_fill_1: (+1)
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0xE000             B.N      ??flash_mem_fill_5
    330              }
    331          
    332          #if (FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE == 8)
    333              if (extraBytes)
    334              {
    335                  uint64_t extraPatternBuffer = (uint32_t)kFlashMemory_ErasedValue;
    336                  extraPatternBuffer <<= 32;
    337                  extraPatternBuffer += pattern;
    338          
    339                  lock_acquire();
    340                  status = flash_program(&g_bootloaderContext.flashState, address, (uint32_t *)&extraPatternBuffer, sizeof(extraPatternBuffer));
    341                  lock_release();
    342                  if (status != kStatus_Success)
    343                  {
    344                      return status;
    345                  }
    346          
    347          #if !BL_FLASH_VERIFY_DISABLE
    348                  // Verify flash program
    349                  if (verifyWrites)
    350                  {
    351                      uint32_t failedAddress;
    352                      uint32_t  failedData;
    353          
    354                      lock_acquire();
    355                      status = flash_verify_program(&g_bootloaderContext.flashState,
    356                                        address, sizeof(extraPatternBuffer), (uint8_t *)&extraPatternBuffer,
    357                                        (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin,
    358                                        &failedAddress, &failedData);
    359                      lock_release();
    360                      if (status != kStatus_Success)
    361                      {
    362                          debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
    363                          return status;
    364                      }
    365                  }
    366          #endif // !BL_FLASH_VERIFY_DISABLE
    367              }
    368          #endif // !(FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE == 8)
    369          
    370              return kStatus_Success;
   \                     ??flash_mem_fill_4: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_fill_5: (+1)
   \   00000088   0xB008             ADD      SP,SP,#+32
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    371          }
    372          
    373          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    374          status_t flash_mem_erase(uint32_t address, uint32_t length)
    375          {
   \                     flash_mem_erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    376              status_t status;
    377          
    378              lock_acquire();
   \   00000006   0x.... 0x....      BL       lock_acquire
    379              status = flash_erase(&g_bootloaderContext.flashState, address, length, kFlashEraseKey);
   \   0000000A   0x....             LDR.N    R6,??DataTable8
   \   0000000C   0x....             LDR.N    R3,??DataTable8_1  ;; 0x6b65666b
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000016   0x.... 0x....      BL       flash_erase
   \   0000001A   0x4607             MOV      R7,R0
    380              lock_release();
   \   0000001C   0x.... 0x....      BL       lock_release
    381          
    382          #if !BL_FLASH_VERIFY_DISABLE
    383              if ((status == kStatus_Success) && (g_bootloaderContext.propertyInterface->store->verifyWrites))
   \   00000020   0xB997             CBNZ.N   R7,??flash_mem_erase_0
   \   00000022   0x68B0             LDR      R0,[R6, #+8]
   \   00000024   0x6900             LDR      R0,[R0, #+16]
   \   00000026   0x6B00             LDR      R0,[R0, #+48]
   \   00000028   0xB170             CBZ.N    R0,??flash_mem_erase_0
    384              {
    385                  lock_acquire();
   \   0000002A   0x.... 0x....      BL       lock_acquire
    386                  status = flash_verify_erase(&g_bootloaderContext.flashState, address, length,
    387                                              (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   0000002E   0x68B0             LDR      R0,[R6, #+8]
   \   00000030   0x6900             LDR      R0,[R0, #+16]
   \   00000032   0x6D83             LDR      R3,[R0, #+88]
   \   00000034   0xB2DB             UXTB     R3,R3
   \   00000036   0x462A             MOV      R2,R5
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0xF106 0x0020      ADD      R0,R6,#+32
   \   0000003E   0x.... 0x....      BL       flash_verify_erase
   \   00000042   0x4607             MOV      R7,R0
    388                  lock_release();
   \   00000044   0x.... 0x....      BL       lock_release
    389                  if (status != kStatus_Success)
    390                  {
    391                      debug_printf("Error: flash_verify_erase failed\r\n");
    392                      return status;
    393                 }
    394              }
    395          #endif // !BL_FLASH_VERIFY_DISABLE
    396          
    397              return status;
   \                     ??flash_mem_erase_0: (+1)
   \   00000048   0x4638             MOV      R0,R7
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    398          }
    399          
    400          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    401          status_t flash_mem_erase_all(void)
    402          {
   \                     flash_mem_erase_all: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    403              status_t status = kStatus_Success;
    404          
    405              // Decompose the the flash erase all into two region erases.
    406          #if BL_TARGET_FLASH
    407          
    408              reserved_region_t * reservedRegion =
    409                  &g_bootloaderContext.propertyInterface->store->reservedRegions[kProperty_FlashReservedRegionIndex];
   \   00000002   0x....             LDR.N    R6,??DataTable8
   \   00000004   0x68B0             LDR      R0,[R6, #+8]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0xF100 0x0460      ADD      R4,R0,#+96
   \   0000000C   0x2500             MOVS     R5,#+0
    410              bool isReservedRegionEmpty = (reservedRegion->startAddress == 0) && (reservedRegion->endAddress == 0);
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0xB921             CBNZ.N   R1,??flash_mem_erase_all_0
   \   00000012   0x6862             LDR      R2,[R4, #+4]
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0x4192             SBCS     R2,R2,R2
   \   00000018   0x0FD2             LSRS     R2,R2,#+31
   \   0000001A   0xE000             B.N      ??flash_mem_erase_all_1
   \                     ??flash_mem_erase_all_0: (+1)
   \   0000001C   0x2200             MOVS     R2,#+0
    411              const uint32_t eraseSize = g_bootloaderContext.propertyInterface->store->flashSectorSize;
   \                     ??flash_mem_erase_all_1: (+1)
   \   0000001E   0x6983             LDR      R3,[R0, #+24]
    412          
    413              if (g_bootloaderContext.propertyInterface->store->validateRegions && !isReservedRegionEmpty)
   \   00000020   0x6B40             LDR      R0,[R0, #+52]
   \   00000022   0xB1B8             CBZ.N    R0,??flash_mem_erase_all_2
   \   00000024   0xB9B2             CBNZ.N   R2,??flash_mem_erase_all_2
    414              {
    415                  // Erase the initial unreserved region, if any.
    416                  if (reservedRegion->startAddress  > 0)
   \   00000026   0x425F             RSBS     R7,R3,#+0
   \   00000028   0xB131             CBZ.N    R1,??flash_mem_erase_all_3
    417                  {
    418                      uint32_t length = ALIGN_DOWN(reservedRegion->startAddress, eraseSize);
   \   0000002A   0x4039             ANDS     R1,R7,R1
    419                      if (length > 0)
   \   0000002C   0xD004             BEQ.N    ??flash_mem_erase_all_3
    420                      {
    421                          status = flash_mem_erase(0, length);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       flash_mem_erase
   \   00000034   0x0005             MOVS     R5,R0
    422                      }
    423                  }
    424          
    425                  // Erase the final unreserved region, if any.
    426                  if (status == kStatus_Success)
   \   00000036   0xD12D             BNE.N    ??flash_mem_erase_all_4
    427                  {
    428                      memory_map_entry_t * map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
   \                     ??flash_mem_erase_all_3: (+1)
   \   00000038   0x6871             LDR      R1,[R6, #+4]
    429                      uint32_t start = ALIGN_UP(reservedRegion->endAddress, eraseSize);
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
    430                      if (start < map->endAddress)
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0x4240             RSBS     R0,R0,#+0
   \   00000040   0x4038             ANDS     R0,R7,R0
   \   00000042   0x4240             RSBS     R0,R0,#+0
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD225             BCS.N    ??flash_mem_erase_all_4
    431                      {
    432                          status = flash_mem_erase(start, (map->endAddress + 1) - start);
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0x1A09             SUBS     R1,R1,R0
   \   0000004C   0x.... 0x....      BL       flash_mem_erase
   \   00000050   0x4605             MOV      R5,R0
   \   00000052   0xE01F             B.N      ??flash_mem_erase_all_4
    433                      }
    434                  }
    435          
    436                  return status;
    437              }
    438          
    439          #endif // BL_TARGET_FLASH
    440          
    441              // Do full erase and verify.
    442          
    443              lock_acquire();
   \                     ??flash_mem_erase_all_2: (+1)
   \   00000054   0x.... 0x....      BL       lock_acquire
    444              status = flash_erase_all(&g_bootloaderContext.flashState, kFlashEraseKey);
   \   00000058   0x....             LDR.N    R1,??DataTable8_1  ;; 0x6b65666b
   \   0000005A   0xF106 0x0020      ADD      R0,R6,#+32
   \   0000005E   0x.... 0x....      BL       flash_erase_all
   \   00000062   0x4605             MOV      R5,R0
    445              lock_release();
   \   00000064   0x.... 0x....      BL       lock_release
    446          
    447          #if !BL_FLASH_VERIFY_DISABLE
    448              if ((status == kStatus_Success) && (g_bootloaderContext.propertyInterface->store->verifyWrites))
   \   00000068   0xB9A5             CBNZ.N   R5,??flash_mem_erase_all_4
   \   0000006A   0x68B0             LDR      R0,[R6, #+8]
   \   0000006C   0x6900             LDR      R0,[R0, #+16]
   \   0000006E   0x6B00             LDR      R0,[R0, #+48]
   \   00000070   0xB168             CBZ.N    R0,??flash_mem_erase_all_5
    449              {
    450                  lock_acquire();
   \   00000072   0x.... 0x....      BL       lock_acquire
    451                  status = flash_verify_erase_all(&g_bootloaderContext.flashState,
    452                                                  (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   00000076   0x68B0             LDR      R0,[R6, #+8]
   \   00000078   0x6900             LDR      R0,[R0, #+16]
   \   0000007A   0x6D81             LDR      R1,[R0, #+88]
   \   0000007C   0xB2C9             UXTB     R1,R1
   \   0000007E   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000082   0x.... 0x....      BL       flash_verify_erase_all
   \   00000086   0x4605             MOV      R5,R0
    453                  lock_release();
   \   00000088   0x.... 0x....      BL       lock_release
    454                  if (status != kStatus_Success)
   \   0000008C   0xB915             CBNZ.N   R5,??flash_mem_erase_all_4
    455                  {
    456                      debug_printf("Error: flash_verify_erase_all failed\r\n");
    457                      return status;
    458                  }
    459              }
    460          #endif // !BL_FLASH_VERIFY_DISABLE
    461          
    462          
    463          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    464              if (status == kStatus_Success)
    465              {
    466                  isFlashRegionUnlocked = true;
   \                     ??flash_mem_erase_all_5: (+1)
   \   0000008E   0x....             LDR.N    R1,??DataTable8_2
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    467              }
    468          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    469          
    470          
    471          
    472              return status;
   \                     ??flash_mem_erase_all_4: (+1)
   \   00000094   0x4628             MOV      R0,R5
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    473          }
    474          
    475          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    476          status_t flash_mem_erase_all_unsecure(void)
    477          {
   \                     flash_mem_erase_all_unsecure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    478              status_t status;
    479          
    480              lock_acquire();
   \   00000002   0x.... 0x....      BL       lock_acquire
    481              status = flash_erase_all_unsecure(&g_bootloaderContext.flashState, kFlashEraseKey);
   \   00000006   0x....             LDR.N    R1,??DataTable8_1  ;; 0x6b65666b
   \   00000008   0x....             LDR.N    R0,??DataTable8_3
   \   0000000A   0x.... 0x....      BL       flash_erase_all_unsecure
   \   0000000E   0x4604             MOV      R4,R0
    482              lock_release();
   \   00000010   0x.... 0x....      BL       lock_release
    483          
    484              return status;
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    485          }
    486          
    487          //! @brief check if a flash region is in an XA controlled region or contains an XA controlled region.
    488          //         and try to open flash program state by calling verify_erase_all command if needed.

   \                                 In section .text, align 2, keep-with-next
    489          status_t flash_preprocess_execute_only_region(uint32_t address, uint32_t length, flash_execute_only_access_state_t *state)
    490          {
   \                     flash_preprocess_execute_only_region: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4615             MOV      R5,R2
    491              status_t status = kStatus_Success;
    492              *state = kFlashAccess_UnLimited;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x702A             STRB     R2,[R5, #+0]
    493          
    494           #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    495              // If a target flash location is in an execute-only protected segment, these program commands are not
    496              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    497              flash_execute_only_access_state_t access_state;
    498          
    499              status = flash_is_execute_only(&g_bootloaderContext.flashState, address, length,  &access_state);
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x....             LDR.N    R4,??DataTable8
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000014   0x.... 0x....      BL       flash_is_execute_only
    500              if (status != kStatus_Success)
   \   00000018   0xB9A8             CBNZ.N   R0,??flash_preprocess_execute_only_region_0
    501              {
    502                  return status;
    503              }
    504          
    505              *state = access_state;
   \   0000001A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000001E   0x7029             STRB     R1,[R5, #+0]
    506          
    507              if ( (access_state != kFlashAccess_UnLimited) && (!isFlashRegionUnlocked) )
   \   00000020   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000024   0xB179             CBZ.N    R1,??flash_preprocess_execute_only_region_0
   \   00000026   0x....             LDR.N    R5,??DataTable8_2
   \   00000028   0x7829             LDRB     R1,[R5, #+0]
   \   0000002A   0xB961             CBNZ.N   R1,??flash_preprocess_execute_only_region_0
    508              {
    509                  status = flash_verify_erase_all(&g_bootloaderContext.flashState,
    510                                                  (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0x6900             LDR      R0,[R0, #+16]
   \   00000030   0x6D81             LDR      R1,[R0, #+88]
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000038   0x.... 0x....      BL       flash_verify_erase_all
    511                  if (status != kStatus_Success)
   \   0000003C   0xB108             CBZ.N    R0,??flash_preprocess_execute_only_region_1
    512                  {
    513                      return kStatus_FlashRegionExecuteOnly;
   \   0000003E   0x206C             MOVS     R0,#+108
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}
    514                  }
    515          
    516                  isFlashRegionUnlocked = true;
   \                     ??flash_preprocess_execute_only_region_1: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x7029             STRB     R1,[R5, #+0]
    517              }
    518          #endif  // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    519              return status;
   \                     ??flash_preprocess_execute_only_region_0: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    520          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x6B65666B         DC32     0x6b65666b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     isFlashRegionUnlocked

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20
    521          
    522          ////////////////////////////////////////////////////////////////////////////////
    523          // EOF
    524          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   flash_mem_erase
        24   -> flash_erase
        24   -> flash_verify_erase
        24   -> lock_acquire
        24   -> lock_release
      24   flash_mem_erase_all
        24   -> flash_erase_all
        24   -> flash_mem_erase
        24   -> flash_verify_erase_all
        24   -> lock_acquire
        24   -> lock_release
       8   flash_mem_erase_all_unsecure
         8   -> flash_erase_all_unsecure
         8   -> lock_acquire
         8   -> lock_release
      56   flash_mem_fill
        56   -> flash_preprocess_execute_only_region
        56   -> flash_program
        56   -> flash_verify_program
        56   -> lock_acquire
        56   -> lock_release
      16   flash_mem_init
        16   -> flash_get_property
      24   flash_mem_read
        24   -> flash_is_execute_only
        24   -> normal_mem_read
      64   flash_mem_write
        64   -> __aeabi_memcpy
        64   -> flash_preprocess_execute_only_region
        64   -> flash_program
        64   -> flash_verify_program
        64   -> lock_acquire
        64   -> lock_release
      16   flash_preprocess_execute_only_region
        16   -> flash_is_execute_only
        16   -> flash_verify_erase_all


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
      14  ?Subroutine0
      14  ?Subroutine1
      76  flash_mem_erase
     152  flash_mem_erase_all
      24  flash_mem_erase_all_unsecure
     142  flash_mem_fill
      44  flash_mem_init
      60  flash_mem_read
     220  flash_mem_write
      72  flash_preprocess_execute_only_region
      24  g_flashMemoryInterface
       1  isFlashRegionUnlocked

 
   1 byte  in section .bss
  24 bytes in section .rodata
 834 bytes in section .text
 
 834 bytes of CODE  memory
  24 bytes of CONST memory
   1 byte  of DATA  memory

Errors: none
Warnings: none
