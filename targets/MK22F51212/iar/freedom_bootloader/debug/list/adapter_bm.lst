###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:45:50
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\adapter\sources\bm\adapter_bm.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\adapter\sources\bm\adapter_bm.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\adapter_bm.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\adapter_bm.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\adapter\sources\bm\adapter_bm.c
      1          /**HEADER********************************************************************
      2          * 
      3          * Copyright (c) 2013- 2014 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          *
      7          ***************************************************************************  
      8          *
      9          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     10          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     11          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     12          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     13          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     14          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     15          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     16          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     17          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     18          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     19          * THE POSSIBILITY OF SUCH DAMAGE.
     20          *
     21          **************************************************************************
     22          *
     23          * $FileName: osadapter_bm.c$
     24          * $Version : 
     25          * $Date    : 
     26          *
     27          * Comments:
     28          *
     29          * @brief The file includes the implementation of BM of OS adapter.
     30          * 
     31          *****************************************************************************/ 
     32          #include "adapter_cfg.h"
     33          #include "adapter_types.h"
     34          
     35          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM)
     36          #include "types.h"
     37          #include "adapter_bm.h"
     38          #include "bmevent.h"
     39          #include "bmmsgq.h"
     40          #include "poll.h"
     41          #include "bmsem.h"
     42          
     43          extern void delay(uint32_t delay);
     44          
     45          typedef struct registered_info_struct
     46          {
     47             poll_pointer_t   func;
     48             void*            param;
     49          } registered_info_struct_t;
     50          

   \                                 In section .bss, align 4
     51          registered_info_struct_t   registered_function[POLL_MAX_NUM];
   \                     registered_function:
   \   00000000                      DS8 40
     52          

   \                                 In section .text, align 2, keep-with-next
     53          uint32_t OS_Task_create(task_start_t pstart, void* param, uint32_t pri, uint32_t stack_size, char* task_name, void* opt)
     54          {
   \                     OS_Task_create: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     55              uint8_t index = POLL_register(pstart, param);
   \   00000006   0x.... 0x....      BL       POLL_register
     56              if (index != (uint8_t)POLL_REGISTER_FAIL)
   \   0000000A   0x28FF             CMP      R0,#+255
   \   0000000C   0xD006             BEQ.N    ??OS_Task_create_0
     57              {
     58                  registered_function[index].func = pstart;
   \   0000000E   0x....             LDR.N    R1,??DataTable0
   \   00000010   0xF841 0x4030      STR      R4,[R1, R0, LSL #+3]
     59                  registered_function[index].param = param;
   \   00000014   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   \   00000018   0x604D             STR      R5,[R1, #+4]
     60                  return index;
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
     61              }
     62              return (uint32_t)OS_TASK_ERROR;
   \                     ??OS_Task_create_0: (+1)
   \   0000001C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     63          }
     64          

   \                                 In section .text, align 4, keep-with-next
     65          uint32_t OS_Task_delete(uint32_t task_id)
     66          {
   \                     OS_Task_delete: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     67              uint8_t index = task_id;
   \   00000002   0xB2C4             UXTB     R4,R0
     68              poll_pointer_t p_func = NULL;
     69              void*          param  = NULL;
     70              
     71              if(index >= POLL_MAX_NUM)
   \   00000004   0x2C05             CMP      R4,#+5
   \   00000006   0xDA11             BGE.N    ??OS_Task_delete_0
     72              {
     73                  return (uint32_t)OS_TASK_ERROR;
     74              }
     75              
     76              p_func = registered_function[index].func;
     77              param = registered_function[index].param;
     78          
     79              if (POLL_unregister(p_func, param) != (uint8_t)POLL_NOT_FOUND)
   \   00000008   0x4D07             LDR.N    R5,??OS_Task_delete_1
   \   0000000A   0xF855 0x0034      LDR      R0,[R5, R4, LSL #+3]
   \   0000000E   0xEB05 0x06C4      ADD      R6,R5,R4, LSL #+3
   \   00000012   0x6871             LDR      R1,[R6, #+4]
   \   00000014   0x.... 0x....      BL       POLL_unregister
   \   00000018   0x28FE             CMP      R0,#+254
   \   0000001A   0xD007             BEQ.N    ??OS_Task_delete_0
     80              {
     81                  registered_function[index].param = NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
     82                  registered_function[index].func = NULL;
   \   0000001E   0xF845 0x0034      STR      R0,[R5, R4, LSL #+3]
   \   00000022   0x6070             STR      R0,[R6, #+4]
     83                  return OS_TASK_OK;
   \   00000024   0xBD70             POP      {R4-R6,PC}
   \   00000026   0xBF00             Nop      
   \                     ??OS_Task_delete_1:
   \   00000028   0x........         DC32     registered_function
     84              }
     85              else
     86              {
     87                  return (uint32_t)OS_TASK_ERROR;
   \                     ??OS_Task_delete_0: (+1)
   \   0000002C                      REQUIRE ?Subroutine0
   \   0000002C                      ;; // Fall through to label ?Subroutine0
     88              }
     89          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF04F 0x30FF      MOV      R0,#-1
   \   00000004   0xBD70             POP      {R4-R6,PC}       ;; return
     90          

   \                                 In section .text, align 2, keep-with-next
     91          uint32_t OS_Task_suspend(uint32_t task_id)
     92          {
     93              return (uint32_t)OS_TASK_OK;
   \                     OS_Task_suspend: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          uint32_t OS_Task_resume(uint32_t task_id)
     97          {
     98              return (uint32_t)OS_TASK_OK;
   \                     OS_Task_resume: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          os_event_handle OS_Event_create(uint32_t flag)
    102          {
   \                     OS_Event_create: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    103              bm_event_struct_t *event;
    104              event = (bm_event_struct_t*)BM_mem_alloc_word_aligned(sizeof(bm_event_struct_t));
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0x.... 0x....      BL       BM_mem_alloc_word_aligned
   \   00000008   0x0004             MOVS     R4,R0
    105              if (event == NULL)
   \   0000000A   0xD006             BEQ.N    ??OS_Event_create_0
    106              {
    107                  return NULL;
    108              }
    109              
    110              if (_bm_event_init(event) != BM_EVENT_OK)
   \   0000000C   0x.... 0x....      BL       _bm_event_init
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xD002             BEQ.N    ??OS_Event_create_1
    111              {
    112                  BM_mem_free((void*)event);
   \   00000016   0x.... 0x....      BL       BM_mem_free
    113                  return NULL;
   \                     ??OS_Event_create_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
    114              }
    115              return (os_event_handle)event;
   \                     ??OS_Event_create_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    116          }
    117          

   \                                 In section .text, align 2, keep-with-next
    118          uint32_t OS_Event_destroy(os_event_handle handle)
    119          {
   \                     OS_Event_destroy: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    120              if (NULL == handle)
   \   00000002   0xB910             CBNZ.N   R0,??OS_Event_destroy_0
    121                  return (uint32_t)OS_EVENT_ERROR;
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0xBD02             POP      {R1,PC}
    122              BM_mem_free((void*)handle);
   \                     ??OS_Event_destroy_0: (+1)
   \   0000000A   0x.... 0x....      BL       BM_mem_free
    123              return (uint32_t)OS_EVENT_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    124          }
    125          

   \                                 In section .text, align 2, keep-with-next
    126          uint32_t OS_Event_check_bit(os_event_handle handle, uint32_t bitmask)
    127          {
    128              return (((bm_event_struct_t*)handle)->value & bitmask);
   \                     OS_Event_check_bit: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x4008             ANDS     R0,R1,R0
   \   00000004   0x4770             BX       LR               ;; return
    129          }
    130          

   \                                 In section .text, align 2, keep-with-next
    131          uint32_t OS_Event_get_value(os_event_handle handle)
    132          {
    133                  return ((bm_event_struct_t*)handle)->value;
   \                     OS_Event_get_value: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x4770             BX       LR               ;; return
    134          }
    135          #if 0
    136          uint32_t OS_Event_set(os_event_handle handle, uint32_t bitmask)
    137          {
    138              LWEVENT_STRUCT *event = (LWEVENT_STRUCT*)handle;
    139              if (_lwevent_set(event, bitmask) != MQX_OK)
    140              {
    141                  return OS_EVENT_ERROR;
    142              }
    143              return OS_EVENT_OK;
    144          }
    145          
    146          
    147          uint32_t OS_Event_clear(os_event_handle handle, uint32_t bitmask)
    148          {
    149              LWEVENT_STRUCT *event = (LWEVENT_STRUCT*)handle;
    150              if(_lwevent_clear(event, bitmask) != MQX_OK)
    151              {
    152                  return OS_EVENT_ERROR;
    153              }
    154              return OS_EVENT_OK;
    155          }
    156          
    157          #endif

   \                                 In section .text, align 2, keep-with-next
    158          uint32_t OS_Event_wait(os_event_handle handle, uint32_t bitmask, uint32_t flag, uint32_t timeout)
    159          {
   \                     OS_Event_wait: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461F             MOV      R7,R3
    160              bm_event_struct_t *event = (bm_event_struct_t*)handle;
    161              uint32_t ret;
    162              uint32_t wait_ticket = timeout * 10;
   \   00000008   0x200A             MOVS     R0,#+10
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0xFB00 0xF507      MUL      R5,R0,R7
   \   00000010   0x4688             MOV      R8,R1
    163              
    164              ret = _bm_event_wait_ticks(event, bitmask, flag, timeout);
    165              
    166              if(BM_EVENT_SET == ret)
   \   00000012   0xB29B             UXTH     R3,R3
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _bm_event_wait_ticks
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD00D             BEQ.N    ??OS_Event_wait_0
    167              {
    168                  return OS_EVENT_OK;
    169              }
    170          
    171              while (wait_ticket--)
   \                     ??OS_Event_wait_1: (+1)
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x1E45             SUBS     R5,R0,#+1
   \   00000024   0xB160             CBZ.N    R0,??OS_Event_wait_2
    172              {
    173                  delay(1);
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       delay
    174                  ret = _bm_event_wait_ticks(event, bitmask, flag, timeout);
    175                      
    176                  if(BM_EVENT_SET == ret)
   \   0000002C   0xB2BB             UXTH     R3,R7
   \   0000002E   0xB2F2             UXTB     R2,R6
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _bm_event_wait_ticks
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD1F1             BNE.N    ??OS_Event_wait_1
    177                  {
    178                      return (uint32_t)OS_EVENT_OK;
   \                     ??OS_Event_wait_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE001             B.N      ??OS_Event_wait_3
    179                  }
    180              }
    181              return (uint32_t)OS_EVENT_TIMEOUT;
   \                     ??OS_Event_wait_2: (+1)
   \   00000040   0xF06F 0x0001      MVN      R0,#+1
   \                     ??OS_Event_wait_3: (+1)
   \   00000044   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    182          }
    183          
    184          #if 0
    185          os_msgq_handle OS_MsgQ_create(uint32_t max_msg_number, uint32_t msg_size)
    186          {
    187              void* msgq;
    188              uint32_t size = sizeof(LWMSGQ_STRUCT) + max_msg_number * msg_size + 4;
    189              
    190              msgq = _mem_alloc_system_zero(size);
    191              if (msgq == NULL)
    192              {
    193                  return NULL;
    194              }
    195          
    196              size = (msg_size - 1) / sizeof(uint32_t) + 1;
    197              if (_lwmsgq_init(msgq, max_msg_number, size) != MQX_OK)
    198              {
    199                  _mem_free(msgq);
    200                  return NULL;
    201              }
    202                 
    203              return (os_msgq_handle)msgq;
    204          }
    205          #endif
    206          

   \                                 In section .text, align 2, keep-with-next
    207          uint32_t OS_MsgQ_send(os_msgq_handle msgq, void* msg, uint32_t flag)
    208          {
   \                     OS_MsgQ_send: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    209              if (BM_MSGQ_OK != _bm_msgq_send((bm_msgq_handle)msgq, (int32_t *) msg))
   \   00000002   0x.... 0x....      BL       _bm_msgq_send
   \   00000006   0x....             B.N      ?Subroutine3
    210              {
    211                  return (uint32_t)OS_MSGQ_ERROR;
    212              }
    213              return (uint32_t)OS_MSGQ_OK;
    214          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xB108             CBZ.N    R0,??Subroutine3_0
   \   00000002   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??Subroutine3_0: (+1)
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    215          

   \                                 In section .text, align 2, keep-with-next
    216          uint32_t OS_MsgQ_recv(os_msgq_handle msgq, void* msg, uint32_t flag, uint32_t timeout)
    217          {
   \                     OS_MsgQ_recv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    218              if (BM_MSGQ_OK != _bm_msgq_receive((bm_msgq_handle)msgq, (int32_t *) msg))
   \   00000002   0x.... 0x....      BL       _bm_msgq_receive
   \   00000006                      REQUIRE ?Subroutine3
   \   00000006                      ;; // Fall through to label ?Subroutine3
    219              {
    220                  return (uint32_t)OS_MSGQ_ERROR;
    221              }
    222              return (uint32_t)OS_MSGQ_OK;
    223          }
    224          
    225          #if 0
    226          uint32_t OS_MsgQ_destroy(os_msgq_handle msgq)
    227          {
    228              _mem_free(msgq);
    229              return OS_MSGQ_OK;
    230          }
    231          #endif

   \                                 In section .text, align 2, keep-with-next
    232          uint32_t OS_MsgQ_Is_Empty(os_msgq_handle msgq, void* msg)
    233          {
   \                     OS_MsgQ_Is_Empty: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    234            uint32_t ret;
    235          
    236              ret = BMMSGQ_IS_EMPTY(msgq);
   \   00000002   0x6942             LDR      R2,[R0, #+20]
   \   00000004   0xB912             CBNZ.N   R2,??OS_MsgQ_Is_Empty_0
   \   00000006   0x2401             MOVS     R4,#+1
    237            if(!ret)
    238            {
    239              if (BM_MSGQ_OK != _bm_msgq_receive((bm_msgq_handle)msgq, (int32_t *) msg))
    240              {
    241                      return (uint32_t)OS_MSGQ_ERROR;
    242              }
    243            }
    244            return ret;
   \                     ??OS_MsgQ_Is_Empty_1: (+1)
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
   \                     ??OS_MsgQ_Is_Empty_0: (+1)
   \   0000000C   0x.... 0x....      BL       _bm_msgq_receive
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD0F8             BEQ.N    ??OS_MsgQ_Is_Empty_1
   \   00000016   0x....             B.N      ?Subroutine2
    245          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF04F 0x30FF      MOV      R0,#-1
   \   00000004   0xBD10             POP      {R4,PC}
    246          

   \                                 In section .text, align 2, keep-with-next
    247          os_mutex_handle OS_Mutex_create()
    248          {
    249              return (os_mutex_handle)(0x0000FFFF);
   \                     OS_Mutex_create: (+1)
   \   00000000   0x....             B.N      ?Subroutine1
    250          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000004   0x4770             BX       LR               ;; return
    251          

   \                                 In section .text, align 2, keep-with-next
    252          uint32_t OS_Mutex_lock(os_mutex_handle mutex)
    253          {
    254              return OS_MUTEX_OK;
   \                     OS_Mutex_lock: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    255          }
    256          

   \                                 In section .text, align 2, keep-with-next
    257          uint32_t OS_Mutex_unlock(os_mutex_handle mutex)
    258          {
    259              return OS_MUTEX_OK;
   \                     OS_Mutex_unlock: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    260          }
    261          

   \                                 In section .text, align 2, keep-with-next
    262          uint32_t OS_Mutex_destroy(os_mutex_handle mutex)
    263          {
    264              return OS_MUTEX_OK;
   \                     OS_Mutex_destroy: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    265          }
    266          

   \                                 In section .text, align 2, keep-with-next
    267          os_gpio_handle OS_Gpio_init(uint32_t id, uint32_t dir, uint32_t value)
   \                     OS_Gpio_init: (+1)
   \   00000000   0xBF00             Nop      
    268          {
    269              return (os_gpio_handle)(0x0000FFFF);
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    270          }
    271          

   \                                 In section .text, align 2, keep-with-next
    272          uint32_t OS_Gpio_set_functionality(os_gpio_handle handle, uint32_t function)
    273          {
    274              return OS_GPIO_OK;
   \                     OS_Gpio_set_functionality: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          uint32_t OS_Gpio_set_value(os_gpio_handle handle, uint32_t value)
    278          {
    279              return OS_GPIO_OK;
   \                     OS_Gpio_set_value: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    280          }
    281          

   \                                 In section .text, align 2, keep-with-next
    282          uint32_t OS_Gpio_deinit(os_gpio_handle handle)
    283          {
    284              return OS_GPIO_OK;
   \                     OS_Gpio_deinit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    285          }
    286          

   \                                 In section .text, align 2, keep-with-next
    287          os_sem_handle OS_Sem_create(int32_t initial_number)
    288          {
   \                     OS_Sem_create: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    289              bm_sem_struct_t* sem = NULL;
    290              sem = (bm_sem_struct_t*)BM_mem_alloc_word_aligned(sizeof(bm_sem_struct_t));
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       BM_mem_alloc_word_aligned
   \   0000000A   0x0005             MOVS     R5,R0
    291              if (sem == NULL)
   \   0000000C   0xD007             BEQ.N    ??OS_Sem_create_0
    292              {
    293                  return NULL;
    294              }
    295              if (_bm_sem_create(sem, initial_number) != BM_SEM_OK)
   \   0000000E   0x4621             MOV      R1,R4
   \   00000010   0x.... 0x....      BL       _bm_sem_create
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xD002             BEQ.N    ??OS_Sem_create_1
    296              {
    297                  BM_mem_free(sem);
   \   0000001A   0x.... 0x....      BL       BM_mem_free
    298                  return NULL;
   \                     ??OS_Sem_create_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
    299              }
    300              return (os_sem_handle)sem;
   \                     ??OS_Sem_create_1: (+1)
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          uint32_t OS_Sem_wait(os_sem_handle handle, uint32_t timeout)
    304          {
   \                     OS_Sem_wait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    305              bm_sem_struct_t* sem = (bm_sem_struct_t*)handle;
    306              uint32_t ret;
    307              uint32_t wait_ticket = timeout * 10;
   \   00000006   0x200A             MOVS     R0,#+10
   \   00000008   0xFB00 0xF605      MUL      R6,R0,R5
    308              
    309              ret = _bm_sem_wait_ticks(sem, timeout);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _bm_sem_wait_ticks
    310              if (BM_SEM_OK == ret)
   \   00000012   0xB170             CBZ.N    R0,??OS_Sem_wait_0
    311              {
    312                  return (uint32_t)OS_SEM_OK;
    313              }
    314              else if (BM_SEM_INVALID == ret)
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD100             BNE.N    ??OS_Sem_wait_1
    315              {
    316                  return (uint32_t)OS_SEM_ERROR;
   \   00000018   0x....             B.N      ?Subroutine0
    317              }
    318          
    319              while (wait_ticket--)
   \                     ??OS_Sem_wait_1: (+1)
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x1E46             SUBS     R6,R0,#+1
   \   0000001E   0xB150             CBZ.N    R0,??OS_Sem_wait_2
    320              {
    321                  delay(1);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       delay
    322                  ret = _bm_sem_wait_ticks(sem, timeout);
    323                      
    324                  if(BM_SEM_OK == ret)
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _bm_sem_wait_ticks
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??OS_Sem_wait_1
    325                  {
    326                      return (uint32_t)OS_SEM_OK;
   \                     ??OS_Sem_wait_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD70             POP      {R4-R6,PC}
    327                  }
    328              }
    329              return (uint32_t)OS_SEM_TIMEOUT;
   \                     ??OS_Sem_wait_2: (+1)
   \   00000036   0xF06F 0x0001      MVN      R0,#+1
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    330          }
    331          

   \                                 In section .text, align 2, keep-with-next
    332          uint32_t OS_Sem_destroy(os_sem_handle handle)
    333          {
   \                     OS_Sem_destroy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    334              uint32_t result = _bm_sem_destroy((bm_sem_struct_t*)handle);
    335              if (result == BM_SEM_OK)
   \   00000004   0x.... 0x....      BL       _bm_sem_destroy
   \   00000008   0xB920             CBNZ.N   R0,??OS_Sem_destroy_0
    336              {
    337                  BM_mem_free(handle);
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       BM_mem_free
    338                  return (uint32_t)OS_SEM_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD10             POP      {R4,PC}
    339              }
    340              else
    341              {
    342                  return (uint32_t)OS_SEM_ERROR;
   \                     ??OS_Sem_destroy_0: (+1)
   \   00000014                      REQUIRE ?Subroutine2
   \   00000014                      ;; // Fall through to label ?Subroutine2
    343              }
    344          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     registered_function
    345          
    346          #endif
    347          
    348          
    349          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   OS_Event_check_bit
       8   OS_Event_create
         8   -> BM_mem_alloc_word_aligned
         8   -> BM_mem_free
         8   -> _bm_event_init
       8   OS_Event_destroy
         8   -> BM_mem_free
       0   OS_Event_get_value
      24   OS_Event_wait
        24   -> _bm_event_wait_ticks
        24   -> delay
       0   OS_Gpio_deinit
       0   OS_Gpio_init
       0   OS_Gpio_set_functionality
       0   OS_Gpio_set_value
       8   OS_MsgQ_Is_Empty
         8   -> _bm_msgq_receive
       8   OS_MsgQ_recv
         8   -> _bm_msgq_receive
       8   OS_MsgQ_send
         8   -> _bm_msgq_send
       0   OS_Mutex_create
       0   OS_Mutex_destroy
       0   OS_Mutex_lock
       0   OS_Mutex_unlock
      16   OS_Sem_create
        16   -> BM_mem_alloc_word_aligned
        16   -> BM_mem_free
        16   -> _bm_sem_create
       8   OS_Sem_destroy
         8   -> BM_mem_free
         8   -> _bm_sem_destroy
      16   OS_Sem_wait
        16   -> _bm_sem_wait_ticks
        16   -> delay
      16   OS_Task_create
        16   -> POLL_register
      16   OS_Task_delete
        16   -> POLL_unregister
       0   OS_Task_resume
       0   OS_Task_suspend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       8  ?Subroutine3
       6  OS_Event_check_bit
      30  OS_Event_create
      18  OS_Event_destroy
       4  OS_Event_get_value
      72  OS_Event_wait
       4  OS_Gpio_deinit
       2  OS_Gpio_init
       4  OS_Gpio_set_functionality
       4  OS_Gpio_set_value
      24  OS_MsgQ_Is_Empty
       6  OS_MsgQ_recv
       8  OS_MsgQ_send
       2  OS_Mutex_create
       4  OS_Mutex_destroy
       4  OS_Mutex_lock
       4  OS_Mutex_unlock
      34  OS_Sem_create
      20  OS_Sem_destroy
      60  OS_Sem_wait
      34  OS_Task_create
      44  OS_Task_delete
       4  OS_Task_resume
       4  OS_Task_suspend
      40  registered_function

 
  40 bytes in section .bss
 426 bytes in section .text
 
 426 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
