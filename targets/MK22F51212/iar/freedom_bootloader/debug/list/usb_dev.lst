###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:46
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\usb_dev.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\usb_dev.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_dev.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_dev.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\usb_dev.c
      1          /**HEADER********************************************************************
      2          * 
      3          * Copyright (c) 2008, 2013 - 2014 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          * Copyright (c) 1989-2008 ARC International;
      7          * All Rights Reserved
      8          *
      9          *************************************************************************** 
     10          *
     11          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     12          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     13          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     14          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     15          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     16          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     17          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     18          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     19          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     20          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     21          * THE POSSIBILITY OF SUCH DAMAGE.
     22          *
     23          **************************************************************************
     24          *
     25          * $FileName: usb_dev.c$
     26          * $Version : 
     27          * $Date    : 
     28          *
     29          * Comments:
     30          *
     31          *  This file contains the main USB device API functions that will be 
     32          *  used by most applications.
     33          *                                                               
     34          *END*********************************************************************/
     35          #include "usb_device_config.h"
     36          #if USBCFG_DEV_KHCI || USBCFG_DEV_EHCI
     37          #include "usb.h"
     38          #include "usb_device_stack_interface.h"
     39          
     40          #define USBCFG_DEV_USE_TASK                   (0)
     41          #define USBCFG_DEV_SERVICE_MSG_CNT            (8)
     42          
     43          #include "usb_dev.h"
     44          #include "khci_dev_misc.h"
     45          #ifdef USBCFG_OTG
     46          #include "usb_otg_dev_api.h"
     47          #endif
     48          
     49          #if ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)))
     50              #if defined( __ICCARM__ )
     51                  #pragma data_alignment=32

   \                                 In section .noinit, align 32
     52                  __no_init usb_dev_data_t g_usb_dev_data[USBCFG_DEV_NUM];
   \                     g_usb_dev_data:
   \   00000000                      DS8 96
     53              #elif defined (__CC_ARM) || defined(__GNUC__)
     54                  __attribute__((aligned(32))) usb_dev_data_t g_usb_dev_data[USBCFG_DEV_NUM];
     55              #else
     56                  #error Unsupported compiler, please use IAR, Keil or arm gcc compiler and rebuild the project.
     57              #endif
     58          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
     59                  usb_dev_data_t* g_usb_dev_data_ptr[USBCFG_DEV_NUM] = {NULL};
     60          #endif
     61          
     62          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM)
     63          #define OS_Mutex_lock(_M_) OS_Lock()
     64          #define OS_Mutex_unlock(_M_) OS_Unlock()
     65          #endif
     66          #define USB_DEV_HANDLE_OCCUPIED ((uint8_t)1)
     67          #define USB_DEV_HANDLE_FREE     ((uint8_t)0)
     68          
     69          
     70          #if USBCFG_DEV_USE_TASK
     71          #define USB_DEVICE_TASK_TEMPLATE_INDEX           0
     72          
     73          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)            /* USB stack running on MQX */
     74          #define USB_DEVICE_TASK_ADDRESS                   _usb_dev_task_stun
     75          
     76          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM)        /* USB stack running on BM  */
     77          #define USB_DEVICE_TASK_ADDRESS                   _usb_dev_task
     78          
     79          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)
     80          #if USE_RTOS
     81          #define USB_DEVICE_TASK_ADDRESS                   _usb_dev_task_stun
     82          #else
     83          #define USB_DEVICE_TASK_ADDRESS                   _usb_dev_task
     84          #endif
     85          
     86          #endif
     87          
     88          #define USB_DEVICE_TASK_PRIORITY                 (6)
     89          #define USB_DEVICE_TASK_STACKSIZE                (3500)
     90          #define USB_DEVICE_TASK_NAME                     "Device Task"
     91          #define USB_DEVICE_TASK_ATTRIBUTES               (0)
     92          #define USB_DEVICE_TASK_CREATION_PARAMETER       (0)
     93          #define USB_DEVICE_TASK_DEFAULT_TIME_SLICE       (0)
     94          
     95          #endif
     96          
     97          extern int32_t bsp_usb_dev_init(uint8_t controller_id);
     98          #if USBCFG_DEV_KHCI && USBCFG_DEV_DETACH_ENABLE && USB_CFG_DEV_IO_DETACH_ENABLE
     99          extern int32_t bsp_usb_detach_init(uint8_t controller_id);
    100          #endif
    101          extern void USB_Control_Service (void* handle, usb_event_struct_t* event,void* arg);
    102          extern void USB_Reset_Service(void* handle, usb_event_struct_t* event, void* arg);
    103          extern void USB_Error_Service(void* handle, usb_event_struct_t* event, void* arg);
    104          extern void USB_Suspend_Service(void* handle, usb_event_struct_t* event,void* arg);
    105          extern void USB_Resume_Service(void* handle,usb_event_struct_t* event,void* arg );
    106          

   \                                 In section .bss, align 4
    107          static usb_dev_state_struct_t g_usb_dev[USBCFG_DEV_NUM] = {{0}};
   \                     g_usb_dev:
   \   00000000                      DS8 164
    108          #if USBCFG_DEV_KHCI
    109          extern const usb_dev_interface_functions_struct_t _usb_khci_dev_function_table;
    110          #endif
    111          #if USBCFG_DEV_EHCI
    112          extern const usb_dev_interface_functions_struct_t _usb_ehci_dev_function_table;
    113          #endif
    114          
    115          /*FUNCTION*-------------------------------------------------------------
    116          *
    117          *  Function Name  : _usb_device_get_handle
    118          *  Returned Value : NULL
    119          *  Comments       :
    120          *        This function is used to get one unused device object
    121          *
    122          *END*-----------------------------------------------------------------*/
    123          static usb_dev_state_struct_t* _usb_device_get_handle
    124          (
    125              void
    126          )
    127          {
    128              uint8_t i = 0;
    129          
    130              for (; i < USBCFG_DEV_NUM; i++) 
    131              {
    132                  if (g_usb_dev[i].occupied != USB_DEV_HANDLE_OCCUPIED) 
    133                  {
    134                      OS_Mem_zero(&g_usb_dev[i], sizeof(usb_dev_state_struct_t));
    135                      g_usb_dev[i].occupied = USB_DEV_HANDLE_OCCUPIED;
    136                      return &g_usb_dev[i];
    137                  }
    138              }
    139              return NULL;
    140          }
    141          
    142          /*FUNCTION*-------------------------------------------------------------
    143          *
    144          *  Function Name  : _usb_device_release_handle
    145          *  Returned Value : NULL
    146          *  Comments       :
    147          *        This function is used to set one used device object to free
    148          *
    149          *END*-----------------------------------------------------------------*/
    150          static void _usb_device_release_handle
    151          (
    152              usb_dev_state_struct_t *usb_dev
    153          )
    154          {
    155              usb_dev->occupied = USB_DEV_HANDLE_FREE;
    156          }
    157          
    158          /*FUNCTION*-------------------------------------------------------------
    159          *
    160          *  Function Name  : _usb_device_get_DCI
    161          *  Returned Value : NULL
    162          *  Comments       :
    163          *        This function is used to get the device controller's interface table pointer
    164          *
    165          *END*-----------------------------------------------------------------*/
    166          static void _usb_device_get_DCI
    167          (
    168              uint8_t                                     controller_id, 
    169              usb_dev_interface_functions_struct_t**      controller_if_ptr
    170          )
    171          {
    172          #if USBCFG_DEV_KHCI
    173              if ((controller_id == USB_CONTROLLER_KHCI_0) || ((controller_id == USB_CONTROLLER_KHCI_1)))
    174              {
    175                  *controller_if_ptr = (usb_dev_interface_functions_struct_t*)&_usb_khci_dev_function_table;
    176              }
    177          #endif
    178          
    179          #if USBCFG_DEV_EHCI
    180          	if ((controller_id == USB_CONTROLLER_EHCI_0) || (controller_id == USB_CONTROLLER_EHCI_1))
    181          	{
    182          		*controller_if_ptr = (usb_dev_interface_functions_struct_t*)&_usb_ehci_dev_function_table;
    183          	}
    184          #endif
    185          }
    186          
    187          /*FUNCTION*-------------------------------------------------------------
    188          *
    189          *  Function Name  : _usb_device_shutdown
    190          *  Returned Value : USB_OK or error code
    191          *  Comments       :
    192          *        Shutdown an initialized USB device
    193          *
    194          *END*-----------------------------------------------------------------*/
    195          static usb_status _usb_device_shutdown
    196          (
    197              /* [IN] the USB_USB_dev_initialize state structure */
    198              usb_device_handle         handle
    199          )
    200          { 
    201              usb_status                        error;
    202              usb_dev_state_struct_t*           usb_dev_ptr;
    203              
    204              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    205          #if USBCFG_DEV_USE_TASK
    206          
    207              if (usb_dev_ptr->task_id != (uint32_t)OS_TASK_ERROR)
    208              {
    209                  OS_Task_delete(usb_dev_ptr->task_id);
    210              }
    211              if (NULL != usb_dev_ptr->usb_dev_service_que)
    212              {
    213                  OS_MsgQ_destroy(usb_dev_ptr->usb_dev_service_que);
    214              }
    215          #endif
    216              if (((usb_dev_interface_functions_struct_t*)\
    217                  usb_dev_ptr->usb_dev_interface)->dev_shutdown != NULL)
    218              {
    219                  error = ((usb_dev_interface_functions_struct_t*)\
    220                      usb_dev_ptr->usb_dev_interface)->dev_shutdown(usb_dev_ptr->controller_handle);
    221                  return  error;
    222              }
    223              else
    224              {
    225                  #if _DEBUG
    226          //            USB_PRINTF("_usb_device_shutdown: DEV_SHUTDOWN is NULL\n");
    227                  #endif  
    228                  return USBERR_ERROR;
    229              }    
    230          } /* EndBody */
    231          
    232          /*FUNCTION*----------------------------------------------------------------
    233          * 
    234          * Function Name  : usb_device_call_service
    235          * Returned Value : USB_OK or error code
    236          * Comments       :
    237          *     Calls the appropriate service for the specified type, if one is
    238          *     registered. Used internally only.
    239          * 
    240          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    241          usb_status _usb_device_call_service_internal
    242             (
    243                /* [IN] pointer to usb device status structure  */ 
    244                usb_dev_state_struct_t*       usb_dev_ptr,
    245                /* [IN] pointer to event structure  */ 
    246                usb_event_struct_t*    event 
    247             )
    248          {
   \                     _usb_device_call_service_internal: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    249              service_struct_t*             service_ptr = NULL;
    250              uint32_t                      i;
    251          
    252              /* Needs mutual exclusion */
    253              //OS_Mutex_lock(usb_dev_ptr->mutex);
    254          
    255              switch (event->type)
   \   00000006   0x7B68             LDRB     R0,[R5, #+13]
   \   00000008   0xB138             CBZ.N    R0,??_usb_device_call_service_internal_0
   \   0000000A   0x2810             CMP      R0,#+16
   \   0000000C   0xBF02             ITTT     EQ 
    256              {
    257                  case USB_SERVICE_EP0:
    258                      USB_Control_Service(&usb_dev_ptr->usb_framework, event, NULL);
    259                      break;     
    260                  case USB_SERVICE_BUS_RESET:
    261                      USB_Reset_Service(&usb_dev_ptr->usb_framework, event, NULL);
   \   0000000E   0x2200             MOVEQ    R2,#+0
   \   00000010   0xF104 0x0008      ADDEQ    R0,R4,#+8
   \   00000014   0x.... 0x....      BLEQ     USB_Reset_Service
   \   00000018   0xE004             B.N      ??_usb_device_call_service_internal_1
   \                     ??_usb_device_call_service_internal_0: (+1)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000020   0x.... 0x....      BL       USB_Control_Service
    262                      break;
    263          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME
    264                  case USB_SERVICE_SUSPEND:
    265                      USB_Suspend_Service(&usb_dev_ptr->usb_framework, event, NULL);
    266                      break;
    267                  case USB_SERVICE_RESUME:
    268                      USB_Resume_Service(&usb_dev_ptr->usb_framework, event, NULL);
    269                      break;
    270          #endif
    271          #if USBCFG_DEV_KHCI_ADVANCED_ERROR_HANDLING
    272                  case USB_SERVICE_ERROR:
    273                      USB_Error_Service(&usb_dev_ptr->usb_framework, event, NULL);
    274                      break;
    275          #endif
    276          #if USBCFG_DEV_DETACH_ENABLE
    277                  case USB_SERVICE_DETACH:
    278                      USB_Detach_Service(&usb_dev_ptr->usb_framework, event, NULL);
    279                      break;
    280          #endif
    281                  default:
    282                      break;
    283              } /* Endswitch */
    284          
    285              /* Search for an existing entry for type */
    286              for (i = 0; i < MAX_DEVICE_SERVICE_NUMBER; i++) 
   \                     ??_usb_device_call_service_internal_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
    287              {
    288                  service_ptr = &usb_dev_ptr->services[i];
   \                     ??_usb_device_call_service_internal_2: (+1)
   \   00000026   0x210C             MOVS     R1,#+12
   \   00000028   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   0000002C   0xF101 0x023C      ADD      R2,R1,#+60
    289                  if (service_ptr->type == event->type) 
   \   00000030   0x7B6B             LDRB     R3,[R5, #+13]
   \   00000032   0x7A11             LDRB     R1,[R2, #+8]
   \   00000034   0x4299             CMP      R1,R3
   \   00000036   0xD105             BNE.N    ??_usb_device_call_service_internal_3
    290                  {
    291                      service_ptr->service(event,service_ptr->arg);
   \   00000038   0x6851             LDR      R1,[R2, #+4]
   \   0000003A   0x6812             LDR      R2,[R2, #+0]
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x4790             BLX      R2
    292                      //OS_Mutex_unlock(usb_dev_ptr->mutex);
    293                      return USB_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}
    294                  }  
    295              }
   \                     ??_usb_device_call_service_internal_3: (+1)
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x2808             CMP      R0,#+8
   \   00000048   0xD3ED             BCC.N    ??_usb_device_call_service_internal_2
    296          
    297          	//OS_Mutex_unlock(usb_dev_ptr->mutex);
    298              return USBERR_CLOSED_SERVICE;
   \   0000004A   0x2083             MOVS     R0,#+131
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    299          } /* EndBody */
    300          
    301          
    302          #if USBCFG_DEV_USE_TASK
    303          static void _usb_dev_task
    304          (
    305              void* dev_inst_ptr
    306          )
    307          {
    308              usb_dev_state_struct_t* usb_dev_ptr = (usb_dev_state_struct_t*)dev_inst_ptr;
    309              static usb_event_struct_t msg = {0};
    310              
    311              //if (!OS_MsgQ_Is_Empty(usb_device_ptr->isr_que,&msg))
    312              while (!OS_MsgQ_recv(usb_dev_ptr->usb_dev_service_que, (uint32_t *) &msg, OS_MSGQ_RECEIVE_BLOCK_ON_EMPTY, 10))
    313              {
    314                    _usb_device_call_service_internal(usb_dev_ptr, &msg);
    315              }
    316          }
    317          
    318          /*FUNCTION*-------------------------------------------------------------
    319          *
    320          *  Function Name  : _usb_khci_task_stun
    321          *  Returned Value : none
    322          *  Comments       :
    323          *        KHCI task
    324          *END*-----------------------------------------------------------------*/
    325          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX) || ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK) && USE_RTOS)
    326          static void _usb_dev_task_stun
    327          (
    328              void* dev_inst_ptr
    329          )
    330          {
    331              while (1)
    332              {
    333                  _usb_dev_task(dev_inst_ptr);
    334              }
    335          }
    336          #endif
    337          
    338          /*FUNCTION*-------------------------------------------------------------
    339          *
    340          *  Function Name  : _usb_task_create
    341          *  Returned Value : error or USB_OK
    342          *  Comments       :
    343          *        Create devcie task
    344          *END*-----------------------------------------------------------------*/
    345          static usb_status _usb_dev_task_create
    346          (
    347              usb_device_handle handle
    348          )
    349          {
    350              //USB_STATUS status;
    351              //task_id = _task_create_blocked(0, 0, (uint32_t)&task_template);
    352              usb_dev_state_struct_t*           usb_dev_ptr;
    353              
    354              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    355              usb_dev_ptr->task_id = OS_Task_create(USB_DEVICE_TASK_ADDRESS, (void*)handle, (uint32_t)USB_DEVICE_TASK_PRIORITY, USB_DEVICE_TASK_STACKSIZE, USB_DEVICE_TASK_NAME, NULL);
    356              
    357              if (usb_dev_ptr->task_id == (uint32_t)OS_TASK_ERROR) {
    358                  return USBERR_ERROR;
    359              }
    360              
    361              //_task_ready(_task_get_td(task_id));
    362              //OS_Task_resume(task_id);
    363          
    364              return USB_OK;
    365          }
    366          
    367          #endif
    368          
    369          /*FUNCTION*----------------------------------------------------------------
    370          * 
    371          * Function Name  : usb_device_call_service
    372          * Returned Value : USB_OK or error code
    373          * Comments       :
    374          *     Calls the appropriate service for the specified type, if one is
    375          *     registered. Used internally only.
    376          * 
    377          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    378          usb_status _usb_device_call_service
    379          (
    380              /* [IN] Type of service or endpoint */
    381              uint8_t                  type,
    382              /* [IN] pointer to event structure  */ 
    383              usb_event_struct_t*      event
    384          )
    385          {
    386              usb_dev_state_struct_t*       usb_dev_ptr;
    387              usb_dev_ptr = (usb_dev_state_struct_t*)event->handle;
   \                     _usb_device_call_service: (+1)
   \   00000000   0x680A             LDR      R2,[R1, #+0]
    388          
    389              event->type = type;
   \   00000002   0x7348             STRB     R0,[R1, #+13]
    390              if((type & 0x7F) && ((type & 0x7F) < 0x10))
   \   00000004   0xF010 0x037F      ANDS     R3,R0,#0x7F
   \   00000008   0xD007             BEQ.N    ??_usb_device_call_service_0
   \   0000000A   0xF000 0x007F      AND      R0,R0,#0x7F
   \   0000000E   0x2810             CMP      R0,#+16
   \   00000010   0xDA03             BGE.N    ??_usb_device_call_service_0
    391              {
    392                  event->type = (uint8_t)(((uint8_t)(event->direction << 7)) | (type & 0x7F));
   \   00000012   0x7BC8             LDRB     R0,[R1, #+15]
   \   00000014   0xEA43 0x10C0      ORR      R0,R3,R0, LSL #+7
   \   00000018   0x7348             STRB     R0,[R1, #+13]
    393              }
    394          #if USBCFG_DEV_USE_TASK
    395              if (0 != OS_MsgQ_send(usb_dev_ptr->usb_dev_service_que, (void *)event, 0))
    396              {
    397                  return USBERR_ALLOC_STATE;
    398              }
    399              return USB_OK;
    400          #else
    401              return _usb_device_call_service_internal(usb_dev_ptr, event);
   \                     ??_usb_device_call_service_0: (+1)
   \   0000001A   0x4610             MOV      R0,R2
   \   0000001C   0x....             B.N      _usb_device_call_service_internal
    402          #endif
    403              
    404          }
    405          
    406          /*FUNCTION*-------------------------------------------------------------
    407          *
    408          *  Function Name  : usb_device_set_address
    409          *  Returned Value : USB_OK or error code
    410          *  Comments       :
    411          *        Sets the device address as assigned by the host during enumeration
    412          *
    413          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    414          usb_status _usb_device_set_address
    415          (
    416              /* [IN] the USB_USB_dev_initialize state structure */
    417              usb_device_handle         handle,
    418              /* [IN] the USB address to be set in the hardware */
    419              uint8_t                     address
    420          )
    421          { 
   \                     _usb_device_set_address: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0x6B12             LDR      R2,[R2, #+48]
   \   00000004   0x0013             MOVS     R3,R2
   \   00000006   0xBF1C             ITT      NE 
    422              usb_dev_state_struct_t*       usb_dev_ptr;
    423              usb_status                    error;
    424             
    425              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    426          
    427              if (((usb_dev_interface_functions_struct_t*)
    428                usb_dev_ptr->usb_dev_interface)->dev_set_address != NULL) 
    429              {
    430                  error = ((usb_dev_interface_functions_struct_t*)
    431                      usb_dev_ptr->usb_dev_interface)->dev_set_address(usb_dev_ptr->controller_handle, address);
    432                  return error;
   \   00000008   0x6800             LDRNE    R0,[R0, #+0]
   \   0000000A   0x4710             BXNE     R2
    433              }
    434              else
    435              {
    436                  #ifdef _DEBUG
    437          //            USB_PRINTF("usb_device_set_address: DEV_SET_ADDRESS is NULL\n");                      
    438                  #endif  
    439                  return USBERR_ERROR;
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x4770             BX       LR               ;; return
    440              }
    441          
    442              
    443          }
    444          
    445          /*FUNCTION*----------------------------------------------------------------
    446          * 
    447          * Function Name  : usb_device_get_status
    448          * Returned Value : USB_OK or error code
    449          * Comments       :
    450          *     Provides API to access the USB internal state.
    451          * 
    452          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    453          usb_status usb_device_get_status
    454          (
    455              /* [IN] Handle to the USB device */
    456              usb_device_handle   handle,
    457              /* [IN] What to get the error of */
    458              uint8_t              component,
    459              /* [OUT] The requested error */
    460              uint16_t*            error
    461          )
    462          { /* Body */
   \                     usb_device_get_status: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine4
    463              usb_dev_state_struct_t* usb_dev_ptr;
    464          
    465              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    466          
    467              OS_Mutex_lock(usb_dev_ptr->mutex);
    468              if (component & USB_STATUS_ENDPOINT) 
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x06E9             LSLS     R1,R5,#+27
   \   0000000A   0xD506             BPL.N    ??usb_device_get_status_0
    469              {
    470                  if (((usb_dev_interface_functions_struct_t*)
    471                     usb_dev_ptr->usb_dev_interface)->dev_get_endpoint_status != NULL)
   \   0000000C   0x6A43             LDR      R3,[R0, #+36]
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xD00A             BEQ.N    ??usb_device_get_status_1
    472                  {
    473                      ((usb_dev_interface_functions_struct_t*)
    474                          usb_dev_ptr->usb_dev_interface)->dev_get_endpoint_status(usb_dev_ptr->controller_handle,
    475                          (uint8_t)(component),error);
   \   00000012   0x.... 0x....      BL       ?Subroutine6
    476                  }
    477                  else
    478                  {
    479                      #if _DEBUG
    480          //                USB_PRINTF("usb_device_get_status: DEV_GET_ENDPOINT_STATUS is NULL\n");
    481                      #endif  
    482                      OS_Mutex_unlock(usb_dev_ptr->mutex);
    483                      return USBERR_ERROR;
    484                  }             
    485              } 
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000016   0x4798             BLX      R3
    486              else 
    487              {
    488                  if (((usb_dev_interface_functions_struct_t*)
    489                     usb_dev_ptr->usb_dev_interface)->dev_get_device_status != NULL)
    490                  {
    491                      ((usb_dev_interface_functions_struct_t*)
    492                          usb_dev_ptr->usb_dev_interface)->dev_get_device_status(usb_dev_ptr->controller_handle,
    493                          (uint8_t)(component),error);
    494                  }
    495                  else
    496                  {
    497                      #if _DEBUG
    498          //                USB_PRINTF("usb_device_get_status: DEV_GET_DEVICE_STATUS is NULL\n");
    499                      #endif  
    500                      OS_Mutex_unlock(usb_dev_ptr->mutex);
    501                      return USBERR_ERROR;
    502                  }        
    503              } 
    504          
    505             OS_Mutex_unlock(usb_dev_ptr->mutex);
   \                     ??usb_device_get_status_2: (+1)
   \   00000018   0x....             B.N      ?Subroutine2
   \                     ??usb_device_get_status_0: (+1)
   \   0000001A   0x6C43             LDR      R3,[R0, #+68]
   \   0000001C   0x0018             MOVS     R0,R3
   \   0000001E   0xD003             BEQ.N    ??usb_device_get_status_1
   \   00000020   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000024   0x4798             BLX      R3
   \   00000026   0xE7F7             B.N      ??usb_device_get_status_2
   \                     ??usb_device_get_status_1: (+1)
   \   00000028   0x....             B.N      ?Subroutine1
    506             return USB_OK;
    507          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x.... 0x....      B.W      sys_lock

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      BL       sys_unlock
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       sys_unlock
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x4632             MOV      R2,R6
   \   00000004   0x4629             MOV      R1,R5
   \   00000006   0x4770             BX       LR
    508           
    509          /*FUNCTION*----------------------------------------------------------------
    510          * 
    511          * Function Name  : usb_device_set_status
    512          * Returned Value : USB_OK or error code
    513          * Comments       :
    514          *     Provides API to set internal state
    515          * 
    516          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    517          usb_status usb_device_set_status
    518          (
    519              /* [IN] Handle to the usb device */
    520              usb_device_handle   handle,
    521              /* [IN] What to set the error of */
    522              uint8_t               component,
    523              /* [IN] What to set the error to */
    524              uint16_t              setting
    525          )
    526          {
   \                     usb_device_set_status: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine4
    527              usb_dev_state_struct_t* usb_dev_ptr;
    528              uint8_t                 error = USB_OK;
    529              
    530              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    531              OS_Mutex_lock(usb_dev_ptr->mutex);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x6C03             LDR      R3,[R0, #+64]
   \   0000000A   0x0018             MOVS     R0,R3
   \   0000000C   0xD003             BEQ.N    ??usb_device_set_status_0
    532              if (((usb_dev_interface_functions_struct_t*)
    533                 usb_dev_ptr->usb_dev_interface)->dev_set_device_status != NULL)
    534              {
    535                  ((usb_dev_interface_functions_struct_t*)
    536                      usb_dev_ptr->usb_dev_interface)->dev_set_device_status(usb_dev_ptr->controller_handle,
    537                      (uint8_t)(component),setting);
   \   0000000E   0x.... 0x....      BL       ?Subroutine6
    538              }
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000012   0x4798             BLX      R3
    539              else
    540              {
    541                  #if _DEBUG
    542          //            USB_PRINTF("usb_device_set_status: dev_set_device_status is NULL\n");
    543                  #endif  
    544          		OS_Mutex_unlock(usb_dev_ptr->mutex);
    545                  return USBERR_ERROR;
    546              }
    547          
    548          	OS_Mutex_unlock(usb_dev_ptr->mutex);
   \   00000014   0x....             B.N      ?Subroutine2
   \                     ??usb_device_set_status_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine1
    549              return error;
    550          } /* EndBody */
    551          
    552          
    553          /*FUNCTION*-------------------------------------------------------------
    554          *
    555          *  Function Name  : usb_device_init
    556          *  Returned Value : USB_OK or error code
    557          *  Comments       :
    558          *        Initializes the USB device specific data structures and calls 
    559          *  the low-level device controller chip initialization routine.
    560          *
    561          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    562          usb_status usb_device_init
    563          (
    564                /* [IN] the USB device controller to initialize */
    565                uint8_t controller_id,
    566                /* [OUT] the USB_USB_dev_initialize state structure */
    567                usb_device_handle *  handle
    568          )
    569          {
   \                     usb_device_init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    570              usb_dev_state_struct_t*                 usb_dev_ptr;
    571              uint8_t                                 i;
    572              usb_status                              error = USB_OK;
    573              usb_dev_interface_functions_struct_t*   dev_if = NULL;
    574              usb_class_fw_object_struct_t*           usb_fw_ptr = NULL;
    575          
    576              //OS_Lock();
    577          
    578          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
    579          	for(i = 0; i < USBCFG_DEV_NUM; i++)
    580          	{
    581          		if(NULL == g_usb_dev_data_ptr[i])
    582          		{
    583          			g_usb_dev_data_ptr[i] = OS_Mem_alloc_uncached_align(sizeof(usb_dev_data_t), 32);
    584          		}
    585          	}
    586          #endif
    587          
    588              usb_dev_ptr = _usb_device_get_handle();
   \   00000002   0x....             LDR.N    R6,??DataTable0
   \   00000004   0xF106 0x079C      ADD      R7,R6,#+156
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x7838             LDRB     R0,[R7, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0xD029             BEQ.N    ??usb_device_init_0
   \   00000012   0x22A4             MOVS     R2,#+164
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       memset
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7038             STRB     R0,[R7, #+0]
    589           
    590              if(usb_dev_ptr == NULL)
    591              {
    592                    /* The interface does not support device functionality */
    593                  //OS_Unlock();
    594                  return USBERR_DEVICE_BUSY;
    595              }
    596          	usb_dev_ptr->controller_id = controller_id;
   \   00000020   0x707C             STRB     R4,[R7, #+1]
    597              usb_fw_ptr = &usb_dev_ptr->usb_framework;
    598              usb_dev_ptr->mutex = OS_Mutex_create();
   \   00000022   0x.... 0x....      BL       OS_Mutex_create
    599          #if ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)))
    600              usb_fw_ptr->ext_req_to_host = (uint8_t*)g_usb_dev_data[controller_id].control_out;
   \   00000026   0x....             LDR.N    R1,??DataTable0_1
   \   00000028   0x6078             STR      R0,[R7, #+4]
   \   0000002A   0x2260             MOVS     R2,#+96
   \   0000002C   0xFB12 0x1104      SMLABB   R1,R2,R4,R1
   \   00000030   0x61F1             STR      R1,[R6, #+28]
    601          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
    602              usb_fw_ptr->ext_req_to_host = (uint8_t*)g_usb_dev_data_ptr[controller_id]->control_out;
    603          #endif
    604              
    605              for (i= 0; i < MAX_DEVICE_SERVICE_NUMBER; i++)
   \   00000032   0x22FF             MOVS     R2,#+255
   \   00000034   0x2100             MOVS     R1,#+0
    606              {
    607                  usb_dev_ptr->services[i].type = (uint8_t)-1;
   \                     ??usb_device_init_1: (+1)
   \   00000036   0x230C             MOVS     R3,#+12
   \   00000038   0xFB13 0x6301      SMLABB   R3,R3,R1,R6
    608              }
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0x2908             CMP      R1,#+8
   \   00000040   0xF883 0x2044      STRB     R2,[R3, #+68]
   \   00000044   0xDBF7             BLT.N    ??usb_device_init_1
    609          
    610              _usb_device_get_DCI(controller_id, &dev_if);
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xBF18             IT       NE 
   \   0000004A   0x2C01             CMPNE    R4,#+1
   \   0000004C   0xD10D             BNE.N    ??usb_device_init_2
    611           
    612              if(dev_if == NULL)
    613              {
    614                   _usb_device_release_handle(usb_dev_ptr);
    615                   //OS_Unlock();
    616                   return USBERR_DEVICE_NOT_FOUND;
    617              }
    618           
    619              usb_dev_ptr->usb_dev_interface = (void*)dev_if;
   \   0000004E   0x....             LDR.N    R7,??DataTable0_2
   \   00000050   0x6077             STR      R7,[R6, #+4]
    620              
    621          #if USBCFG_DEV_USE_TASK
    622                  /* The _lwmsgq_init accepts the size of ISR_MSG_STRUCT as a multiplier of sizeof(_mqx_max_type) */
    623                  #define MSG_SIZE_IN_MAX_TYPE (1 + (sizeof(usb_event_struct_t) - 1) / sizeof(uint32_t))
    624                  usb_dev_ptr->usb_dev_service_que = (os_msgq_handle)OS_MsgQ_create(USBCFG_DEV_SERVICE_MSG_CNT, MSG_SIZE_IN_MAX_TYPE);
    625                 _usb_dev_task_create(usb_dev_ptr);
    626          #endif
    627          
    628              //OS_Unlock();
    629              /* Initialize the USB interface. */
    630              if (dev_if->dev_preint != NULL)
   \   00000052   0x683A             LDR      R2,[R7, #+0]
   \   00000054   0x0010             MOVS     R0,R2
   \   00000056   0xD002             BEQ.N    ??usb_device_init_3
    631              {
    632                  error = dev_if->dev_preint(usb_dev_ptr, (usb_device_handle *) (&usb_dev_ptr->controller_handle));
   \   00000058   0x4631             MOV      R1,R6
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x4790             BLX      R2
    633              }
    634          
    635              if (usb_dev_ptr->controller_handle == NULL)
   \                     ??usb_device_init_3: (+1)
   \   0000005E   0x6830             LDR      R0,[R6, #+0]
   \   00000060   0xB938             CBNZ.N   R0,??usb_device_init_4
    636              {
    637                  #ifdef _DEBUG
    638          //        USB_PRINTF("1 memalloc failed in usb_device_init\n");
    639                  #endif  
    640                  return USBERR_ALLOC_STATE;
   \   00000062   0x2087             MOVS     R0,#+135
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}
    641              } /* Endif */
   \                     ??usb_device_init_0: (+1)
   \   00000066   0x20C1             MOVS     R0,#+193
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??usb_device_init_2: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x7038             STRB     R0,[R7, #+0]
   \   0000006E   0x20C0             MOVS     R0,#+192
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}
    642              usb_fw_ptr->controller_handle = usb_dev_ptr->controller_handle;
   \                     ??usb_device_init_4: (+1)
   \   00000072   0x60F0             STR      R0,[R6, #+12]
    643              usb_fw_ptr->dev_handle = usb_dev_ptr;
   \   00000074   0x6136             STR      R6,[R6, #+16]
    644          #ifndef USBCFG_OTG
    645              error = bsp_usb_dev_init(controller_id);
    646          #if USBCFG_DEV_KHCI && USBCFG_DEV_DETACH_ENABLE && USB_CFG_DEV_IO_DETACH_ENABLE
    647              error = bsp_usb_detach_init(controller_id);
    648          #endif
    649          #endif
    650              if (error != USB_OK)
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       bsp_usb_dev_init
   \   0000007C   0xB130             CBZ.N    R0,??usb_device_init_5
    651              {     
    652                  if (dev_if->dev_shutdown != NULL)
   \   0000007E   0x6B79             LDR      R1,[R7, #+52]
   \   00000080   0x0008             MOVS     R0,R1
   \   00000082   0xBF1C             ITT      NE 
    653                  {
    654                      dev_if->dev_shutdown(usb_dev_ptr->controller_handle);
   \   00000084   0x6830             LDRNE    R0,[R6, #+0]
   \   00000086   0x4788             BLXNE    R1
    655                  }
    656                  return USBERR_UNKNOWN_ERROR;
   \   00000088   0x20C4             MOVS     R0,#+196
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}
    657              }
    658          
    659              /* Initialize the USB controller chip */
    660              if (dev_if->dev_init != NULL) 
   \                     ??usb_device_init_5: (+1)
   \   0000008C   0x687A             LDR      R2,[R7, #+4]
   \   0000008E   0x0010             MOVS     R0,R2
   \   00000090   0xD005             BEQ.N    ??usb_device_init_6
    661              {
    662                  error = dev_if->dev_init(controller_id,usb_dev_ptr->controller_handle);     
    663              }
    664              else
    665              {
    666                  #ifdef _DEBUG
    667          //            USB_PRINTF("usb_device_init: DEV_INIT is NULL\n");                   
    668                  #endif  
    669                  return USBERR_ERROR;
    670              }
    671          
    672              if (error) 
   \   00000092   0x6831             LDR      R1,[R6, #+0]
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x4790             BLX      R2
   \   00000098   0xB918             CBNZ.N   R0,??usb_device_init_7
    673              {
    674                  if (dev_if->dev_shutdown != NULL)
    675                  {
    676                      dev_if->dev_shutdown(usb_dev_ptr->controller_handle);
    677                  }
    678                  return USBERR_INIT_FAILED;
    679              } /* Endif */
    680              
    681              *handle = usb_dev_ptr;
   \   0000009A   0x602E             STR      R6,[R5, #+0]
    682              return error;
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??usb_device_init_6: (+1)
   \   0000009E   0x20FF             MOVS     R0,#+255
   \   000000A0   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??usb_device_init_7: (+1)
   \   000000A2   0x6B79             LDR      R1,[R7, #+52]
   \   000000A4   0x0008             MOVS     R0,R1
   \   000000A6   0xBF1C             ITT      NE 
   \   000000A8   0x6830             LDRNE    R0,[R6, #+0]
   \   000000AA   0x4788             BLXNE    R1
   \   000000AC   0x208D             MOVS     R0,#+141
   \   000000AE   0xBDF2             POP      {R1,R4-R7,PC}
    683          } /* EndBody */
    684          
    685          /*FUNCTION*-------------------------------------------------------------
    686          *
    687          *  Function Name  : usb_device_postinit
    688          *  Returned Value : USB_OK or error code
    689          *  Comments       :
    690          *        Initializes the USB device specific data structures and calls 
    691          *  the low-level device controller chip initialization routine.
    692          *
    693          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    694          usb_status usb_device_postinit
    695          (
    696                /* [IN] the USB device controller to initialize */
    697                uint8_t controller_id,
    698                /* [OUT] the USB_USB_dev_initialize state structure */
    699                usb_device_handle  handle
    700          )
    701          {
   \                     usb_device_postinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    702              usb_dev_state_struct_t*                 usb_dev_ptr;
    703              usb_status                              error = 0;
   \   00000002   0x684B             LDR      R3,[R1, #+4]
   \   00000004   0x689B             LDR      R3,[R3, #+8]
   \   00000006   0x4602             MOV      R2,R0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x001C             MOVS     R4,R3
   \   0000000C   0xD003             BEQ.N    ??usb_device_postinit_0
    704          
    705              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    706              if (((usb_dev_interface_functions_struct_t*)\
    707                   usb_dev_ptr->usb_dev_interface)->dev_postinit != NULL)
    708              {
    709                  error = ((usb_dev_interface_functions_struct_t*)\
    710                      usb_dev_ptr->usb_dev_interface)->dev_postinit(controller_id, handle);    
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0x4718             BX       R3
    711              }
    712              return error;
   \                     ??usb_device_postinit_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    713          } /* EndBody */
    714          
    715          /*FUNCTION*-------------------------------------------------------------
    716          *
    717          *  Function Name  : usb_device_deinit
    718          *  Returned Value : USB_OK or error code
    719          *  Comments       :
    720          *  uninitializes the USB device specific data structures and calls 
    721          *  the low-level device controller chip initialization routine.
    722          *
    723          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    724          usb_status usb_device_deinit
    725          (
    726              /* [OUT] the USB_USB_dev_initialize state structure */
    727              usb_device_handle  handle
    728          )
    729          {
   \                     usb_device_deinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    730          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
    731              uint32_t i;
    732          #endif
    733              usb_dev_state_struct_t*      usb_dev_ptr;
    734              //usb_class_fw_object_struct_t* usb_fw_ptr = NULL;
    735              if (handle == NULL)
   \   00000004   0xD101             BNE.N    ??usb_device_deinit_0
    736              {
    737                  #if _DEBUG
    738          //            USB_PRINTF("_usb_device_shutdowna: handle is NULL\n");
    739                  #endif  
    740                  return USBERR_ERROR;
   \   00000006   0x20FF             MOVS     R0,#+255
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    741              }
    742              
    743              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    744              
    745              OS_Mutex_destroy(usb_dev_ptr->mutex);
   \                     ??usb_device_deinit_0: (+1)
   \   0000000A   0xF104 0x059C      ADD      R5,R4,#+156
   \   0000000E   0x6868             LDR      R0,[R5, #+4]
   \   00000010   0x.... 0x....      BL       OS_Mutex_destroy
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x6B41             LDR      R1,[R0, #+52]
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0xBF1C             ITT      NE 
    746              _usb_device_shutdown(handle);
   \   0000001C   0x6820             LDRNE    R0,[R4, #+0]
   \   0000001E   0x4788             BLXNE    R1
    747          
    748              _usb_device_release_handle(usb_dev_ptr);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7028             STRB     R0,[R5, #+0]
    749              
    750          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
    751          	for(i = 0; i < USBCFG_DEV_NUM; i++)
    752          	{
    753          		if(NULL != g_usb_dev_data_ptr[i])
    754          		{
    755          			OS_Mem_free(g_usb_dev_data_ptr[i]);
    756                      g_usb_dev_data_ptr[i] = NULL;
    757          		}
    758          	}
    759          #endif
    760          
    761              return USB_OK;
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    762          } /* EndBody */
    763          
    764          /*FUNCTION*-------------------------------------------------------------
    765          *
    766          *  Function Name  : usb_device_init_endpoint
    767          *  Returned Value : USB_OK or error code
    768          *  Comments       :
    769          *     Initializes the endpoint and the data structures associated with the 
    770          *  endpoint
    771          *
    772          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    773          usb_status usb_device_init_endpoint
    774          (
    775              /* [IN] the USB_USB_dev_initialize state structure */
    776              usb_device_handle         handle,
    777              /* [IN] the endpoint structure, include members such as endpoint number, 
    778               * endpoint type, endpoint direction and the max packet size 
    779               */                  
    780              usb_ep_struct_t*          ep_ptr, 
    781              /* [IN] After all data is transfered, should we terminate the transfer
    782               * with a zero length packet if the last packet size == MAX_PACKET_SIZE?
    783               */
    784              uint8_t                    flag
    785          )
    786          {
   \                     usb_device_init_endpoint: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    787              usb_status                    error = 0;
    788              usb_dev_state_struct_t*       usb_dev_ptr;
    789              struct xd_struct              xd;
    790              if (handle == NULL)
   \   00000004   0xB1C0             CBZ.N    R0,??usb_device_init_endpoint_0
    791              {
    792                  #if _DEBUG
    793                      USB_PRINTF("_usb_device_shutdowna: handle is NULL\n");
    794                  #endif  
    795                  return USBERR_ERROR;
    796              }
    797              
    798              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    799           
    800              /* Initialize the transfer descriptor */
    801              xd.ep_num = ep_ptr->ep_num;
   \   00000006   0x780B             LDRB     R3,[R1, #+0]
   \   00000008   0xF88D 0x3000      STRB     R3,[SP, #+0]
    802              xd.bdirection = ep_ptr->direction;
   \   0000000C   0x788B             LDRB     R3,[R1, #+2]
   \   0000000E   0xF88D 0x3001      STRB     R3,[SP, #+1]
    803              xd.wmaxpacketsize = (uint16_t)(ep_ptr->size & 0x0000FFFF);
   \   00000012   0x684B             LDR      R3,[R1, #+4]
   \   00000014   0xF8AD 0x3014      STRH     R3,[SP, #+20]
    804              xd.ep_type = ep_ptr->type;
   \   00000018   0x7849             LDRB     R1,[R1, #+1]
   \   0000001A   0xF88D 0x1002      STRB     R1,[SP, #+2]
    805              xd.dont_zero_terminate = flag;
   \   0000001E   0xF88D 0x2016      STRB     R2,[SP, #+22]
    806              xd.wtotallength = 0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x9102             STR      R1,[SP, #+8]
    807              xd.wsofar = 0;
   \   00000026   0x9103             STR      R1,[SP, #+12]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0x698A             LDR      R2,[R1, #+24]
   \   0000002C   0x0011             MOVS     R1,R2
   \   0000002E   0xD003             BEQ.N    ??usb_device_init_endpoint_0
    808           
    809              if (((usb_dev_interface_functions_struct_t*)
    810                 usb_dev_ptr->usb_dev_interface)->dev_init_endoint != NULL) 
    811              {
    812                   error=((usb_dev_interface_functions_struct_t*)\
    813                     usb_dev_ptr->usb_dev_interface)->dev_init_endoint(usb_dev_ptr->controller_handle, &xd);
    814              }
    815              else
    816              {
    817                   #ifdef _DEBUG
    818          //             USB_PRINTF("usb_device_init_endpoint: DEV_INIT_ENDPOINT is NULL\n");                     
    819                   #endif  
    820                   return USBERR_ERROR;
    821              }
    822              
    823              return error;
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x4790             BLX      R2
   \   00000036   0xE000             B.N      ??usb_device_init_endpoint_1
   \                     ??usb_device_init_endpoint_0: (+1)
   \   00000038   0x20FF             MOVS     R0,#+255
   \                     ??usb_device_init_endpoint_1: (+1)
   \   0000003A   0xB007             ADD      SP,SP,#+28
   \   0000003C   0xBD00             POP      {PC}             ;; return
    824          } /* EndBody */
    825          
    826          /*FUNCTION*----------------------------------------------------------------
    827          * 
    828          * Function Name  : usb_device_register_service
    829          * Returned Value : USB_OK or error code
    830          * Comments       :
    831          *     Registers a callback routine for a specified event or endpoint.
    832          * 
    833          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    834          usb_status usb_device_register_service
    835          (
    836              /* [IN] Handle to the USB device */
    837              usb_device_handle          handle,
    838              /* [IN] type of event or endpoint number to service */
    839              uint8_t                    type,
    840              /* [IN] Pointer to the service's callback function */
    841              usb_event_service_t        service,
    842              /*[IN] User Argument to be passed to Services when invoked.*/
    843              void*                      arg
    844          )
    845          {
   \                     usb_device_register_service: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000006   0x461F             MOV      R7,R3
    846              usb_dev_state_struct_t*    usb_dev_ptr;
    847              service_struct_t*          service_ptr;
    848              uint32_t                   i;
    849           
    850              if (handle == NULL)
   \   00000008   0xD101             BNE.N    ??usb_device_register_service_0
    851              {
    852                   return USBERR_ERROR;
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0xBDF2             POP      {R1,R4-R7,PC}
    853              }
    854              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    855           
    856              OS_Mutex_lock(usb_dev_ptr->mutex);
   \                     ??usb_device_register_service_0: (+1)
   \   0000000E   0x.... 0x....      BL       sys_lock
    857          
    858              for (i = 0; i < MAX_DEVICE_SERVICE_NUMBER; i++)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x210C             MOVS     R1,#+12
    859              {
    860                  service_ptr = &usb_dev_ptr->services[i];
    861                  if (service_ptr->type == type)
   \                     ??usb_device_register_service_1: (+1)
   \   00000016   0xFB01 0x4200      MLA      R2,R1,R0,R4
   \   0000001A   0xF892 0x2044      LDRB     R2,[R2, #+68]
   \   0000001E   0x42AA             CMP      R2,R5
   \   00000020   0xD103             BNE.N    ??usb_device_register_service_2
    862                  {
    863                      OS_Mutex_unlock(usb_dev_ptr->mutex);
   \   00000022   0x.... 0x....      BL       sys_unlock
    864                      return USBERR_OPEN_SERVICE;
   \   00000026   0x2084             MOVS     R0,#+132
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
    865                  }
    866              }
   \                     ??usb_device_register_service_2: (+1)
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x2808             CMP      R0,#+8
   \   0000002E   0xD3F2             BCC.N    ??usb_device_register_service_1
    867          
    868              for (i = 0; i < MAX_DEVICE_SERVICE_NUMBER; i++)
   \   00000030   0x2000             MOVS     R0,#+0
    869              {
    870                  service_ptr = &usb_dev_ptr->services[i];
   \                     ??usb_device_register_service_3: (+1)
   \   00000032   0xFB01 0x4200      MLA      R2,R1,R0,R4
   \   00000036   0x323C             ADDS     R2,R2,#+60
    871                  if (service_ptr->type == (uint8_t)-1)
   \   00000038   0x7A13             LDRB     R3,[R2, #+8]
   \   0000003A   0x2BFF             CMP      R3,#+255
   \   0000003C   0xD106             BNE.N    ??usb_device_register_service_4
    872                  {
    873                      service_ptr->type = type;
   \   0000003E   0x7215             STRB     R5,[R2, #+8]
    874                      service_ptr->service = service;
   \   00000040   0x6016             STR      R6,[R2, #+0]
    875                      service_ptr->arg = arg;
   \   00000042   0x6057             STR      R7,[R2, #+4]
    876                      OS_Mutex_unlock(usb_dev_ptr->mutex);
   \   00000044   0x.... 0x....      BL       sys_unlock
    877                      return USB_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
    878                  }
    879              }
   \                     ??usb_device_register_service_4: (+1)
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x2808             CMP      R0,#+8
   \   00000050   0xD3EF             BCC.N    ??usb_device_register_service_3
    880          
    881          	OS_Mutex_unlock(usb_dev_ptr->mutex);
   \   00000052   0x.... 0x....      BL       sys_unlock
    882              return USBERR_ALLOC;
   \   00000056   0x2081             MOVS     R0,#+129
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    883          } /* EndBody */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x0004             MOVS     R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x4770             BX       LR
    884          
    885          /*FUNCTION*----------------------------------------------------------------
    886          * 
    887          * Function Name  : usb_device_unregister_service
    888          * Returned Value : USB_OK or error code
    889          * Comments       :
    890          *     Unregisters a callback routine for a specified event or endpoint.
    891          * 
    892          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    893          usb_status usb_device_unregister_service
    894          (
    895              /* [IN] Handle to the USB device */
    896              usb_device_handle           handle,
    897              /* [IN] type of event or endpoint number to service */
    898              uint8_t                     type
    899          )
    900          { /* Body */
   \                     usb_device_unregister_service: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
    901              usb_dev_state_struct_t*    usb_dev_ptr;
    902              service_struct_t*          service_ptr;
    903              uint32_t                   i;
    904          
    905              if (handle == NULL)
   \   00000006   0xD101             BNE.N    ??usb_device_unregister_service_0
    906              {
    907                 return USBERR_ERROR;
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0xBD32             POP      {R1,R4,R5,PC}
    908              }
    909          
    910              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    911              /* Needs mutual exclusion */
    912              OS_Mutex_lock(usb_dev_ptr->mutex);
   \                     ??usb_device_unregister_service_0: (+1)
   \   0000000C   0x.... 0x....      BL       sys_lock
    913          
    914              for (i = 0; i < MAX_DEVICE_SERVICE_NUMBER; i++)
   \   00000010   0x2000             MOVS     R0,#+0
    915              {
    916                  service_ptr = &usb_dev_ptr->services[i];
   \                     ??usb_device_unregister_service_1: (+1)
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   00000018   0x313C             ADDS     R1,R1,#+60
    917                  if (service_ptr->type == type)
   \   0000001A   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001C   0x42AA             CMP      R2,R5
   \   0000001E   0xD108             BNE.N    ??usb_device_unregister_service_2
    918                  {
    919                      service_ptr->type    = (uint8_t)-1;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x7208             STRB     R0,[R1, #+8]
    920                      service_ptr->service = NULL;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6008             STR      R0,[R1, #+0]
    921                      service_ptr->arg     = NULL;
   \   00000028   0x6048             STR      R0,[R1, #+4]
    922                      OS_Mutex_unlock(usb_dev_ptr->mutex);
   \   0000002A   0x.... 0x....      BL       sys_unlock
    923                      return USB_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    924                  }
    925              }
   \                     ??usb_device_unregister_service_2: (+1)
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD3EC             BCC.N    ??usb_device_unregister_service_1
    926           
    927              OS_Mutex_unlock(usb_dev_ptr->mutex);
   \   00000038   0x.... 0x....      BL       sys_unlock
    928              return USBERR_CLOSED_SERVICE;
   \   0000003C   0x2083             MOVS     R0,#+131
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    929          } /* EndBody */
    930          
    931          /*FUNCTION*-------------------------------------------------------------
    932          *
    933          *  Function Name  : usb_device_deinit_endpoint
    934          *  Returned Value : USB_OK or error code
    935          *  Comments       :
    936          *  Disables the endpoint and the data structures associated with the 
    937          *  endpoint
    938          *
    939          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    940          usb_status usb_device_deinit_endpoint
    941          (
    942              /* [IN] the USB_USB_dev_initialize state structure */
    943              usb_device_handle         handle,
    944              /* [IN] the Endpoint number */
    945              uint8_t                    ep_num,
    946              /* [IN] Direction */
    947              uint8_t                    direction
    948          )
    949          {
   \                     usb_device_deinit_endpoint: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    950              uint8_t                      error = 0;
    951              usb_dev_state_struct_t*      usb_dev_ptr;
    952           
    953              if (handle == NULL)
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000006   0xD009             BEQ.N    ??usb_device_deinit_endpoint_0
    954              {
    955                  return USBERR_ERROR;
    956              }
    957              
    958              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
    959              OS_Mutex_lock(usb_dev_ptr->mutex);
   \   00000008   0x.... 0x....      BL       sys_lock
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x69C3             LDR      R3,[R0, #+28]
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xD003             BEQ.N    ??usb_device_deinit_endpoint_0
    960           
    961              if (((usb_dev_interface_functions_struct_t*)
    962                 usb_dev_ptr->usb_dev_interface)->dev_deinit_endoint != NULL) 
    963              {
    964                   error = ((usb_dev_interface_functions_struct_t*)
    965                       usb_dev_ptr->usb_dev_interface)->dev_deinit_endoint(usb_dev_ptr->controller_handle, 
    966                       ep_num, direction);
   \   00000014   0x.... 0x....      BL       ?Subroutine6
    967              }
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000018   0x4798             BLX      R3
   \   0000001A   0x....             B.N      ?Subroutine0
    968              else
    969              {
    970                   #if _DEBUG
    971                       USB_PRINTF("usb_device_deinit_endpoint: DEV_DEINIT_ENDPOINT is NULL\n");                     
    972                   #endif  
    973                   return USBERR_ERROR;
   \                     ??usb_device_deinit_endpoint_0: (+1)
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    974              }
    975          
    976          	OS_Mutex_unlock(usb_dev_ptr->mutex);
    977              return error;
    978          } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x.... 0x....      B.W      sys_unlock

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000004   0xB2E0             UXTB     R0,R4
   \   00000006   0xBD70             POP      {R4-R6,PC}
    979          
    980          /*FUNCTION*-------------------------------------------------------------
    981          *
    982          *  Function Name  : usb_device_recv_data
    983          *  Returned Value : USB_OK or error code
    984          *  Comments       :
    985          *        Receives data on a specified endpoint.
    986          *
    987          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    988          usb_status usb_device_recv_data
    989          (
    990              /* [IN] the USB_USB_dev_initialize state structure */
    991              usb_device_handle           handle,
    992              /* [IN] the Endpoint number */
    993              uint8_t                     ep_num,
    994              /* [IN] buffer to receive data */
    995              uint8_t *                   buff_ptr,
    996              /* [IN] length of the transfer */
    997              uint32_t                    size
    998          )
    999          {
   \                     usb_device_recv_data: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
   1000              usb_status                       error = USB_OK;
   1001              xd_struct_t*                     xd_ptr;
   1002              usb_dev_state_struct_t*          usb_dev_ptr;
   1003          
   1004              if (handle == NULL)
   \   0000000A   0xD01B             BEQ.N    ??usb_device_recv_data_0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x6C82             LDR      R2,[R0, #+72]
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xD017             BEQ.N    ??usb_device_recv_data_0
   1005              {
   1006                  return USBERR_ERROR;
   1007              }
   1008          
   1009              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1010              if (((usb_dev_interface_functions_struct_t*)\
   1011                   usb_dev_ptr->usb_dev_interface)->dev_get_xd != NULL)
   1012              {
   1013                  error = ((usb_dev_interface_functions_struct_t*)\
   1014                      usb_dev_ptr->usb_dev_interface)->dev_get_xd(usb_dev_ptr->controller_handle, &xd_ptr);    
   1015                  
   1016                  if (USB_OK != error)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x4790             BLX      R2
   \   0000001A   0xB998             CBNZ.N   R0,??usb_device_recv_data_0
   1017                  {
   1018                      #if _DEBUG
   1019                          USB_PRINTF("usb_device_recv_data: DEV_GET_XD failed\n");
   1020                      #endif
   1021                      return USBERR_ERROR;
   1022                  }
   1023              }
   1024              else
   1025              {
   1026                  #if _DEBUG
   1027                      USB_PRINTF("usb_device_recv_data: DEV_GET_XD is NULL\n");
   1028                  #endif  
   1029                  return USBERR_ERROR;
   1030              }
   1031               
   1032          	OS_Mutex_lock(usb_dev_ptr->mutex);
   \   0000001C   0x.... 0x....      BL       sys_lock
   1033           
   1034              /* Initialize the new transfer descriptor */
   1035              xd_ptr->ep_num = ep_num;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x7007             STRB     R7,[R0, #+0]
   1036              xd_ptr->bdirection = USB_RECV;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       ?Subroutine3
   1037              xd_ptr->wtotallength = size;
   1038              xd_ptr->wstartaddress = buff_ptr;
   1039              xd_ptr->wsofar = 0;
   1040              xd_ptr->bstatus = USB_STATUS_TRANSFER_ACCEPTED;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000002A   0x6902             LDR      R2,[R0, #+16]
   \   0000002C   0x0010             MOVS     R0,R2
   \   0000002E   0xD009             BEQ.N    ??usb_device_recv_data_0
   1041           
   1042              if (((usb_dev_interface_functions_struct_t*)\
   1043                 usb_dev_ptr->usb_dev_interface)->dev_recv != NULL)
   1044              {
   1045          #if (USBCFG_BUFF_PROPERTY_CACHEABLE)  
   1046                  if (size > 0)
   1047                  {
   1048                      OS_dcache_invalidate_mlines((void*)buff_ptr, size);
   1049                  }
   1050          #endif 
   1051                  error = ((usb_dev_interface_functions_struct_t*)\
   1052                           usb_dev_ptr->usb_dev_interface)->dev_recv(usb_dev_ptr->controller_handle, xd_ptr);  
   \   00000030   0x9900             LDR      R1,[SP, #+0]
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4790             BLX      R2
   \   00000036   0x.... 0x....      BL       ?Subroutine5
   1053              }
   1054              else
   1055              {
   1056                  #if _DEBUG
   1057                  USB_PRINTF("usb_device_recv_data: DEV_RECV is NULL\n");                      
   1058                  #endif    
   1059                  return USBERR_ERROR;
   1060              }
   1061          
   1062          	OS_Mutex_unlock(usb_dev_ptr->mutex);
   1063              if (error) 
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xBF0C             ITE      EQ 
   \   0000003E   0x2000             MOVEQ    R0,#+0
   \   00000040   0x2094             MOVNE    R0,#+148
   1064              {
   1065                  return USBERR_RX_FAILED;
   1066              } /* Endif */
   1067          
   1068              return error;
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??usb_device_recv_data_0: (+1)
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}
   1069          } /* EndBody */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x9900             LDR      R1,[SP, #+0]
   \   00000002   0x7048             STRB     R0,[R1, #+1]
   \   00000004   0x9800             LDR      R0,[SP, #+0]
   \   00000006   0x6086             STR      R6,[R0, #+8]
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0x6045             STR      R5,[R0, #+4]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9900             LDR      R1,[SP, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   \   00000012   0x2006             MOVS     R0,#+6
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x70C8             STRB     R0,[R1, #+3]
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x4770             BX       LR
   1070          
   1071          /*FUNCTION*-------------------------------------------------------------
   1072          *
   1073          *  Function Name  : usb_device_send_data
   1074          *  Returned Value : USB_OK or error code
   1075          *  Comments       :
   1076          *        Sends data on a specified endpoint.
   1077          *
   1078          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1079          usb_status usb_device_send_data
   1080          (
   1081              /* [IN] the USB_USB_dev_initialize state structure */
   1082              usb_device_handle           handle,
   1083              /* [IN] the Endpoint number */
   1084              uint8_t                    ep_num,
   1085              /* [IN] buffer to send */
   1086              uint8_t *                  buff_ptr,
   1087              /* [IN] length of the transfer */
   1088              uint32_t                   size
   1089          )
   1090          { /* Body */
   \                     usb_device_send_data: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
   1091              usb_status                       error;
   1092              xd_struct_t*                     xd_ptr;
   1093              usb_dev_state_struct_t*          usb_dev_ptr;
   1094          
   1095              if (handle == NULL)
   \   0000000A   0xD01B             BEQ.N    ??usb_device_send_data_0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x6C82             LDR      R2,[R0, #+72]
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xD017             BEQ.N    ??usb_device_send_data_0
   1096              {
   1097                  #if _DEBUG
   1098                      USB_PRINTF("usb_device_send_data: handle is NULL\n");
   1099                  #endif  
   1100                  return USBERR_ERROR;
   1101              }
   1102          
   1103              usb_dev_ptr = (usb_dev_state_struct_t*)handle;   
   1104          
   1105              if (((usb_dev_interface_functions_struct_t*)\
   1106                  usb_dev_ptr->usb_dev_interface)->dev_get_xd != NULL)
   1107              {
   1108                  error = ((usb_dev_interface_functions_struct_t*)\
   1109                      usb_dev_ptr->usb_dev_interface)->dev_get_xd(usb_dev_ptr->controller_handle, &xd_ptr);    
   1110                  
   1111                  if (USB_OK != error)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x4790             BLX      R2
   \   0000001A   0xB998             CBNZ.N   R0,??usb_device_send_data_0
   1112                  {
   1113                      #if _DEBUG
   1114                          USB_PRINTF("usb_device_send_data: DEV_GET_XD failed\n");
   1115                      #endif
   1116                      return USBERR_ERROR;
   1117                  }
   1118              }
   1119              else
   1120              {
   1121                  #if _DEBUG
   1122                      USB_PRINTF("usb_device_send_data: DEV_GET_XD is NULL\n");
   1123                  #endif  
   1124                  return USBERR_ERROR;
   1125              }
   1126              
   1127              OS_Mutex_lock(usb_dev_ptr->mutex);
   \   0000001C   0x.... 0x....      BL       sys_lock
   1128          
   1129              /* Initialize the new transfer descriptor */      
   1130              xd_ptr->ep_num = ep_num;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x7007             STRB     R7,[R0, #+0]
   1131              xd_ptr->bdirection = USB_SEND;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       ?Subroutine3
   1132              xd_ptr->wtotallength = size;
   1133              xd_ptr->wstartaddress = buff_ptr;
   1134              xd_ptr->wsofar = 0;
   1135              xd_ptr->bstatus = USB_STATUS_TRANSFER_ACCEPTED;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000002A   0x68C2             LDR      R2,[R0, #+12]
   \   0000002C   0x0010             MOVS     R0,R2
   \   0000002E   0xD009             BEQ.N    ??usb_device_send_data_0
   1136              
   1137              if (((usb_dev_interface_functions_struct_t*)\
   1138                  usb_dev_ptr->usb_dev_interface)->dev_send != NULL)
   1139              {
   1140          #if (USBCFG_BUFF_PROPERTY_CACHEABLE)  
   1141                  if (size > 0)
   1142                  {
   1143                      /********************************************************
   1144                       If system has a data cache, it is assumed that buffer
   1145                       passed to this routine will be aligned on a cache line
   1146                       boundry. The following code will flush the
   1147                       buffer before passing it to hardware driver.   
   1148                       ********************************************************/
   1149                      OS_dcache_flush_mlines((void*)buff_ptr, size);
   1150                  }
   1151          #endif 
   1152                  error = ((usb_dev_interface_functions_struct_t*)\
   1153                      usb_dev_ptr->usb_dev_interface)->dev_send(usb_dev_ptr->controller_handle, xd_ptr);    
   \   00000030   0x9900             LDR      R1,[SP, #+0]
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4790             BLX      R2
   \   00000036   0x.... 0x....      BL       ?Subroutine5
   1154              }
   1155              else
   1156              {
   1157                  #if _DEBUG
   1158                      USB_PRINTF("usb_device_send_data: DEV_SEND is NULL\n");
   1159                  #endif  
   1160                  return USBERR_ERROR;
   1161              }
   1162          
   1163          	OS_Mutex_unlock(usb_dev_ptr->mutex);
   1164              if (error) 
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xBF0C             ITE      EQ 
   \   0000003E   0x2000             MOVEQ    R0,#+0
   \   00000040   0x2093             MOVNE    R0,#+147
   1165              {
   1166                  #if _DEBUG
   1167                      USB_PRINTF("usb_device_send_data, transfer failed\n");
   1168                  #endif  
   1169                  return USBERR_TX_FAILED;
   1170              }
   1171              return error;
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??usb_device_send_data_0: (+1)
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}
   1172          } 
   1173          
   1174          /*FUNCTION*-------------------------------------------------------------
   1175          *
   1176          *  Function Name  : usb_device_unstall_endpoint
   1177          *  Returned Value : USB_OK or error code
   1178          *  Comments       :
   1179          *     Unstalls the endpoint in specified direction
   1180          *
   1181          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1182          usb_status usb_device_unstall_endpoint
   1183          (
   1184              /* [IN] the USB_USB_dev_initialize state structure */
   1185              usb_device_handle          handle,
   1186              /* [IN] the Endpoint number */
   1187              uint8_t                    ep_num,
   1188              /* [IN] direction */
   1189              uint8_t                    direction
   1190          )
   1191          {
   \                     usb_device_unstall_endpoint: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
   1192              usb_status                       error = USB_OK;
   1193              usb_dev_state_struct_t*          usb_dev_ptr;
   1194              
   1195              if (handle  == NULL)
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000006   0xD00C             BEQ.N    ??usb_device_unstall_endpoint_0
   1196              {
   1197                 #if _DEBUG
   1198                    USB_PRINTF("usb_device_unstall_endpoint: handle is NULL\n");
   1199                 #endif    
   1200                 return USBERR_ERROR;
   1201              }
   1202              
   1203              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1204           
   1205              OS_Mutex_lock(usb_dev_ptr->mutex);
   \   00000008   0x.... 0x....      BL       sys_lock
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x6A03             LDR      R3,[R0, #+32]
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xD006             BEQ.N    ??usb_device_unstall_endpoint_0
   1206          
   1207              if (((usb_dev_interface_functions_struct_t*)\
   1208                 usb_dev_ptr->usb_dev_interface)->dev_unstall_endpoint != NULL)
   1209              {
   1210                  error= ((usb_dev_interface_functions_struct_t*)\
   1211                  usb_dev_ptr->usb_dev_interface)->dev_unstall_endpoint(usb_dev_ptr->controller_handle, ep_num, direction);   
   \   00000014   0x.... 0x....      BL       ?Subroutine6
   1212              }
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000018   0x4798             BLX      R3
   \   0000001A   0x.... 0x....      BL       ?Subroutine5
   1213              else
   1214              {
   1215                  return USBERR_ERROR;
   1216              }
   1217          	OS_Mutex_unlock(usb_dev_ptr->mutex);
   1218              return error;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xBD70             POP      {R4-R6,PC}
   \                     ??usb_device_unstall_endpoint_0: (+1)
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
   1219          } /* EndBody */
   1220          
   1221          /*FUNCTION*-------------------------------------------------------------
   1222          *
   1223          *  Function Name  : usb_device_stall_endpoint
   1224          *  Returned Value : USB_OK or error code
   1225          *  Comments       :
   1226          *     Stalls the endpoint.
   1227          *
   1228          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1229          usb_status usb_device_stall_endpoint
   1230          (
   1231              /* [IN] the USB_USB_dev_initialize state structure */
   1232              usb_device_handle          handle,
   1233              /* [IN] the Endpoint number */
   1234              uint8_t                    ep_num,
   1235              /* [IN] direction */
   1236              uint8_t                    direction
   1237          )
   1238          {
   \                     usb_device_stall_endpoint: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1239              usb_status                            error = 0;
   1240              usb_dev_state_struct_t*               usb_dev_ptr;
   1241          
   1242              if (handle == NULL)
   \   00000002   0xB138             CBZ.N    R0,??usb_device_stall_endpoint_0
   \   00000004   0x6843             LDR      R3,[R0, #+4]
   \   00000006   0x6BDB             LDR      R3,[R3, #+60]
   \   00000008   0x001C             MOVS     R4,R3
   \   0000000A   0xD003             BEQ.N    ??usb_device_stall_endpoint_0
   1243              {
   1244                 #if _DEBUG
   1245                   USB_PRINTF("usb_device_stall_endpoint: handle is NULL\n");
   1246                 #endif    
   1247                 return USBERR_ERROR;
   1248              }
   1249              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1250           
   1251              if (((usb_dev_interface_functions_struct_t*)
   1252              usb_dev_ptr->usb_dev_interface)->dev_stall_endpoint
   1253                  != NULL)
   1254              {
   1255                  error = ((usb_dev_interface_functions_struct_t*)
   1256                      usb_dev_ptr->usb_dev_interface)->dev_stall_endpoint(usb_dev_ptr->controller_handle, 
   1257                      ep_num, direction);
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x4718             BX       R3
   1258              }
   1259              else
   1260              {
   1261                  #if _DEBUG
   1262                      USB_PRINTF("usb_device_stall_endpoint: DEV_STALL_ENDPOINT is NULL\n");             
   1263                  #endif  
   1264                  error = USBERR_ERROR;
   \                     ??usb_device_stall_endpoint_0: (+1)
   \   00000014   0x20FF             MOVS     R0,#+255
   1265              }
   1266              
   1267              return  error;
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1268          } 
   1269          
   1270          /*FUNCTION*-------------------------------------------------------------
   1271          *
   1272          *  Function Name  : usb_device_register_application_notify
   1273          *  Returned Value : USB_OK or error code
   1274          *  Comments       :
   1275          *        Process Resume event
   1276          *
   1277          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1278          usb_status usb_device_register_application_notify
   1279          (
   1280              /* [IN] the USB_USB_dev_initialize state structure */
   1281              usb_device_handle         handle,
   1282              usb_device_notify_t       device_notify_callback,
   1283              void*                     device_notify_param
   1284          )
   1285          {
   1286              usb_dev_state_struct_t*               usb_dev_ptr;
   1287              usb_status                            error = USB_OK;
   1288               
   1289              if (handle == NULL)
   \                     usb_device_register_application_notify: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF0F             ITEEE    EQ 
   \   00000004   0x20FF             MOVEQ    R0,#+255
   \   00000006   0x6201             STRNE    R1,[R0, #+32]
   \   00000008   0x6242             STRNE    R2,[R0, #+36]
   \   0000000A   0x2000             MOVNE    R0,#+0
   1290              {
   1291                  #if _DEBUG
   1292                  USB_PRINTF("usb_device_register_application_notify: handle is NULL\n");
   1293                  #endif    
   1294                  return USBERR_ERROR;
   1295              }
   1296              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1297           
   1298              usb_dev_ptr->usb_framework.device_notify_callback = device_notify_callback;
   1299              usb_dev_ptr->usb_framework.device_notify_param = device_notify_param;
   1300              return error;
   \   0000000C   0x4770             BX       LR
   1301          }
   1302          
   1303          /*FUNCTION*-------------------------------------------------------------
   1304          *
   1305          *  Function Name  : usb_device_register_vendor_class_request_notify
   1306          *  Returned Value : USB_OK or error code
   1307          *  Comments       :
   1308          *        Process Resume event
   1309          *
   1310          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1311          usb_status usb_device_register_vendor_class_request_notify
   1312          (
   1313              /* [IN] the USB_USB_dev_initialize state structure */
   1314              usb_device_handle         handle,
   1315              usb_request_notify_t      request_notify_callback,
   1316              void*                     request_notify_param
   1317          )
   1318          {
   1319              usb_dev_state_struct_t*               usb_dev_ptr;
   1320              usb_status                            error = USB_OK;
   1321           
   1322              if (handle == NULL)
   \                     usb_device_register_vendor_class_request_notify: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF0F             ITEEE    EQ 
   \   00000004   0x20FF             MOVEQ    R0,#+255
   \   00000006   0x6281             STRNE    R1,[R0, #+40]
   \   00000008   0x62C2             STRNE    R2,[R0, #+44]
   \   0000000A   0x2000             MOVNE    R0,#+0
   1323              {
   1324                  #if _DEBUG
   1325                  USB_PRINTF("usb_device_register_vendor_class_request_notify: handle is NULL\n");
   1326                  #endif    
   1327                  return USBERR_ERROR;
   1328              }
   1329              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1330          
   1331              usb_dev_ptr->usb_framework.request_notify_callback = request_notify_callback;
   1332              usb_dev_ptr->usb_framework.request_notify_param = request_notify_param;
   1333          
   1334              return error;
   \   0000000C   0x4770             BX       LR
   1335          }
   1336          
   1337          /*FUNCTION*-------------------------------------------------------------
   1338          *
   1339          *  Function Name  : usb_device_register_desc_request_notify
   1340          *  Returned Value : USB_OK or error code
   1341          *  Comments       :
   1342          *        
   1343          *
   1344          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1345          usb_status usb_device_register_desc_request_notify
   1346          (
   1347              /* [IN] the USB_USB_dev_initialize state structure */
   1348              usb_device_handle              handle,
   1349              usb_desc_request_notify_struct_t*  desc_request_notify_callback,
   1350              void*                           desc_request_notify_param
   1351          )
   1352          {
   1353              usb_dev_state_struct_t*               usb_dev_ptr;
   1354              usb_status                            error = USB_OK;
   1355          
   1356              if (handle == NULL)
   \                     usb_device_register_desc_request_notify: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF0F             ITEEE    EQ 
   \   00000004   0x20FF             MOVEQ    R0,#+255
   \   00000006   0x6301             STRNE    R1,[R0, #+48]
   \   00000008   0x6342             STRNE    R2,[R0, #+52]
   \   0000000A   0x2000             MOVNE    R0,#+0
   1357              {
   1358              #if _DEBUG
   1359                 USB_PRINTF("usb_device_register_desc_request_notify\n");
   1360              #endif    
   1361                 return USBERR_ERROR;
   1362              }
   1363              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1364               
   1365              usb_dev_ptr->usb_framework.desc_notify_callback = desc_request_notify_callback;
   1366              usb_dev_ptr->usb_framework.desc_notify_param    = desc_request_notify_param;
   1367              
   1368              return error;
   \   0000000C   0x4770             BX       LR
   1369          }
   1370          #if USBCFG_DEV_ADVANCED_CANCEL_ENABLE
   1371          /*FUNCTION*-------------------------------------------------------------
   1372          *
   1373          *  Function Name  : usb_device_cancel_transfer
   1374          *  Returned Value : USB_OK or error code
   1375          *  Comments       :
   1376          *        returns the status of the transaction on the specified endpoint.
   1377          *
   1378          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1379          usb_status usb_device_cancel_transfer
   1380          (
   1381              /* [IN] the USB_USB_dev_initialize state structure */
   1382              usb_device_handle         handle,
   1383              /* [IN] the Endpoint number */
   1384              uint8_t                     ep_num,
   1385              /* [IN] direction */
   1386              uint8_t                     direction
   1387          )
   1388          { 
   \                     usb_device_cancel_transfer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
   1389              uint8_t                        error = USB_OK;
   1390              usb_dev_state_struct_t*        usb_dev_ptr;
   1391              if (handle == NULL)
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000006   0xD009             BEQ.N    ??usb_device_cancel_transfer_0
   1392              {
   1393                  #if _DEBUG
   1394                      USB_PRINTF("_usb_device_shutdowna: handle is NULL\n");
   1395                  #endif  
   1396                  return USBERR_ERROR;
   1397              }
   1398              
   1399              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1400              OS_Mutex_lock(usb_dev_ptr->mutex);
   \   00000008   0x.... 0x....      BL       sys_lock
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x6943             LDR      R3,[R0, #+20]
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xD003             BEQ.N    ??usb_device_cancel_transfer_0
   1401              
   1402              /* Cancel transfer on the specified endpoint for the specified 
   1403               ** direction 
   1404               */
   1405              if (((usb_dev_interface_functions_struct_t*)
   1406                usb_dev_ptr->usb_dev_interface)->dev_cancel_transfer != NULL)   
   1407              {
   1408                  error = ((usb_dev_interface_functions_struct_t*)
   1409                      usb_dev_ptr->usb_dev_interface)->dev_cancel_transfer(usb_dev_ptr->controller_handle, 
   1410                      ep_num, direction);
   \   00000014   0x.... 0x....      BL       ?Subroutine6
   1411              }
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000018   0x4798             BLX      R3
   \   0000001A   0x....             B.N      ?Subroutine0
   1412              else
   1413              {
   1414                  #if _DEBUG
   1415                      USB_PRINTF("usb_device_cancel_transfer: dev_cancel_transfer is NULL\n");               
   1416                  #endif  
   1417                  return USBERR_ERROR;
   \                     ??usb_device_cancel_transfer_0: (+1)
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
   1418              }
   1419          
   1420          	OS_Mutex_unlock(usb_dev_ptr->mutex);
   1421          
   1422              return error;
   1423          }
   1424          #endif
   1425          
   1426          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME
   1427          /*FUNCTION*-------------------------------------------------------------
   1428          *
   1429          *  Function Name  : usb_device_process_resume
   1430          *  Returned Value : USB_OK or error code
   1431          *  Comments       :
   1432          *        Process Resume event
   1433          *
   1434          *END*-----------------------------------------------------------------*/
   1435          usb_status usb_device_assert_resume
   1436          (
   1437              /* [IN] the USB_USB_dev_initialize state structure */
   1438              usb_device_handle         handle
   1439          )
   1440          {
   1441              usb_dev_state_struct_t*               usb_dev_ptr;
   1442              usb_status                            error = USB_OK;
   1443               
   1444              if (handle == NULL)
   1445              {
   1446                 #if _DEBUG
   1447                   USB_PRINTF("usb_device_assert_resume: handle is NULL\n");
   1448                 #endif    
   1449                 return USBERR_ERROR;
   1450              }
   1451              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1452          
   1453              if (((usb_dev_interface_functions_struct_t*)
   1454                   usb_dev_ptr->usb_dev_interface)->dev_assert_resume != NULL)
   1455              {
   1456                  error= ((usb_dev_interface_functions_struct_t*)\
   1457                      usb_dev_ptr->usb_dev_interface)->dev_assert_resume(usb_dev_ptr->controller_handle);
   1458              }
   1459              else
   1460              {
   1461                  #if _DEBUG
   1462                      USB_PRINTF("usb_device_assert_resume: dev_assert_resume is NULL\n");               
   1463                  #endif  
   1464                  error = USBERR_ERROR;
   1465              }
   1466              
   1467              return error;
   1468          }
   1469          #endif
   1470          
   1471          #ifdef USBCFG_OTG
   1472          /*FUNCTION*-------------------------------------------------------------
   1473          *
   1474          *  Function Name  : usb_device_otg_init
   1475          *  Returned Value : USB_OK or error code
   1476          *  Comments       :
   1477          *        Process Resume event
   1478          *
   1479          *END*-----------------------------------------------------------------*/
   1480          usb_status usb_device_otg_init
   1481          (
   1482              usb_device_handle handle, 
   1483              uint8_t     otg_attributes
   1484          )    
   1485          {
   1486              usb_status error;
   1487              usb_khci_dev_state_struct_t* khci_dev_state_ptr;
   1488              if (handle == NULL)
   1489              {
   1490                  return USBERR_ERROR;
   1491              }
   1492              khci_dev_state_ptr = ((usb_dev_state_struct_t*)handle)->controller_handle;
   1493              khci_dev_state_ptr->otg_attr_srp = (otg_attributes & OTG_SRP_SUPPORT)?(TRUE):(FALSE);
   1494              khci_dev_state_ptr->otg_attr_hnp = (otg_attributes & OTG_HNP_SUPPORT)?(TRUE):(FALSE);
   1495              error = usb_otg_device_on_class_init(khci_dev_state_ptr->otg_handle, handle , otg_attributes );
   1496          
   1497              return error;
   1498          }
   1499          
   1500          /*FUNCTION*-------------------------------------------------------------
   1501          *
   1502          *  Function Name  : usb_device_otg_get_hnp_support
   1503          *  Returned Value : USB_OK or error code
   1504          *  Comments       :
   1505          *        Process Resume event
   1506          *
   1507          *END*-----------------------------------------------------------------*/
   1508          usb_status usb_device_otg_get_hnp_support
   1509          (
   1510              usb_device_handle handle, 
   1511              uint8_t*    hnp_support_ptr 
   1512          )
   1513          {
   1514              usb_khci_dev_state_struct_t* khci_dev_state_ptr;
   1515          
   1516              if (handle == NULL)
   1517              {
   1518                  *hnp_support_ptr = 0;
   1519                  return USBERR_ERROR;
   1520              }
   1521              khci_dev_state_ptr = ((usb_dev_state_struct_t*)handle)->controller_handle;
   1522              *hnp_support_ptr = khci_dev_state_ptr->otg_attr_hnp;
   1523              return USB_OK;
   1524          }
   1525          
   1526          /*FUNCTION*-------------------------------------------------------------
   1527          *
   1528          *  Function Name  : usb_device_otg_set_hnp_enable
   1529          *  Returned Value : USB_OK or error code
   1530          *  Comments       :
   1531          *        Process Resume event
   1532          *
   1533          *END*-----------------------------------------------------------------*/
   1534          usb_status usb_device_otg_set_hnp_enable
   1535          (
   1536              usb_device_handle handle
   1537          )
   1538          {
   1539              usb_khci_dev_state_struct_t* khci_dev_state_ptr;
   1540              if (handle == NULL)
   1541              {
   1542                  return USBERR_ERROR;
   1543              }
   1544              khci_dev_state_ptr = ((usb_dev_state_struct_t*)handle)->controller_handle;
   1545              return usb_otg_device_hnp_enable(khci_dev_state_ptr->otg_handle, TRUE);
   1546          }
   1547          #endif /* USBCFG_OTG */
   1548          
   1549          
   1550          /*FUNCTION*-------------------------------------------------------------
   1551          *
   1552          *  Function Name  : usb_device_reset
   1553          *  Returned Value : USB_OK or error code
   1554          *  Comments       :
   1555          *        reset device.
   1556          *
   1557          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1558          usb_status usb_device_reset
   1559          (
   1560              /* [IN] the USB_USB_dev_initialize state structure */
   1561              usb_device_handle           handle
   1562          )
   1563          {
   1564              usb_status                       error = USB_OK;
   1565              usb_dev_state_struct_t*          usb_dev_ptr;
   1566          
   1567              if (handle == NULL)
   \                     usb_device_reset: (+1)
   \   00000000   0xB128             CBZ.N    R0,??usb_device_reset_0
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x6CC9             LDR      R1,[R1, #+76]
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xBF1C             ITT      NE 
   1568              {
   1569                  return USBERR_ERROR;
   1570              }
   1571          
   1572              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1573           
   1574              if (((usb_dev_interface_functions_struct_t*)\
   1575                 usb_dev_ptr->usb_dev_interface)->dev_reset != NULL)
   1576              {
   1577                  error = ((usb_dev_interface_functions_struct_t*)\
   1578                           usb_dev_ptr->usb_dev_interface)->dev_reset(usb_dev_ptr->controller_handle);  
   1579              }
   1580              else
   1581              {
   1582                  #if _DEBUG
   1583                  USB_PRINTF("usb_device_reset: dev_reset is NULL\n");                      
   1584                  #endif    
   1585                  return USBERR_ERROR;
   1586              }
   1587          
   1588              return error;
   \   0000000A   0x6800             LDRNE    R0,[R0, #+0]
   \   0000000C   0x4708             BXNE     R1
   \                     ??usb_device_reset_0: (+1)
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0x4770             BX       LR               ;; return
   1589          } /* EndBody */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     g_usb_dev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     g_usb_dev_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x........         DC32     _usb_khci_dev_function_table
   1590          
   1591          
   1592          #if USBCFG_DEV_EHCI_TEST_MODE
   1593          /*FUNCTION*-------------------------------------------------------------
   1594          *
   1595          *  Function Name  : usb_device_set_test_mode
   1596          *  Returned Value : USB_OK or error code
   1597          *  Comments       :
   1598          *     Stalls the endpoint.
   1599          *
   1600          *END*-----------------------------------------------------------------*/
   1601          usb_status usb_device_set_test_mode
   1602          (
   1603              /* [IN] the USB_USB_dev_initialize state structure */
   1604              usb_device_handle          handle,
   1605              /* [IN] the Endpoint number */
   1606              uint16_t                   testmode
   1607          )
   1608          {
   1609              usb_status                            error = 0;
   1610              usb_dev_state_struct_t*               usb_dev_ptr;
   1611          
   1612              if (handle == NULL)
   1613              {
   1614                 #if _DEBUG
   1615                   USB_PRINTF("usb_device_set_test_mode: handle is NULL\n");
   1616                 #endif    
   1617                 return USBERR_ERROR;
   1618              }
   1619              usb_dev_ptr = (usb_dev_state_struct_t*)handle;
   1620           
   1621              if (((usb_dev_interface_functions_struct_t*)
   1622              usb_dev_ptr->usb_dev_interface)->dev_set_test_mode
   1623                  != NULL)
   1624              {
   1625                  error = ((usb_dev_interface_functions_struct_t*)
   1626                      usb_dev_ptr->usb_dev_interface)->dev_set_test_mode(usb_dev_ptr->controller_handle, 
   1627                      testmode);
   1628              }
   1629              else
   1630              {
   1631                  #if _DEBUG
   1632                      USB_PRINTF("usb_device_set_test_mode: dev_set_test_mode is NULL\n");             
   1633                  #endif  
   1634                  error = USBERR_ERROR;
   1635              }
   1636              
   1637              return  error;
   1638          }
   1639          #endif 
   1640          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _usb_device_call_service
         0   -> _usb_device_call_service_internal
      16   _usb_device_call_service_internal
        16   -- Indirect call
        16   -> USB_Control_Service
        16   -> USB_Reset_Service
       0   _usb_device_set_address
         0   -- Indirect call
      16   usb_device_cancel_transfer
        16   -- Indirect call
        16   -> sys_lock
        16   -> sys_unlock
      16   usb_device_deinit
        16   -- Indirect call
        16   -> OS_Mutex_destroy
      16   usb_device_deinit_endpoint
        16   -- Indirect call
        16   -> sys_lock
        16   -> sys_unlock
      16   usb_device_get_status
        16   -- Indirect call
        16   -> sys_lock
        16   -> sys_unlock
      24   usb_device_init
        24   -- Indirect call
        24   -> OS_Mutex_create
        24   -> bsp_usb_dev_init
        24   -> memset
      32   usb_device_init_endpoint
        32   -- Indirect call
       8   usb_device_postinit
         0   -- Indirect call
      24   usb_device_recv_data
        24   -- Indirect call
        24   -> sys_lock
        24   -> sys_unlock
       0   usb_device_register_application_notify
       0   usb_device_register_desc_request_notify
      24   usb_device_register_service
        24   -> sys_lock
        24   -> sys_unlock
       0   usb_device_register_vendor_class_request_notify
       0   usb_device_reset
         0   -- Indirect call
      24   usb_device_send_data
        24   -- Indirect call
        24   -> sys_lock
        24   -> sys_unlock
      16   usb_device_set_status
        16   -- Indirect call
        16   -> sys_lock
        16   -> sys_unlock
       8   usb_device_stall_endpoint
         0   -- Indirect call
      16   usb_device_unregister_service
        16   -> sys_lock
        16   -> sys_unlock
      16   usb_device_unstall_endpoint
        16   -- Indirect call
        16   -> sys_lock
        16   -> sys_unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      28  ?Subroutine3
      10  ?Subroutine4
       6  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
      30  _usb_device_call_service
      78  _usb_device_call_service_internal
      16  _usb_device_set_address
     164  g_usb_dev
      96  g_usb_dev_data
      32  usb_device_cancel_transfer
      38  usb_device_deinit
      32  usb_device_deinit_endpoint
      42  usb_device_get_status
     176  usb_device_init
      62  usb_device_init_endpoint
      24  usb_device_postinit
      72  usb_device_recv_data
      14  usb_device_register_application_notify
      14  usb_device_register_desc_request_notify
      90  usb_device_register_service
      14  usb_device_register_vendor_class_request_notify
      18  usb_device_reset
      72  usb_device_send_data
      24  usb_device_set_status
      24  usb_device_stall_endpoint
      64  usb_device_unregister_service
      38  usb_device_unstall_endpoint

 
   164 bytes in section .bss
    96 bytes in section .noinit
 1 070 bytes in section .text
 
 1 070 bytes of CODE memory
   260 bytes of DATA memory

Errors: none
Warnings: none
