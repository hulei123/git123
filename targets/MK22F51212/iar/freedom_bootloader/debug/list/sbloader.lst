###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:25
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\sbloader\src\sbloader.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\sbloader\src\sbloader.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\sbloader.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\sbloader.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\sbloader\src\sbloader.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <stdint.h>
     32          #include <stdio.h>
     33          #include <string.h>
     34          #include "sbloader/sbloader.h"
     35          #include "bootloader/context.h"
     36          #include "bootloader/bootloader.h"
     37          #include "bootloader/shutdown_cleanup.h"
     38          #if BL_FEATURE_ENCRYPTION
     39          #include "security/aes_security.h"
     40          #include "security/cbc_mac.h"
     41          #endif // BL_FEATURE_ENCRYPTION
     42          #include "utilities/fsl_assert.h"
     43          
     44          #if DEBUG
     45          #include "property/property.h"
     46          #endif
     47          
     48          //! @addtogroup sbloader
     49          //! @{
     50          
     51          ////////////////////////////////////////////////////////////////////////////////
     52          // Definitions
     53          ////////////////////////////////////////////////////////////////////////////////
     54          
     55          #define SB_KEY_RDONCE_INDEX 0x30
     56          
     57          ////////////////////////////////////////////////////////////////////////////////
     58          // Prototypes
     59          ////////////////////////////////////////////////////////////////////////////////
     60          typedef struct _ldr_buf ldr_buf_t;
     61          
     62          struct _ldr_buf
     63          {
     64              chunk_t data;
     65              unsigned int fillPosition;
     66          };
     67          
     68          //! Loader utilities.
     69          int ldr_GoToNextSection(ldr_Context_t *);
     70          status_t sbloader_handle_chunk(void);
     71          
     72          //! Loader action (context.Action) functions for header processing.
     73          int ldr_DoHeader(ldr_Context_t *);
     74          int ldr_DoHeader1(ldr_Context_t *);
     75          int ldr_DoHeader2(ldr_Context_t *);
     76          int ldr_DoHeaderMac(ldr_Context_t *);
     77          int ldr_DoKeyTest(ldr_Context_t *);
     78          int ldr_DoGetDek(ldr_Context_t *);
     79          
     80          //! Loader action (context.Action) functions for command processing.
     81          status_t ldr_DoInit(ldr_Context_t *);
     82          status_t ldr_DoCommand(ldr_Context_t *);
     83          int ldr_DoLoadBytes(ldr_Context_t *);
     84          status_t ldr_DoLoadChunks(ldr_Context_t *);
     85          status_t ldr_DoLoadCmd(ldr_Context_t *);
     86          status_t ldr_DoFillCmd(ldr_Context_t *);
     87          status_t ldr_DoJumpCmd(ldr_Context_t *);
     88          status_t ldr_DoCallCmd(ldr_Context_t *);
     89          status_t ldr_DoTagCmd(ldr_Context_t *);
     90          status_t ldr_DoEraseCmd(ldr_Context_t *);
     91          
     92          ////////////////////////////////////////////////////////////////////////////////
     93          // Data
     94          ////////////////////////////////////////////////////////////////////////////////
     95          
     96          //! static loader context data.

   \                                 In section .bss, align 4
     97          static ldr_Context_t s_loaderContext;
   \                     s_loaderContext:
   \   00000000                      DS8 112
     98          
     99          //! static buffer queueing up a chunk worth of data

   \                                 In section .bss, align 4
    100          static ldr_buf_t s_loaderBuf;
   \                     s_loaderBuf:
   \   00000000                      DS8 20
    101          
    102          #if AES_SECURITY_SUPPORTED
    103          //! Pointer for the aes which will for now be a null pointer unless in debug mode
    104          //! we will try to read from the config area
    105          static uint32_t s_aesKey[AES_128_KEY_SIZE_WORDS];
    106          #endif
    107          
    108          ////////////////////////////////////////////////////////////////////////////////
    109          //! \brief  Skip ahead to the next "tag" command
    110          //!
    111          //! \This function will set up the skipCount to skip over the remainder of any section
    112          //! \that you are currently in. If encryption is enabled it will also re-init the encryption
    113          //! \process to begin on the new section it arrives at.
    114          //!
    115          //! \retval kStatus_Success
    116          //! \retval kStatusRomLdrEOFReached if the end of the image file is reached.
    117          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    118          int ldr_GoToNextSection(ldr_Context_t *context)
    119          {
    120              // If we are not in the last section of the image file, setup to get a
    121              // "tag" command then skip the remaining chunks in the section. Otherwise,
    122              // return an error.
    123              if (context->fileChunks > context->sectChunks)
   \                     ldr_GoToNextSection: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x428A             CMP      R2,R1
   \   00000006   0xD209             BCS.N    ??ldr_GoToNextSection_0
    124              {
    125                  // Skip over any remaining chunks in section, making sure to adjust
    126                  // the file chunk count.
    127                  context->fileChunks -= context->sectChunks;
   \   00000008   0x1A89             SUBS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    128                  context->skipCount = context->sectChunks;
   \   0000000C   0x6682             STR      R2,[R0, #+104]
    129          
    130                  // Setup the loader context to get the next command
    131                  context->Action = ldr_DoCommand;
   \   0000000E   0x.... 0x....      ADR.W    R1,ldr_DoCommand
   \   00000012   0x6001             STR      R1,[R0, #+0]
    132          
    133                  // Reinit the encryption for the start of a new section
    134          #if AES_SECURITY_SUPPORTED
    135                  if (context->keyCount)
    136                  {
    137                      cbc_mac_init(context->dek, context->initVector);
    138                  }
    139          #endif
    140          
    141                  // Assume for now the new section has at least one chunk
    142                  context->sectChunks = 1;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x6081             STR      R1,[R0, #+8]
    143          
    144                  return kStatus_Success;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR
    145              }
    146          
    147              // No where to skip to, so return an error
    148              return kStatusRomLdrEOFReached;
   \                     ??ldr_GoToNextSection_0: (+1)
   \   0000001C   0xF242 0x7078      MOVW     R0,#+10104
   \   00000020   0x4770             BX       LR               ;; return
    149          }
    150          
    151          ////////////////////////////////////////////////////////////////////////////////
    152          //! \brief  Loader action function processes the first header chunk
    153          //!
    154          //! Processes the first header chunk of the boot image file, which
    155          //! saves the SHA-1 to the context initVector field, the CBC-MAC process is
    156          //! started here to handle the DEK if one is found
    157          //!
    158          //! \param[in]  context    Pointer to a loader context structure.
    159          //!
    160          //! \pre    context->src points at the current header chunk.
    161          //!
    162          //! \post   context->Action is set to process the next header chunk.
    163          //!
    164          //! \retval SUCCESS
    165          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    166          int ldr_DoHeader(ldr_Context_t *context)
    167          {
    168          #if AES_SECURITY_SUPPORTED
    169              // Start the cbc-mac decode process which we may not need but won't know until we get
    170              // to the keyCount variable in the header
    171              cbc_mac_init((uint8_t*)&s_aesKey, 0);
    172          
    173              // The contents of header chunk[0] are used as the initialization vector
    174              // for the CBC decryption process. Save this value in the loader context.
    175              memcpy(context->initVector, context->src, sizeof(chunk_t));
    176          
    177              // Feed the cbc mac the received data, and store the data in the DEK
    178              cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    179          #endif
    180          
    181              // Setup to process the next header chunk
    182              context->Action = ldr_DoHeader1;
   \                     ldr_DoHeader: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,ldr_DoHeader1
   \   00000004   0x....             B.N      ?Subroutine0
    183          
    184              return kStatus_Success;
    185          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    186          
    187          ////////////////////////////////////////////////////////////////////////////////
    188          //! \brief  Loader action function processes header chunk 1
    189          //!
    190          //! Processes the second header chunk of the boot image file, which contains
    191          //! the file signature, version, flags and chunk count.
    192          //!
    193          //! \param[in]  context    Pointer to a loader context structure.
    194          //!
    195          //! \pre    context->src points at the current header chunk.
    196          //!
    197          //! \post   context->Action is set to process the next header chunk.
    198          //! \post   context->fileChunks and fileFlags are set to the header values.
    199          //!
    200          //! \retval kStatus_Success
    201          //! \retval kStatusRomLdrSignature if the signature or version are incorrect.
    202          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    203          int ldr_DoHeader1(ldr_Context_t *context)
    204          {
    205              boot_hdr1_t *pHdr1 = (boot_hdr1_t *)context->src;
   \                     ldr_DoHeader1: (+1)
   \   00000000   0x6A41             LDR      R1,[R0, #+36]
    206          
    207              // Copy the file flags and chunk count
    208              context->fileFlags = pHdr1->fileFlags;
    209              context->fileChunks = pHdr1->fileChunks - 2;
    210          
    211              // Check the file signature and version
    212              if ((pHdr1->signature != BOOT_SIGNATURE) || (pHdr1->major > SB_FILE_MAJOR_VERSION))
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable9  ;; 0x504d5453
   \   00000006   0x894A             LDRH     R2,[R1, #+10]
   \   00000008   0x8282             STRH     R2,[R0, #+20]
   \   0000000A   0x68CA             LDR      R2,[R1, #+12]
   \   0000000C   0x1E92             SUBS     R2,R2,#+2
   \   0000000E   0x6042             STR      R2,[R0, #+4]
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x429A             CMP      R2,R3
   \   00000014   0xD102             BNE.N    ??ldr_DoHeader1_0
   \   00000016   0x7A09             LDRB     R1,[R1, #+8]
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xDB02             BLT.N    ??ldr_DoHeader1_1
    213              {
    214                  return kStatusRomLdrSignature;
   \                     ??ldr_DoHeader1_0: (+1)
   \   0000001C   0xF242 0x7075      MOVW     R0,#+10101
   \   00000020   0x4770             BX       LR
    215              }
    216              else
    217              {
    218          #if AES_SECURITY_SUPPORTED
    219                  // Feed the cbc mac the received data
    220                  cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    221          #endif
    222          
    223                  // Setup to process the next header chunk
    224                  context->Action = ldr_DoHeader2;
   \                     ??ldr_DoHeader1_1: (+1)
   \   00000022   0x.... 0x....      ADR.W    R1,ldr_DoHeader2
   \   00000026   0xBF00             Nop      
   \   00000028                      REQUIRE ?Subroutine0
   \   00000028                      ;; // Fall through to label ?Subroutine0
    225          
    226                  return kStatus_Success;
    227              }
    228          }
    229          
    230          ////////////////////////////////////////////////////////////////////////////////
    231          //! \brief  Loader action function processes header chunk 2
    232          //!
    233          //! Processes the third header chunk of the boot image file, which contains
    234          //! parameters for the first boot section and the key dictionary.
    235          //!
    236          //! \param[in]  context    Pointer to a loader context structure.
    237          //!
    238          //! \pre    context->src points at the current header chunk.
    239          //!
    240          //! \post   context->Action is set to process the next header chunk.
    241          //! \post   context->sectChunks, objectID and keyCount are set to the header values.
    242          //!
    243          //! \retval kStatus_Success
    244          //! \retval kStatusRomLdrSectionLength if the bootOffset is out of range.
    245          //! \retval kStatusRomLdrUnencryptedOnly if the unencrypted image is disabled.
    246          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    247          int ldr_DoHeader2(ldr_Context_t *context)
    248          {
   \                     ldr_DoHeader2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    249              boot_hdr2_t *pHdr2 = (boot_hdr2_t *)context->src;
   \   00000006   0x6A60             LDR      R0,[R4, #+36]
    250          
    251              // Save first boot section parameters
    252              context->objectID = pHdr2->bootSectID;
   \   00000008   0x6841             LDR      R1,[R0, #+4]
    253              // Set up our first sectChunks value since we can determine it now
    254              context->sectChunks = pHdr2->bootOffset - 3;
    255          
    256              // Sanity check the section chunk count
    257              if (context->sectChunks >= context->fileChunks)
   \   0000000A   0x6862             LDR      R2,[R4, #+4]
   \   0000000C   0x61A1             STR      R1,[R4, #+24]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x1EC9             SUBS     R1,R1,#+3
   \   00000012   0x4291             CMP      R1,R2
   \   00000014   0x60A1             STR      R1,[R4, #+8]
   \   00000016   0xD302             BCC.N    ??ldr_DoHeader2_0
    258              {
    259                  return kStatusRomLdrSectionLength;
   \   00000018   0xF242 0x7076      MOVW     R0,#+10102
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}
    260              }
    261          
    262              // Check whether the image is encrypted
    263              if (pHdr2->keyCount != 0)
   \                     ??ldr_DoHeader2_0: (+1)
   \   0000001E   0x8900             LDRH     R0,[R0, #+8]
   \   00000020   0xB110             CBZ.N    R0,??ldr_DoHeader2_1
    264              {
    265          #if AES_SECURITY_SUPPORTED
    266                  // Save the key count for the dictionary search
    267                  context->keyCount = pHdr2->keyCount;
    268          
    269                  // Use bootCmd.count as temporary storage to hold the number of chunks
    270                  // remaining in the plaintext header
    271                  context->bootCmd.count = pHdr2->keyOffset - 3;
    272          
    273                  // Set action to finish calculation of CBC MAC over the header
    274                  context->Action = ldr_DoHeaderMac;
    275          
    276                  // Feed the cbc mac the received data
    277                  cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    278          
    279                  return kStatus_Success;
    280          #else
    281                  debug_printf("Error: image is encrypted\r\n");
    282                  return kStatusRomLdrUnencryptedOnly;
   \   00000022   0xF242 0x7077      MOVW     R0,#+10103
   \   00000026   0xBD16             POP      {R1,R2,R4,PC}
    283          #endif
    284              }
    285              else
    286              {
    287          #ifndef BOOTLOADER_HOST
    288                  flash_security_state_t securityState = kFlashNotSecure;
   \                     ??ldr_DoHeader2_1: (+1)
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
    289                  // If the image is not encrypted and we have flash security enabled
    290                  // abort the transfer
    291                  flash_get_security_state(&g_bootloaderContext.flashState, &securityState);
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x....             LDR.N    R0,??DataTable9_1
   \   00000030   0x.... 0x....      BL       flash_get_security_state
    292          
    293                  if (securityState != kFlashNotSecure)
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0xB110             CBZ.N    R0,??ldr_DoHeader2_2
    294                  {
    295                      return kStatusRomLdrSecureOnly;
   \   0000003A   0xF242 0x7081      MOVW     R0,#+10113
   \   0000003E   0xBD16             POP      {R1,R2,R4,PC}
    296                  }
    297          #endif // BOOTLOADER_HOST
    298          
    299                  // Skip the rest of the header
    300                  return ldr_GoToNextSection(context);
   \                     ??ldr_DoHeader2_2: (+1)
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       ldr_GoToNextSection
   \   00000046   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    301              }
    302          }
    303          
    304          ////////////////////////////////////////////////////////////////////////////////
    305          //! \brief  Loader action function finishes CBC-MAC over final header chunks
    306          //!
    307          //! Completes the CBC-MAC calculation over the remaining plaintext header.
    308          //! This function will only get called if CBC_MAC is supported
    309          //!
    310          //! \param[in]  context    Pointer to a loader context structure.
    311          //!
    312          //! \pre    context->src points at the current header chunk.
    313          //! \pre    context->bootCmd.count = number of chunks left in plaintext header.
    314          //!
    315          //! \post   context->scratchPad contains the computed CBC-MAC.
    316          //! \post   context->bootCmd.count is updated.
    317          //!
    318          //! \retval SUCCESS
    319          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    320          int ldr_DoHeaderMac(ldr_Context_t *context)
    321          {
    322              // Continue to compute the CBC-MAC over the remaining plaintext header
    323              // one chunk at a time.
    324              --context->sectChunks;
   \                     ldr_DoHeaderMac: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x1E49             SUBS     R1,R1,#+1
   \   00000004   0x6081             STR      R1,[R0, #+8]
    325          
    326          #if AES_SECURITY_SUPPORTED
    327              // Feed the cbc mac the received data
    328              cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    329          #endif
    330          
    331              if (--(context->bootCmd.count) == 0)
   \   00000006   0x6E01             LDR      R1,[R0, #+96]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x6601             STR      R1,[R0, #+96]
   \   0000000C   0xBF04             ITT      EQ 
   \   0000000E   0x.... 0x....      ADREQ.W  R1,ldr_DoKeyTest
   \   00000012   0x6001             STREQ    R1,[R0, #+0]
    332              {
    333                  context->Action = ldr_DoKeyTest;
    334              }
    335          
    336              return kStatus_Success;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    337          }
    338          
    339          ////////////////////////////////////////////////////////////////////////////////
    340          //! \brief  Loader action function processes a key dictionary match
    341          //!
    342          //! This loader action function is one of three functions used to parse the
    343          //! key dictionary. It is called after a match of the CBC-MAC is found and the
    344          //! session key (DEK) is decrypted. It saves the DEK in the boot context and
    345          //! then skips to the first boot command in the image.
    346          //! This function will only get called if CBC_MAC is supported
    347          //!
    348          //! \param[in]  context    Pointer to a loader context structure.
    349          //!
    350          //! \pre    context->src points to the the encrypted session key.
    351          //! \pre    context->initVector contains the SHA-1 chunk from the header
    352          //!
    353          //! \post   *context is setup to decrypt the first boot command.
    354          //! \post   The session key is decrypted and stored in the context dek field
    355          //!
    356          //! \return Return value from ldr_GoToNextSection().
    357          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    358          int ldr_DoGetDek(ldr_Context_t *context)
    359          {
    360              --context->sectChunks;
   \                     ldr_DoGetDek: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x1E49             SUBS     R1,R1,#+1
   \   00000004   0x6081             STR      R1,[R0, #+8]
    361          
    362          #if AES_SECURITY_SUPPORTED
    363              // Use the OTP key and the init vector from the header
    364              cbc_mac_init((uint8_t*)&s_aesKey, context->initVector);
    365          
    366              // decrypt the dek
    367              cbc_mac_decrypt(context->src, sizeof(chunk_t), context->dek);
    368          #endif
    369          
    370              // Skip ahead to the next section
    371              return ldr_GoToNextSection(context);
   \   00000006   0x....             B.N      ldr_GoToNextSection
    372          }
    373          
    374          ////////////////////////////////////////////////////////////////////////////////
    375          //! \brief  Loader action function tests for a key dictionary match
    376          //!
    377          //! This loader action function is one of three functions used to parse the
    378          //! key dictionary. It is called after a CBC-MAC entry from the dictionary
    379          //! has been read. If the value read is equal to the computed CBC-MAC, then
    380          //! the next encrypted chunk holds the session key (DEK), and the next action
    381          //! function will decrypt the key. Otherwise if there are remaining entries
    382          //! in the dictionary, the next action will get the next CBC-MAC to test.
    383          //!
    384          //! \param[in]  context    Pointer to a loader context structure.
    385          //!
    386          //! \pre    context->dek holds the CBC-MAC computed over the header.
    387          //! \pre    context->src holds a CBC-MAC value from the dictionary.
    388          //!
    389          //! \post   if CBC-MAC matches we transition to decrypt the DEK
    390          //! \post   context->keyCount is updated to the remaining number of keys to test.
    391          //!
    392          //! \retval SUCCESS
    393          //! \retval ERROR_ROM_LDR_KEY_NOT_FOUND if there are no more entries in the
    394          //!             dictionary and a CBC-MAC match was not found.
    395          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    396          int ldr_DoKeyTest(ldr_Context_t *context)
    397          {
   \                     ldr_DoKeyTest: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    398              int rc = kStatus_Success;
    399          
    400              --context->sectChunks;
    401          
    402              // See if the computed CBC-MAC and the dictionary entry match
    403              if (memcmp(context->dek, context->src, sizeof(chunk_t)) == 0)
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x68A8             LDR      R0,[R5, #+8]
   \   00000008   0x6A69             LDR      R1,[R5, #+36]
   \   0000000A   0x1E46             SUBS     R6,R0,#+1
   \   0000000C   0x60AE             STR      R6,[R5, #+8]
   \   0000000E   0xF105 0x0038      ADD      R0,R5,#+56
   \   00000012   0x.... 0x....      BL       memcmp
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0xB910             CBNZ.N   R0,??ldr_DoKeyTest_0
    404              {
    405                  // Yes, the next chunk holds the session key. The next action will
    406                  // load the key and terminate the key search.
    407                  context->Action = ldr_DoGetDek;
   \   0000001A   0x....             LDR.N    R0,??DataTable9_2
   \   0000001C   0x6028             STR      R0,[R5, #+0]
   \   0000001E   0xE00B             B.N      ??ldr_DoKeyTest_1
    408              }
    409              else if (--(context->keyCount) > 0)
   \                     ??ldr_DoKeyTest_0: (+1)
   \   00000020   0x8AE8             LDRH     R0,[R5, #+22]
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x82E8             STRH     R0,[R5, #+22]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0xB120             CBZ.N    R0,??ldr_DoKeyTest_2
    410              {
    411                  // No, but there are more entries in the dictionary, so go get the
    412                  // next one to test. Skip over the next chunk which is the unmatching DEK
    413                  --context->sectChunks;
   \   0000002A   0x1E70             SUBS     R0,R6,#+1
   \   0000002C   0x60A8             STR      R0,[R5, #+8]
    414                  context->skipCount = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x66A8             STR      R0,[R5, #+104]
   \   00000032   0xE001             B.N      ??ldr_DoKeyTest_1
    415              }
    416              else
    417              {
    418                  // No, and there are no more entries in the dictionary.
    419                  rc = kStatusRomLdrKeyNotFound;
   \                     ??ldr_DoKeyTest_2: (+1)
   \   00000034   0xF44F 0x541E      MOV      R4,#+10112
    420              }
    421          
    422              return rc;
   \                     ??ldr_DoKeyTest_1: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    423          }
    424          
    425          ////////////////////////////////////////////////////////////////////////////////
    426          //! \brief  Loader action function loads the trailing "ragged edge bytes"
    427          //!
    428          //! Implements the second of two action functions for the boot "load" command.
    429          //! The last move sequence for the load command moves the final
    430          //! payload chunk. This function checks the payload
    431          //! CRC, then copies the final load bytes to the load
    432          //! destination.
    433          //!
    434          //! \param[in]  context    Pointer to a loader context structure.
    435          //!
    436          //! \pre    context->bootCmd contains the boot command.
    437          //! \pre    context->src contains the final decrypted payload chunk.
    438          //! \pre    context->crc32 holds the CRC calculated over the entire payload.
    439          //!
    440          //! \post   *context is setup to get the next boot command.
    441          //!
    442          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    443          int ldr_DoLoadBytes(ldr_Context_t *context)
    444          {
   \                     ldr_DoLoadBytes: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    445              uint32_t crc32Result;
    446          
    447              // Copy the trailing edge payload bytes to the load destination.
    448          #if AES_SECURITY_SUPPORTED
    449              if (context->keyCount)
    450              {
    451                  // decrypt the block in place
    452                  cbc_mac_decrypt(context->src, sizeof(chunk_t), context->src);
    453              }
    454          #endif
    455          
    456              status_t status = g_bootloaderContext.memoryInterface->write(context->bootCmd.address, context->bootCmd.count, context->src);
   \   00000002   0x....             LDR.N    R5,??DataTable9_3
   \   00000004   0x682B             LDR      R3,[R5, #+0]
   \   00000006   0x689B             LDR      R3,[R3, #+8]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x6A62             LDR      R2,[R4, #+36]
   \   0000000C   0x6E21             LDR      R1,[R4, #+96]
   \   0000000E   0x6DE0             LDR      R0,[R4, #+92]
   \   00000010   0x4798             BLX      R3
    457          
    458              if (status != kStatus_Success)
   \   00000012   0xB980             CBNZ.N   R0,??ldr_DoLoadBytes_0
    459              {
    460                  return status;
    461              }
    462          
    463              // Force to write buffered data to target memory
    464              assert(g_bootloaderContext.memoryInterface->flush);
    465              status = g_bootloaderContext.memoryInterface->flush();
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0x4780             BLX      R0
    466              if (status != kStatus_Success)
   \   0000001A   0xB960             CBNZ.N   R0,??ldr_DoLoadBytes_0
    467              {
    468                  return status;
    469              }
    470          
    471              // update the crc running value then finalize
    472              crc32_update(&context->crc32, context->src, sizeof(chunk_t));
   \   0000001C   0x.... 0x....      BL       ?Subroutine3
    473          
    474              crc32_finalize(&context->crc32, &crc32Result);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000020   0x.... 0x....      BL       ?Subroutine4
    475          
    476              if (crc32Result != context->bootCmd.data)
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x6E61             LDR      R1,[R4, #+100]
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD000             BEQ.N    ??ldr_DoLoadBytes_1
    477              {
    478                  return kStatusRomLdrCrc32Error;
   \   0000002C   0x....             B.N      ?Subroutine1
    479              }
    480          
    481              // Setup to get the next boot command.
    482              context->Action = ldr_DoCommand;
   \                     ??ldr_DoLoadBytes_1: (+1)
   \   0000002E   0x.... 0x....      ADR.W    R0,ldr_DoCommand
   \   00000032   0x6020             STR      R0,[R4, #+0]
    483          
    484              return kStatus_Success;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??ldr_DoLoadBytes_0: (+1)
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    485          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x4669             MOV      R1,SP
   \   00000002   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000006   0x.... 0x....      B.W      crc32_finalize

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x6A61             LDR      R1,[R4, #+36]
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000008   0x.... 0x....      B.W      crc32_update

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF242 0x707A      MOVW     R0,#+10106
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}
    486          
    487          ////////////////////////////////////////////////////////////////////////////////
    488          //! \brief  Loader action function loads data chunks
    489          //!
    490          //! Implements the first of two action functions for the boot "load" command.
    491          //! Loads one or more complete "chunk size" blocks of data.
    492          //!
    493          //! If the amount of data remaining to load is one chunk or less, it sets the
    494          //! state sequence to move the next chunk. The
    495          //! action function is changed to \ref ldr_DoLoadBytes, which will check the
    496          //! payload CRC and copy to the correct location.
    497          //!
    498          //! \param[in]  context    Pointer to a loader context structure.
    499          //!
    500          //! \pre    context->bootCmd contains the boot command.
    501          //!
    502          //! \post   context->bootCmd is adjusted to reflect the previous move.
    503          //! \post   context->Action is set to move the next received payload.
    504          //!
    505          //! \retval kStatus_Success
    506          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    507          status_t ldr_DoLoadChunks(ldr_Context_t *context)
    508          {
   \                     ldr_DoLoadChunks: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    509              uint32_t crc32Result;
    510          
    511          #if AES_SECURITY_SUPPORTED
    512              if (context->keyCount)
    513              {
    514                  // decrypt the block in place
    515                  cbc_mac_decrypt(context->src, sizeof(chunk_t), context->src);
    516              }
    517          #endif
    518          
    519              // update the crc running value
    520              crc32_update(&context->crc32, context->src, sizeof(chunk_t));
   \   00000004   0x....             LDR.N    R5,??DataTable9_3
   \   00000006   0x.... 0x....      BL       ?Subroutine3
    521              status_t status = g_bootloaderContext.memoryInterface->write(context->bootCmd.address, sizeof(chunk_t), context->src);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000A   0x682B             LDR      R3,[R5, #+0]
   \   0000000C   0x6A62             LDR      R2,[R4, #+36]
   \   0000000E   0x6DE0             LDR      R0,[R4, #+92]
   \   00000010   0x689B             LDR      R3,[R3, #+8]
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x4798             BLX      R3
    522              if (status != kStatus_Success)
   \   00000016   0xB9D8             CBNZ.N   R0,??ldr_DoLoadChunks_0
    523              {
    524                  return status;
    525              }
    526          
    527              // Adjust the boot command parameters to reflect the last move
    528              context->bootCmd.address += sizeof(chunk_t);
   \   00000018   0x6DE0             LDR      R0,[R4, #+92]
   \   0000001A   0x3010             ADDS     R0,R0,#+16
   \   0000001C   0x65E0             STR      R0,[R4, #+92]
    529              context->bootCmd.count -= sizeof(chunk_t);
   \   0000001E   0x6E20             LDR      R0,[R4, #+96]
   \   00000020   0x3810             SUBS     R0,R0,#+16
   \   00000022   0x6620             STR      R0,[R4, #+96]
    530          
    531              if (context->bootCmd.count > sizeof(chunk_t))
   \   00000024   0x2811             CMP      R0,#+17
   \   00000026   0xBF28             IT       CS 
   \   00000028   0x....             LDRCS.N  R0,??DataTable9_4
    532              {
    533                  context->Action = ldr_DoLoadChunks;
   \   0000002A   0xD20F             BCS.N    ??ldr_DoLoadChunks_1
    534              }
    535              else if (context->bootCmd.count)
   \   0000002C   0xB108             CBZ.N    R0,??ldr_DoLoadChunks_2
    536              {
    537                  context->Action = ldr_DoLoadBytes;
   \   0000002E   0x....             LDR.N    R0,??DataTable9_5
   \   00000030   0xE00C             B.N      ??ldr_DoLoadChunks_1
    538              }
    539              else
    540              {
    541          
    542                  // Force to write buffered data to target memory
    543                  assert(g_bootloaderContext.memoryInterface->flush);
    544                  status = g_bootloaderContext.memoryInterface->flush();
   \                     ??ldr_DoLoadChunks_2: (+1)
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x6900             LDR      R0,[R0, #+16]
   \   00000036   0x4780             BLX      R0
    545                  if (status != kStatus_Success)
   \   00000038   0xB950             CBNZ.N   R0,??ldr_DoLoadChunks_0
    546                  {
    547                      return status;
    548                  }
    549          
    550                  // The last amount of data we received was a full chunk so get our crc result
    551                  crc32_finalize(&context->crc32, &crc32Result);
   \   0000003A   0x.... 0x....      BL       ?Subroutine4
    552          
    553                  if (crc32Result != context->bootCmd.data)
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x6E61             LDR      R1,[R4, #+100]
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD000             BEQ.N    ??ldr_DoLoadChunks_3
    554                  {
    555                      return kStatusRomLdrCrc32Error;
   \   00000046   0x....             B.N      ?Subroutine1
    556                  }
    557          
    558                  context->Action = ldr_DoCommand;
   \                     ??ldr_DoLoadChunks_3: (+1)
   \   00000048   0x.... 0x....      ADR.W    R0,ldr_DoCommand
   \                     ??ldr_DoLoadChunks_1: (+1)
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    559              }
    560          
    561              return kStatus_Success;
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??ldr_DoLoadChunks_0: (+1)
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    562          }
    563          
    564          ////////////////////////////////////////////////////////////////////////////////
    565          //! \brief  Loader "load" command handler
    566          //!
    567          //! Implements the first command handler called for the boot "load" command.
    568          //! The load action is split into two functions:
    569          //! - \ref ldr_DoLoadChunks, loads chunks
    570          //! - \ref ldr_DoLoadBytes, loads the trailing "ragged edge bytes"
    571          //! This function initializes the context before calling load action.
    572          //!
    573          //! \param[in]  context    Pointer to a loader context structure.
    574          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    575          status_t ldr_DoLoadCmd(ldr_Context_t *context)
    576          {
   \                     ldr_DoLoadCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    577              // initialize crc32
    578              crc32_init(&context->crc32);
   \   00000004   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000008   0x.... 0x....      BL       crc32_init
    579          
    580              // Next chunk will be the first chunk to load, if its a full chunk do load chunks
    581              if (context->bootCmd.count > sizeof(chunk_t))
   \   0000000C   0x6E20             LDR      R0,[R4, #+96]
   \   0000000E   0x2811             CMP      R0,#+17
   \   00000010   0xBF2C             ITE      CS 
   \   00000012   0x....             LDRCS.N  R0,??DataTable9_4
   \   00000014   0x....             LDRCC.N  R0,??DataTable9_5
    582              {
    583                  context->Action = ldr_DoLoadChunks;
    584              }
    585              else
    586              {
    587                  context->Action = ldr_DoLoadBytes;
   \   00000016   0x....             B.N      ?Subroutine2
    588              }
    589          
    590              return kStatus_Success;
    591          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6020             STR      R0,[R4, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBD10             POP      {R4,PC}          ;; return
    592          
    593          ////////////////////////////////////////////////////////////////////////////////
    594          //! \brief  Loader "fill" command handler
    595          //!
    596          //! Implements the action function for the boot "fill" command.
    597          //!
    598          //! \param[in]  context    Pointer to a loader context structure.
    599          //!
    600          //! \pre    context->bootCmd contains the boot command.
    601          //!
    602          //! \post   *context is left setup to get the next boot command.
    603          //!
    604          //! \retval kStatus_Success
    605          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    606          status_t ldr_DoFillCmd(ldr_Context_t *context)
    607          {
    608              status_t status = g_bootloaderContext.memoryInterface->fill(context->bootCmd.address, context->bootCmd.count, context->bootCmd.data);
   \                     ldr_DoFillCmd: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable9_3
   \   00000002   0x681B             LDR      R3,[R3, #+0]
   \   00000004   0x6E42             LDR      R2,[R0, #+100]
   \   00000006   0x6E01             LDR      R1,[R0, #+96]
   \   00000008   0x6DC0             LDR      R0,[R0, #+92]
   \   0000000A   0x68DB             LDR      R3,[R3, #+12]
   \   0000000C   0x4718             BX       R3
    609              if (status != kStatus_Success)
    610              {
    611                  return status;
    612              }
    613          
    614              // Context is already setup to get the next boot command
    615              return kStatus_Success;
    616          }
    617          
    618          ////////////////////////////////////////////////////////////////////////////////
    619          //! \brief  Loader "jump" command handler
    620          //!
    621          //! Implements the action function for the boot "jump" command.
    622          //!
    623          //! \param[in]  context    Pointer to a loader context structure.
    624          //!
    625          //! \pre    context->bootCmd contains the boot command.
    626          //!
    627          //! \retval kStatusRomLdrJumpReturned if the plugin returns
    628          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    629          status_t ldr_DoJumpCmd(ldr_Context_t *context)
    630          {
    631              // Actual jump is implemented in sbloader_finalize_jump().
    632              return kStatus_AbortDataPhase;
   \                     ldr_DoJumpCmd: (+1)
   \   00000000   0xF242 0x7012      MOVW     R0,#+10002
   \   00000004   0x4770             BX       LR               ;; return
    633          }
    634          
    635          ////////////////////////////////////////////////////////////////////////////////
    636          //! \brief  Loader "call" command handler
    637          //!
    638          //! Implements the action function for the boot "call" command.
    639          //!
    640          //! \param[in]  context    Pointer to a loader context structure.
    641          //!
    642          //! \pre    context->bootCmd contains the boot command.
    643          //!
    644          //! \post   *context is setup to get the next boot command.
    645          //! \post   context->objectID is set to the next boot section or image ID.
    646          //!
    647          //! \return Return code from plugin or ldr_GoToNextSection.
    648          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    649          status_t ldr_DoCallCmd(ldr_Context_t *context)
    650          {
   \                     ldr_DoCallCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    651              pCallFnc_t entry_fun = (pCallFnc_t)context->bootCmd.address;
    652              status_t rc = kStatusRomLdrCallFailed;
   \   00000004   0xF242 0x707F      MOVW     R0,#+10111
   \   00000008   0x6DE2             LDR      R2,[R4, #+92]
    653          
    654              // todo: need common impl with bootloader call cmd
    655          
    656              // Call the plugin entry point with the specified parameter. The plugin
    657              // can start a new section or image by returning the appropriate code and
    658              // updating the object id pointed to by the second parameter.
    659              if (entry_fun != NULL)
   \   0000000A   0x0011             MOVS     R1,R2
   \   0000000C   0xD00E             BEQ.N    ??ldr_DoCallCmd_0
    660              {
    661                 rc = entry_fun(context->bootCmd.data, &context->objectID);
   \   0000000E   0x6E60             LDR      R0,[R4, #+100]
   \   00000010   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000014   0x4790             BLX      R2
    662              }
    663          
    664              if (rc == ROM_BOOT_SECTION_ID)
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD103             BNE.N    ??ldr_DoCallCmd_1
    665              {
    666                  // The plugin returned a section ID, skip ahead to the next section
    667                  return ldr_GoToNextSection(context);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x....             B.N      ldr_GoToNextSection
    668              }
    669              else if (rc == ROM_BOOT_IMAGE_ID)
   \                     ??ldr_DoCallCmd_1: (+1)
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD102             BNE.N    ??ldr_DoCallCmd_0
    670              {
    671                  // The plugin returned an image ID, restart the loader state machine
    672                  sbloader_init();
   \   00000026   0x.... 0x....      BL       sbloader_init
    673                  return kStatus_Success;
   \   0000002A   0x2000             MOVS     R0,#+0
    674              }
    675              else
    676              {
    677                  // Otherwise, just pass on the plugin return code. Context is already
    678                  // setup to get the next boot command.
    679                  return rc;
   \                     ??ldr_DoCallCmd_0: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    680              }
    681          }
    682          
    683          ////////////////////////////////////////////////////////////////////////////////
    684          //! \brief  Loader "tag" command handler
    685          //!
    686          //! Implements the action function for the boot "tag" command.
    687          //!
    688          //! \param[in]  context    Pointer to a loader context structure.
    689          //!
    690          //! \pre    context->bootCmd contains the boot command.
    691          //!
    692          //! \post   *context is setup to get the next boot command.
    693          //! \post   context->sectChunks is updated to the next section.
    694          //!
    695          //! \retval kStatusRomLdrSectionLength if new section count is out of range.
    696          //! \retval kStatusRomLdrIdNotFound if no match and no more sections.
    697          //! \retval Return code from ldr_GoToNextSection.
    698          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    699          status_t ldr_DoTagCmd(ldr_Context_t *context)
    700          {
   \                     ldr_DoTagCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    701              // Get the section chunk count from the boot command
    702              context->sectChunks = context->bootCmd.count;
   \   00000002   0xF100 0x015C      ADD      R1,R0,#+92
   \   00000006   0x1D03             ADDS     R3,R0,#+4
    703          
    704              // Sanity check the new section count
    705              if (context->sectChunks > context->fileChunks)
   \   00000008   0x681C             LDR      R4,[R3, #+0]
   \   0000000A   0x684A             LDR      R2,[R1, #+4]
   \   0000000C   0x605A             STR      R2,[R3, #+4]
   \   0000000E   0x4294             CMP      R4,R2
   \   00000010   0xD202             BCS.N    ??ldr_DoTagCmd_0
    706              {
    707                  return kStatusRomLdrSectionLength;
   \   00000012   0xF242 0x7076      MOVW     R0,#+10102
   \   00000016   0xBD10             POP      {R4,PC}
    708              }
    709          
    710              if((context->bootCmd.data & SFLG_SECTION_BOOTABLE) &&
    711                 (context->bootCmd.address == context->objectID))
   \                     ??ldr_DoTagCmd_0: (+1)
   \   00000018   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001A   0x07D2             LSLS     R2,R2,#+31
   \   0000001C   0xD507             BPL.N    ??ldr_DoTagCmd_1
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x695C             LDR      R4,[R3, #+20]
   \   00000022   0x42A2             CMP      R2,R4
   \   00000024   0xD103             BNE.N    ??ldr_DoTagCmd_1
    712              {
    713                  // This section is bootable and matches the ID we are looking for, so
    714                  // just continue getting commands from this point
    715                  // Reinitialize the decryption for the rest of the boot commands and the section
    716          
    717                  context->bootSectChunks = context->bootCmd.count;
   \   00000026   0x6848             LDR      R0,[R1, #+4]
   \   00000028   0x6098             STR      R0,[R3, #+8]
    718          
    719          #if AES_SECURITY_SUPPORTED
    720                  if (context->keyCount)
    721                  {
    722                      cbc_mac_init(context->dek, context->initVector);
    723                  }
    724          #endif
    725                  return kStatus_Success;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}
    726              }
    727              else if (context->bootCmd.flags & CFLG_LAST_TAG)
   \                     ??ldr_DoTagCmd_1: (+1)
   \   0000002E   0xF890 0x105A      LDRB     R1,[R0, #+90]
   \   00000032   0x07C9             LSLS     R1,R1,#+31
   \   00000034   0xBF5C             ITT      PL 
    728              {
    729                  // This isn't the right boot section and it's the last one, so return
    730                  // an error
    731                  return kStatusRomLdrIdNotFound;
    732              }
    733              else
    734              {
    735                  // This isn't the boot section we are looking for and there are more, so
    736                  // skip to the next one
    737                  return ldr_GoToNextSection(context);
   \   00000036   0xE8BD 0x4010      POPPL    {R4,LR}
   \   0000003A   0x.... 0x....      BPL.W    ldr_GoToNextSection
    738              }
   \   0000003E   0xF242 0x707C      MOVW     R0,#+10108
   \   00000042   0xBD10             POP      {R4,PC}
    739          }
    740          
    741          
    742          ////////////////////////////////////////////////////////////////////////////////
    743          //! \brief  Loader "erase" command handler
    744          //!
    745          //! Implements the action function for the boot "erase" command.
    746          //!
    747          //! \param[in]  context    Pointer to a loader context structure.
    748          //!
    749          //! \pre    context->bootCmd contains the boot command.
    750          //!
    751          //! \post   *context is setup to get the next boot command.
    752          //! \post   context->sectChunks is updated to the next section.
    753          //!
    754          //! \retval kStatus_Success
    755          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    756          status_t ldr_DoEraseCmd(ldr_Context_t *context)
    757          {
    758              status_t status = kStatus_Success;
    759              if (context->bootCmd.flags & ROM_ERASE_ALL_MASK)
   \                     ldr_DoEraseCmd: (+1)
   \   00000000   0xF890 0x105A      LDRB     R1,[R0, #+90]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xBF48             IT       MI 
    760              {
    761          #ifdef BOOTLOADER_HOST
    762                  host_flash_erase_all();
    763          #else
    764                  status = flash_mem_erase_all();
   \   00000008   0x.... 0x....      BMI.W    flash_mem_erase_all
    765          #endif
    766              }
    767              else
    768              {
    769          #ifdef BOOTLOADER_HOST
    770                  host_flash_erase_region(context->bootCmd.address, context->bootCmd.count);
    771          #else
    772                  status = g_bootloaderContext.memoryInterface->erase(context->bootCmd.address, context->bootCmd.count);
   \   0000000C   0x....             LDR.N    R2,??DataTable9_3
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x6952             LDR      R2,[R2, #+20]
   \   00000012   0x305C             ADDS     R0,R0,#+92
   \   00000014   0x6841             LDR      R1,[R0, #+4]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x4710             BX       R2
    773          #endif
    774              }
    775          
    776              return status;
    777          }
    778          
    779          ////////////////////////////////////////////////////////////////////////////////
    780          //! \brief  Loader boot command parsing function
    781          //!
    782          //! Implements the action function for parsing a boot command. Performs generic
    783          //! integrity tests and flag handling, then calls the appropriate command
    784          //! handler function based on the command tag.
    785          //!
    786          //! \param[in]  context    Pointer to a loader context structure.
    787          //!
    788          //! \pre    context->bootCmd contains the boot command.
    789          //!
    790          //! \retval kStatusRomLdrChecksum if command checksum failed.
    791          //! \retval kStatusRomLdrUnknownCommand if command tag is not recognized.
    792          //! \retval Return code from the boot command handler function.
    793          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    794          status_t ldr_DoCommand(ldr_Context_t *context)
    795          {
   \                     ldr_DoCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    796              boot_cmd_t *pCmd = &context->bootCmd;
   \   00000004   0xF104 0x0558      ADD      R5,R4,#+88
    797              int i, sum = 0x5a;
    798          
    799          #if AES_SECURITY_SUPPORTED
    800              // Decrypt this boot command block if enabled
    801              if (context->keyCount)
    802              {
    803                  cbc_mac_decrypt(context->src, sizeof(chunk_t), context->src);
    804              }
    805          #endif
    806          
    807              // Save the boot commmand.
    808              context->bootCmd = *((boot_cmd_t *)context->src);
   \   00000008   0x6A61             LDR      R1,[R4, #+36]
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000012   0x265A             MOVS     R6,#+90
    809          
    810              // Compute and test the boot command checksum
    811              for (i = 1; i < sizeof(boot_cmd_t); i++)
   \   00000014   0x2001             MOVS     R0,#+1
    812              {
    813                  sum += ((uint8_t *)pCmd)[i];
   \                     ??ldr_DoCommand_1: (+1)
   \   00000016   0x5D41             LDRB     R1,[R0, R5]
   \   00000018   0x1876             ADDS     R6,R6,R1
    814              }
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x2810             CMP      R0,#+16
   \   0000001E   0xD3FA             BCC.N    ??ldr_DoCommand_1
    815              if (((uint8_t *)pCmd)[0] != (sum & 0xFF))
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0xB2F1             UXTB     R1,R6
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD002             BEQ.N    ??ldr_DoCommand_2
    816              {
    817                  debug_printf("Error: invalid boot command checksum\r\n");
    818                  return kStatusRomLdrChecksum;
   \   00000028   0xF242 0x7079      MOVW     R0,#+10105
   \   0000002C   0xBD70             POP      {R4-R6,PC}
    819              }
    820          
    821              // Switch to the appropriate command handler function
    822              switch (pCmd->tag)
   \                     ??ldr_DoCommand_2: (+1)
   \   0000002E   0x7868             LDRB     R0,[R5, #+1]
   \   00000030   0x2807             CMP      R0,#+7
   \   00000032   0xD81E             BHI.N    ??ldr_DoCommand_3
   \   00000034   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??ldr_DoCommand_0:
   \   00000038   0x1B 0x04          DC8      0x1B,0x4,0x8,0xC
   \              0x08 0x0C    
   \   0000003C   0x10 0x13          DC8      0x10,0x13,0x1B,0x17
   \              0x1B 0x17    
    823              {
    824                  case ROM_NOP_CMD:    return kStatus_Success;
    825                  case ROM_TAG_CMD:    return ldr_DoTagCmd(context);
   \                     ??ldr_DoCommand_4: (+1)
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000046   0x....             B.N      ldr_DoTagCmd
    826                  case ROM_LOAD_CMD:   return ldr_DoLoadCmd(context);
   \                     ??ldr_DoCommand_5: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x....             B.N      ldr_DoLoadCmd
    827                  case ROM_FILL_CMD:   return ldr_DoFillCmd(context);
   \                     ??ldr_DoCommand_6: (+1)
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000056   0x....             B.N      ldr_DoFillCmd
    828                  case ROM_JUMP_CMD:   return ldr_DoJumpCmd(context);
   \                     ??ldr_DoCommand_7: (+1)
   \   00000058   0xF242 0x7012      MOVW     R0,#+10002
   \   0000005C   0xBD70             POP      {R4-R6,PC}
    829                  case ROM_CALL_CMD:   return ldr_DoCallCmd(context);
   \                     ??ldr_DoCommand_8: (+1)
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000064   0x....             B.N      ldr_DoCallCmd
    830                  case ROM_ERASE_CMD:  return ldr_DoEraseCmd(context);
   \                     ??ldr_DoCommand_9: (+1)
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006C   0x....             B.N      ldr_DoEraseCmd
    831                  case ROM_MODE_CMD:   return kStatus_Success;        // ignored for Kinetis
   \                     ??ldr_DoCommand_10: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD70             POP      {R4-R6,PC}
    832              }
    833              return kStatusRomLdrUnknownCommand;
   \                     ??ldr_DoCommand_3: (+1)
   \   00000072   0xF242 0x707B      MOVW     R0,#+10107
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
    834          }
    835          
    836          ////////////////////////////////////////////////////////////////////////////////
    837          //! @brief Initialize the loader state machine.
    838          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    839          status_t sbloader_init(void)
    840          {
   \                     sbloader_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    841              // Initialize the context
    842              memset(&s_loaderContext, 0, sizeof(ldr_Context_t));
   \   00000002   0x....             LDR.N    R4,??DataTable9_6
   \   00000004   0x2170             MOVS     R1,#+112
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
    843          
    844              // Process the first chunk of the image header
    845              s_loaderContext.Action = ldr_DoHeader;
   \   0000000C   0x....             LDR.N    R0,??DataTable9_7
   \   0000000E                      REQUIRE ?Subroutine2
   \   0000000E                      ;; // Fall through to label ?Subroutine2
    846          
    847          #if AES_SECURITY_SUPPORTED
    848              flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 0, &s_aesKey[0], sizeof(s_aesKey[0]));
    849              flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 1, &s_aesKey[1], sizeof(s_aesKey[1]));
    850              flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 2, &s_aesKey[2], sizeof(s_aesKey[2]));
    851              flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 3, &s_aesKey[3], sizeof(s_aesKey[3]));
    852          
    853              int i;
    854              // Test to see if the key is non blank
    855              for (i = 0; i < AES_128_KEY_SIZE_WORDS; i++)
    856              {
    857                  if (s_aesKey[i] != ~0)
    858                  {
    859                      break;
    860                  }
    861              }
    862          
    863              // If i went all the way through the loop the key is blank so default to a blank key
    864              if (i == AES_128_KEY_SIZE_WORDS)
    865              {
    866                  memset(s_aesKey, 0, sizeof(s_aesKey));
    867              }
    868          #endif
    869          
    870              return kStatus_Success;
    871          }
    872          
    873          ////////////////////////////////////////////////////////////////////////////////
    874          //! @brief Pump the loader state machine.
    875          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    876          status_t sbloader_pump(uint8_t* data, unsigned int length)
    877          {
   \                     sbloader_pump: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    878              int status = kStatus_Success;
   \   00000006   0x2000             MOVS     R0,#+0
    879              unsigned int required;
    880              unsigned int available;
    881              unsigned int readPosition = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x....             LDR.N    R7,??DataTable9_8
    882          
    883              while(readPosition != length)
   \                     ??sbloader_pump_0: (+1)
   \   0000000C   0x42AE             CMP      R6,R5
   \   0000000E   0xD017             BEQ.N    ??sbloader_pump_1
    884              {
    885                  required = sizeof(s_loaderBuf.data) - s_loaderBuf.fillPosition;
   \   00000010   0x6938             LDR      R0,[R7, #+16]
   \   00000012   0xF1C0 0x0010      RSB      R0,R0,#+16
    886                  available = length - readPosition;
   \   00000016   0x1BA9             SUBS     R1,R5,R6
   \   00000018   0xE009             B.N      ??sbloader_pump_2
    887          
    888                  // copy what we need to complete a full chunk into the chunk buffer
    889                  while ((required > 0) && (available > 0))
   \                     ??sbloader_pump_3: (+1)
   \   0000001A   0xB179             CBZ.N    R1,??sbloader_pump_4
    890                  {
    891                      s_loaderBuf.data[s_loaderBuf.fillPosition++] = data[readPosition++];
   \   0000001C   0x693B             LDR      R3,[R7, #+16]
   \   0000001E   0x5D32             LDRB     R2,[R6, R4]
   \   00000020   0x55DA             STRB     R2,[R3, R7]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \   00000024   0x693A             LDR      R2,[R7, #+16]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x613A             STR      R2,[R7, #+16]
    892                      --required;
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
    893                      --available;
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
    894                  }
   \                     ??sbloader_pump_2: (+1)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??sbloader_pump_3
    895          
    896                  if (required == 0)
    897                  {
    898                      // a full chunk was filled to process it
    899                      s_loaderBuf.fillPosition = 0;
   \   00000032   0x6138             STR      R0,[R7, #+16]
    900          
    901                      status = sbloader_handle_chunk();
   \   00000034   0x.... 0x....      BL       sbloader_handle_chunk
    902          
    903                      if (status != kStatus_Success)
   \   00000038   0xB910             CBNZ.N   R0,??sbloader_pump_1
   \   0000003A   0xE7E7             B.N      ??sbloader_pump_0
    904                      {
    905                          break;
    906                      }
    907                  }
    908                  else if (available == 0)
    909                  {
    910                      // otherwise we are just going to wait for more data
    911                      status = kStatusRomLdrDataUnderrun;
   \                     ??sbloader_pump_4: (+1)
   \   0000003C   0xF242 0x707D      MOVW     R0,#+10109
    912                      break;
    913                  }
    914              }
    915          
    916              return status;
   \                     ??sbloader_pump_1: (+1)
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    917          }
    918          
    919          ////////////////////////////////////////////////////////////////////////////////
    920          //! @brief Handles the chunk in the s_loaderBuf
    921          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    922          status_t sbloader_handle_chunk(void)
    923          {
    924              status_t status = kStatus_Success;
    925          
    926              s_loaderContext.src = s_loaderBuf.data;
   \                     sbloader_handle_chunk: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9_6
   \   00000002   0x....             LDR.N    R2,??DataTable9_8
   \   00000004   0x624A             STR      R2,[R1, #+36]
   \   00000006   0x2000             MOVS     R0,#+0
    927          
    928              // If we have found the boot section and are currently working on its commands
    929              // Once we have received the number of chunks in the section we will be done
    930              if (s_loaderContext.bootSectChunks)
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xB142             CBZ.N    R2,??sbloader_handle_chunk_0
    931              {
    932                  if (s_loaderContext.receivedChunks < s_loaderContext.bootSectChunks)
   \   0000000C   0x6908             LDR      R0,[R1, #+16]
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0xD202             BCS.N    ??sbloader_handle_chunk_1
    933                  {
    934                      s_loaderContext.receivedChunks++;
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x6108             STR      R0,[R1, #+16]
    935                      status = s_loaderContext.Action(&s_loaderContext);
   \   00000016   0xE004             B.N      ??sbloader_handle_chunk_2
    936                  }
    937                  else
    938                  {
    939                      // Otherwise indicate that we have reached the end of what we are going to process
    940                      status = kStatusRomLdrSectionOverrun;
   \                     ??sbloader_handle_chunk_1: (+1)
   \   00000018   0xF242 0x7074      MOVW     R0,#+10100
   \   0000001C   0x4770             BX       LR
    941                  }
    942              }
    943              else
    944              {
    945                  // Otherwise this is header info or a non bootable section that might be skipped through
    946                  if (!s_loaderContext.skipCount)
   \                     ??sbloader_handle_chunk_0: (+1)
   \   0000001E   0x6E8A             LDR      R2,[R1, #+104]
   \   00000020   0xB912             CBNZ.N   R2,??sbloader_handle_chunk_3
    947                  {
    948                      status = s_loaderContext.Action(&s_loaderContext);
   \                     ??sbloader_handle_chunk_2: (+1)
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x4708             BX       R1
    949                  }
    950                  else
    951                  {
    952                      --s_loaderContext.skipCount;
   \                     ??sbloader_handle_chunk_3: (+1)
   \   00000028   0x1E52             SUBS     R2,R2,#+1
   \   0000002A   0x668A             STR      R2,[R1, #+104]
    953                  }
    954              }
    955          
    956              return status;
   \   0000002C   0x4770             BX       LR               ;; return
    957          }
    958          
    959          ////////////////////////////////////////////////////////////////////////////////
    960          //! @brief Implement jump if last command was ROM_JUMP_CMD.
    961          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    962          status_t sbloader_finalize_jump()
    963          {
   \                     sbloader_finalize_jump: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    964          #if !defined (BOOTLOADER_HOST)
    965              if (s_loaderContext.bootCmd.tag == ROM_JUMP_CMD)
   \   00000002   0x....             LDR.N    R0,??DataTable9_6
   \   00000004   0xF890 0x1059      LDRB     R1,[R0, #+89]
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD10C             BNE.N    ??sbloader_finalize_jump_0
    966              {
    967                  pJumpFnc_t entry_fun = (pJumpFnc_t)s_loaderContext.bootCmd.address;
   \   0000000C   0xF100 0x045C      ADD      R4,R0,#+92
   \   00000010   0x6825             LDR      R5,[R4, #+0]
    968          
    969                  // Jump to the entry point with the specified parameter
    970                  if (entry_fun != NULL)
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xD004             BEQ.N    ??sbloader_finalize_jump_1
    971                  {
    972                      // Clean up prior to calling user code.
    973                      shutdown_cleanup(kShutdownType_Shutdown);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       shutdown_cleanup
    974          
    975                      entry_fun(s_loaderContext.bootCmd.data);
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x47A8             BLX      R5
    976                  }
    977          
    978                  // We should never get here, so return an error if we do
    979                  return kStatusRomLdrJumpReturned;
   \                     ??sbloader_finalize_jump_1: (+1)
   \   00000020   0xF242 0x707E      MOVW     R0,#+10110
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    980              }
    981          #endif
    982              return kStatus_Success;
   \                     ??sbloader_finalize_jump_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    983          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x504D5453         DC32     0x504d5453

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     ldr_DoGetDek

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     ldr_DoLoadChunks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ldr_DoLoadBytes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     s_loaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     ldr_DoHeader

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     s_loaderBuf
    984          
    985          //! @}
    986          
    987          ////////////////////////////////////////////////////////////////////////////////
    988          // EOF
    989          ////////////////////////////////////////////////////////////////////////////////
    990          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ldr_DoCallCmd
         8   -- Indirect call
         0   -> ldr_GoToNextSection
         8   -> sbloader_init
      16   ldr_DoCommand
        16   -> __aeabi_memcpy4
         0   -> ldr_DoCallCmd
         0   -> ldr_DoEraseCmd
         0   -> ldr_DoFillCmd
         0   -> ldr_DoLoadCmd
         0   -> ldr_DoTagCmd
       0   ldr_DoEraseCmd
         0   -- Indirect call
         0   -> flash_mem_erase_all
       0   ldr_DoFillCmd
         0   -- Indirect call
       0   ldr_DoGetDek
         0   -> ldr_GoToNextSection
       0   ldr_DoHeader
       0   ldr_DoHeader1
      16   ldr_DoHeader2
        16   -> flash_get_security_state
        16   -> ldr_GoToNextSection
       0   ldr_DoHeaderMac
       0   ldr_DoJumpCmd
      16   ldr_DoKeyTest
        16   -> memcmp
      16   ldr_DoLoadBytes
        16   -- Indirect call
        16   -> crc32_finalize
        16   -> crc32_update
      16   ldr_DoLoadChunks
        16   -- Indirect call
        16   -> crc32_finalize
        16   -> crc32_update
       8   ldr_DoLoadCmd
         8   -> crc32_init
       8   ldr_DoTagCmd
         8   -> ldr_GoToNextSection
       0   ldr_GoToNextSection
      16   sbloader_finalize_jump
        16   -- Indirect call
        16   -> shutdown_cleanup
       0   sbloader_handle_chunk
         0   -- Indirect call
       8   sbloader_init
         8   -> __aeabi_memclr4
      24   sbloader_pump
        24   -> sbloader_handle_chunk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      12  ?Subroutine3
      10  ?Subroutine4
      46  ldr_DoCallCmd
     120  ldr_DoCommand
      26  ldr_DoEraseCmd
      14  ldr_DoFillCmd
       8  ldr_DoGetDek
       6  ldr_DoHeader
      40  ldr_DoHeader1
      72  ldr_DoHeader2
      24  ldr_DoHeaderMac
       6  ldr_DoJumpCmd
      60  ldr_DoKeyTest
      56  ldr_DoLoadBytes
      82  ldr_DoLoadChunks
      24  ldr_DoLoadCmd
      68  ldr_DoTagCmd
      34  ldr_GoToNextSection
      20  s_loaderBuf
     112  s_loaderContext
      42  sbloader_finalize_jump
      46  sbloader_handle_chunk
      14  sbloader_init
      66  sbloader_pump

 
 132 bytes in section .bss
 930 bytes in section .text
 
 930 bytes of CODE memory
 132 bytes of DATA memory

Errors: none
Warnings: none
