###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:35
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\flash\src\flash_is_protected.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\flash\src\flash_is_protected.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\flash_is_protected.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\flash_is_protected.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\flash\src\flash_is_protected.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "SSD_FTFx_Common.h"
     32          #include "flash/flash.h"
     33          #include "fsl_platform_status.h"
     34          #include "fsl_platform_types.h"
     35          #include "device/fsl_device_registers.h"
     36          
     37          #define FSL_FEATURE_FTFx_REGION_COUNT    (32)
     38          
     39          ////////////////////////////////////////////////////////////////////////////////
     40          // Code
     41          ////////////////////////////////////////////////////////////////////////////////
     42          
     43          // See flash.h for documentation of this function.

   \                                 In section .text, align 4, keep-with-next
     44          status_t flash_is_protected(flash_driver_t * driver, uint32_t start, uint32_t lengthInBytes,
     45                                      flash_protection_state_t * protection_state)
     46          {
   \                     flash_is_protected: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0A9             SUB      SP,SP,#+164
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x4617             MOV      R7,R2
     47              if (protection_state == NULL)
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2004             MOVEQ    R0,#+4
     48              {
     49                  return kStatus_InvalidArgument;
   \   00000012   0xD06A             BEQ.N    ??flash_is_protected_0
     50              }
     51          
     52              uint32_t endAddress;   // end address for protection check
     53              uint32_t protectionRegionSize;  // size of flash protection region
     54              uint32_t regionCheckedCounter;  // increments each time the flash address was checked for
     55                                              // protection status
     56              uint32_t regionCounter;  // incrementing variable used to increment through the flash
     57                                       // protection regions
     58              uint32_t protectStatusCounter;  // increments each time a flash region was detected as protected
     59          
     60              uint8_t flashRegionProtectStatus[FSL_FEATURE_FTFx_REGION_COUNT]; // array of the protection status for each
     61                                                              // protection region
     62              uint32_t flashRegionAddress[FSL_FEATURE_FTFx_REGION_COUNT+1];  // array of the start addresses for each flash
     63                                                            // protection region. Note this is REGION_COUNT+1
     64                                                            // due to requiring the next start address after
     65                                                            // the end of flash for loop-check purposes below
     66          
     67              // Check the supplied address range.
     68              status_t returnCode = flash_check_range(driver, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \   00000014   0x2304             MOVS     R3,#+4
   \   00000016   0x.... 0x....      BL       flash_check_range
     69              if (returnCode)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD165             BNE.N    ??flash_is_protected_0
     70              {
     71                  return returnCode;
     72              }
     73          
     74              // calculating Flash end address
     75              endAddress = start + lengthInBytes;
     76          
     77              // Calculate the size of the flash protection region
     78              // If the flash density is > 32KB, then protection region is 1/32 of total flash density
     79              // Else if flash density is < 32KB, then flash protection region is set to 1KB
     80              if (driver->PFlashTotalSize > 32*1024)
   \   0000001E   0x6872             LDR      R2,[R6, #+4]
   \   00000020   0x1939             ADDS     R1,R7,R4
   \   00000022   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000026   0xBF8C             ITE      HI 
   \   00000028   0x0952             LSRHI    R2,R2,#+5
   \   0000002A   0xF44F 0x6280      MOVLS    R2,#+1024
     81              {
     82                  protectionRegionSize = (driver->PFlashTotalSize) / FSL_FEATURE_FTFx_REGION_COUNT;
     83              }
     84              else
     85              {
     86                  protectionRegionSize = 1024;
     87              }
     88          
     89              // populate the flashRegionAddress array with the start address of each flash region
     90              regionCounter = 0;  // make sure regionCounter is initialized to 0 first
   \   0000002E   0x2700             MOVS     R7,#+0
     91          
     92              // populate up to 33rd element of array, this is the next address after end of flash array
     93              while (regionCounter <= FSL_FEATURE_FTFx_REGION_COUNT)
     94              {
     95                  flashRegionAddress[regionCounter] = driver->PFlashBlockBase +
     96                                                      protectionRegionSize*regionCounter;
   \                     ??flash_is_protected_1: (+1)
   \   00000030   0xF8D6 0xC000      LDR      R12,[R6, #+0]
   \   00000034   0xFB07 0xCC02      MLA      R12,R7,R2,R12
   \   00000038   0xF84D 0xC027      STR      R12,[SP, R7, LSL #+2]
     97                  regionCounter++;
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
     98              }
   \   0000003E   0x2F21             CMP      R7,#+33
   \   00000040   0xD3F6             BCC.N    ??flash_is_protected_1
     99          
    100              // populate flashRegionProtectStatus array with status information
    101              // Protection status for each region is stored in the FPROT[3:0] registers
    102              // Each bit represents one region of flash
    103              // 4 registers * 8-bits-per-register = 32-bits (32-regions)
    104              // The convention is:
    105              // FPROT3[bit 0] is the first protection region (start of flash memory)
    106              // FPROT0[bit 7] is the last protection region (end of flash memory)
    107              // regionCounter is used to determine which FPROT[3:0] register to check for protection status
    108              // Note: FPROT=1 means NOT protected, FPROT=0 means protected
    109              regionCounter = 0;  // make sure regionCounter is initialized to 0 first
   \   00000042   0x2700             MOVS     R7,#+0
   \   00000044   0x4B2A             LDR.N    R3,??flash_is_protected_2  ;; 0x40020010
   \   00000046   0xAE21             ADD      R6,SP,#+132
   \   00000048   0xE001             B.N      ??flash_is_protected_3
    110              while (regionCounter < FSL_FEATURE_FTFx_REGION_COUNT)
    111              {
    112                  if (regionCounter < 8)
   \                     ??flash_is_protected_4: (+1)
   \   0000004A   0x2F08             CMP      R7,#+8
   \   0000004C   0xD204             BCS.N    ??flash_is_protected_5
    113                  {
    114                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT3) >> regionCounter)&(0x01);
   \                     ??flash_is_protected_3: (+1)
   \   0000004E   0xF893 0xE000      LDRB     LR,[R3, #+0]
   \   00000052   0xFA2E 0xFE07      LSR      LR,LR,R7
   \   00000056   0xE018             B.N      ??flash_is_protected_6
    115                  }
    116                  else if ((regionCounter >= 8)&& (regionCounter < 16))
   \                     ??flash_is_protected_5: (+1)
   \   00000058   0xF1A7 0x0E08      SUB      LR,R7,#+8
   \   0000005C   0xF1BE 0x0F08      CMP      LR,#+8
   \   00000060   0xD204             BCS.N    ??flash_is_protected_7
    117                  {
    118                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT2) >> (regionCounter-8))&(0x01);
   \   00000062   0xF893 0xE001      LDRB     LR,[R3, #+1]
   \   00000066   0xF1A7 0x0808      SUB      R8,R7,#+8
   \   0000006A   0xE00C             B.N      ??flash_is_protected_8
    119                  }
    120                  else if ((regionCounter >= 16)&& (regionCounter < 24))
   \                     ??flash_is_protected_7: (+1)
   \   0000006C   0xF1A7 0x0E10      SUB      LR,R7,#+16
   \   00000070   0xF1BE 0x0F08      CMP      LR,#+8
   \   00000074   0xBF39             ITTEE    CC 
   \   00000076   0xF893 0xE002      LDRBCC   LR,[R3, #+2]
   \   0000007A   0xF1A7 0x0810      SUBCC    R8,R7,#+16
   \   0000007E   0xF893 0xE003      LDRBCS   LR,[R3, #+3]
   \   00000082   0xF1A7 0x0818      SUBCS    R8,R7,#+24
    121                  {
    122                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT1) >> (regionCounter-16))&(0x01);
    123                  }
    124                  else
    125                  {
    126                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT0) >> (regionCounter-24))&(0x01);
   \                     ??flash_is_protected_8: (+1)
   \   00000086   0xFA2E 0xFE08      LSR      LR,LR,R8
   \                     ??flash_is_protected_6: (+1)
   \   0000008A   0xF00E 0x0E01      AND      LR,LR,#0x1
   \   0000008E   0xF807 0xE006      STRB     LR,[R7, R6]
    127                  }
    128                  regionCounter++;
   \   00000092   0x1C7F             ADDS     R7,R7,#+1
    129              }
   \   00000094   0x2F20             CMP      R7,#+32
   \   00000096   0xD3D8             BCC.N    ??flash_is_protected_4
    130          
    131              // loop through the flash regions and check
    132              // desired flash address range for protection status
    133              // loop stops when it is detected that start has exceeded the endAddress
    134              regionCounter = 0;  // make sure regionCounter is initialized to 0 first
    135              regionCheckedCounter = 0;
   \   00000098   0x2700             MOVS     R7,#+0
   \   0000009A   0xF04F 0x0E00      MOV      LR,#+0
    136              protectStatusCounter = 0; // make sure protectStatusCounter is initialized to 0 first
   \   0000009E   0x46BC             MOV      R12,R7
   \   000000A0   0xE017             B.N      ??flash_is_protected_9
    137              while (start < endAddress)
    138              {
    139                  // check to see if the address falls within this protection region
    140                  // Note that if the entire flash is to be checked, the last protection
    141                  // region checked would consist of the last protection start address and
    142                  // the start address following the end of flash
    143                  if ((start >= flashRegionAddress[regionCounter]) &&
    144                      (start < flashRegionAddress[regionCounter+1]))
   \                     ??flash_is_protected_10: (+1)
   \   000000A2   0x469E             MOV      LR,R3
   \                     ??flash_is_protected_11: (+1)
   \   000000A4   0xF85D 0x902E      LDR      R9,[SP, LR, LSL #+2]
   \   000000A8   0x454C             CMP      R4,R9
   \   000000AA   0xF10E 0x0301      ADD      R3,LR,#+1
   \   000000AE   0xD3F8             BCC.N    ??flash_is_protected_10
   \   000000B0   0x46E9             MOV      R9,SP
   \   000000B2   0xEB09 0x098E      ADD      R9,R9,LR, LSL #+2
   \   000000B6   0xF8D9 0x9004      LDR      R9,[R9, #+4]
   \   000000BA   0x454C             CMP      R4,R9
   \   000000BC   0xD2F1             BCS.N    ??flash_is_protected_10
    145                  {
    146                      // increment regionCheckedCounter to indicate this region was checked
    147                      regionCheckedCounter++;
    148          
    149                      // check the protection status of this region
    150                      // Note: FPROT=1 means NOT protected, FPROT=0 means protected
    151                      if (!flashRegionProtectStatus[regionCounter])
   \   000000BE   0xF81E 0xE006      LDRB     LR,[LR, R6]
   \   000000C2   0x1C7F             ADDS     R7,R7,#+1
   \   000000C4   0xF1BE 0x0F00      CMP      LR,#+0
   \   000000C8   0xBF08             IT       EQ 
   \   000000CA   0xF10C 0x0C01      ADDEQ    R12,R12,#+1
    152                      {
    153                          // increment protectStatusCounter to indicate this region is protected
    154                          protectStatusCounter++;
    155                      }
    156                      start += protectionRegionSize;  // increment to an address within the next region
   \   000000CE   0x1914             ADDS     R4,R2,R4
    157                  }
    158                  regionCounter++;  // increment regionCounter to check for the next flash protection region
   \   000000D0   0x469E             MOV      LR,R3
    159              }
   \                     ??flash_is_protected_9: (+1)
   \   000000D2   0x428C             CMP      R4,R1
   \   000000D4   0xD3E6             BCC.N    ??flash_is_protected_11
    160          
    161              // if protectStatusCounter == 0, then no region of the desired flash region is protected
    162              if (protectStatusCounter == 0)
   \   000000D6   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000DA   0xBF08             IT       EQ 
   \   000000DC   0x2100             MOVEQ    R1,#+0
    163              {
    164                  *protection_state  = kFlashProtection_Unprotected;
   \   000000DE   0xD003             BEQ.N    ??flash_is_protected_12
    165              }
    166              // if protectStatusCounter == regionCheckedCounter, then each region checked was protected
    167              else if (protectStatusCounter == regionCheckedCounter)
   \   000000E0   0x45BC             CMP      R12,R7
   \   000000E2   0xBF0C             ITE      EQ 
   \   000000E4   0x2101             MOVEQ    R1,#+1
   \   000000E6   0x2102             MOVNE    R1,#+2
    168              {
    169                  *protection_state  = kFlashProtection_Protected;
    170              }
    171              // if protectStatusCounter != regionCheckedCounter, then protection status is mixed
    172              // In other words, some regions are protected while others are unprotected
    173              else
    174              {
    175                  *protection_state  = kFlashProtection_Mixed;
   \                     ??flash_is_protected_12: (+1)
   \   000000E8   0x7029             STRB     R1,[R5, #+0]
    176              }
    177          
    178            return(returnCode);
   \                     ??flash_is_protected_0: (+1)
   \   000000EA   0xB029             ADD      SP,SP,#+164
   \   000000EC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   \                     ??flash_is_protected_2:
   \   000000F0   0x40020010         DC32     0x40020010
    179          }
    180          ////////////////////////////////////////////////////////////////////////////////
    181          // EOF
    182          ////////////////////////////////////////////////////////////////////////////////
    183          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     192   flash_is_protected
       192   -> flash_check_range


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     244  flash_is_protected

 
 244 bytes in section .text
 
 244 bytes of CODE memory

Errors: none
Warnings: none
