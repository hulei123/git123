###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:45:51
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\app_crc_check.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\app_crc_check.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\app_crc_check.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\app_crc_check.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\bootloader\src\app_crc_check.c
      1          /*
      2           * Copyright (c) 2014 - 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "utilities/fsl_assert.h"
     32          #include <string.h>
     33          #include "bootloader_common.h"
     34          #include "property/property.h"
     35          #include "memory/memory.h"
     36          #include "bootloader/context.h"
     37          #include "crc/crc32.h"
     38          #include "bootloader/app_crc_check.h"
     39          #include "utilities/vector_table_info.h"
     40          #include "target_config.h"
     41          
     42          ////////////////////////////////////////////////////////////////////////////////
     43          // Declarations
     44          ////////////////////////////////////////////////////////////////////////////////
     45          
     46          ////////////////////////////////////////////////////////////////////////////////
     47          // Code
     48          ////////////////////////////////////////////////////////////////////////////////
     49          #if BL_FEATURE_CRC_ASSERT
     50          //! @brief Toggle a pin to the inverse of default logic state to indicate crc check failure.
     51          static void assert_pin_to_indicate_crc_check_failure(void)
     52          {
     53              // Initialize pin for GPIO
     54              PORT_BWR_PCR_MUX(CRC_CHECK_FAILURE_PIN_PORT, CRC_CHECK_FAILURE_PIN_NUMBER, CRC_CHECK_FAILURE_PIN_GPIO_MODE);
     55              // Set pin as output
     56              GPIO_SET_PDDR(CRC_CHECK_FAILURE_PIN_GPIO, 1 << CRC_CHECK_FAILURE_PIN_NUMBER);
     57              // Toggle pin (the inverse of default logic state) for crc check failure
     58              GPIO_WR_PTOR(CRC_CHECK_FAILURE_PIN_GPIO, 1 << CRC_CHECK_FAILURE_PIN_NUMBER);
     59          }
     60          
     61          // See app_crc_check.h for documentation on this function.
     62          void restore_crc_check_failure_pin(void)
     63          {
     64              // Restore crc check failure pin to default state
     65              if (PORT_BRD_PCR_MUX(CRC_CHECK_FAILURE_PIN_PORT, CRC_CHECK_FAILURE_PIN_NUMBER) == CRC_CHECK_FAILURE_PIN_GPIO_MODE)
     66              {
     67                  // Restore pin as input
     68                  GPIO_CLR_PDDR(CRC_CHECK_FAILURE_PIN_GPIO, 1 << CRC_CHECK_FAILURE_PIN_NUMBER);
     69                  // Restore pin as default muxing slot mode
     70                  PORT_BWR_PCR_MUX(CRC_CHECK_FAILURE_PIN_PORT, CRC_CHECK_FAILURE_PIN_NUMBER, CRC_CHECK_FAILURE_PIN_DEFAULT_MODE);
     71              }
     72          }
     73          #endif
     74          // See app_crc_check.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
     75          void init_crc_check_status(property_store_t * propertyStore)
     76          {
     77              // Crc check is available if BCA exists and crc parameters are set (not all 0xff bytes)
     78              if ( !((propertyStore->configurationData.crcStartAddress == 0xffffffff) &&
     79                     (propertyStore->configurationData.crcByteCount == 0xffffffff) &&
     80                     (propertyStore->configurationData.crcExpectedValue == 0xffffffff)) )
   \                     init_crc_check_status: (+1)
   \   00000000   0x6F41             LDR      R1,[R0, #+116]
   \   00000002   0xF111 0x0F01      CMN      R1,#+1
   \   00000006   0xBF01             ITTTT    EQ 
   \   00000008   0x6F81             LDREQ    R1,[R0, #+120]
   \   0000000A   0xF111 0x0F01      CMNEQ    R1,#+1
   \   0000000E   0x6FC1             LDREQ    R1,[R0, #+124]
   \   00000010   0xF111 0x0F01      CMNEQ    R1,#+1
   \   00000014   0xD002             BEQ.N    ??init_crc_check_status_0
     81              {
     82                  propertyStore->crcCheckStatus = kStatus_AppCrcCheckInactive;
   \   00000016   0xF642 0x01A2      MOVW     R1,#+10402
   \   0000001A   0xE001             B.N      ??init_crc_check_status_1
     83              }
     84              else
     85              {
     86                  propertyStore->crcCheckStatus = kStatus_AppCrcCheckInvalid;
   \                     ??init_crc_check_status_0: (+1)
   \   0000001C   0xF642 0x01A3      MOVW     R1,#+10403
   \                     ??init_crc_check_status_1: (+1)
   \   00000020   0x62C1             STR      R1,[R0, #+44]
     87              }
     88          }
   \   00000022   0x4770             BX       LR               ;; return
     89          
     90          //! @brief Calculate crc on a range of flash, specified in the bootloader configuration area.
     91          static uint32_t calculate_application_crc32(bootloader_configuration_data_t * config)
     92          {
     93              uint32_t crc32;
     94          
     95              // Initialize the CRC32 information
     96              crc32_data_t crcInfo;
     97              crc32_init(&crcInfo);
     98          
     99              // Run CRC, Considering skip crcExpectedValue address
    100              uint32_t bypassStartAddress = kBootloaderConfigAreaAddress + ((uint32_t)&config->crcExpectedValue - (uint32_t)&config->tag);
    101              uint32_t bypassEndAddress = bypassStartAddress + sizeof(config->crcExpectedValue);
    102          
    103              if ((config->crcStartAddress >= bypassEndAddress) || (config->crcStartAddress + config->crcByteCount <= bypassStartAddress))
    104              {
    105                  crc32_update(&crcInfo, (uint8_t *)config->crcStartAddress, config->crcByteCount);
    106              }
    107              else
    108              {
    109                  // Assume that crcExpectedValue address (4 byte) resides in crc addresses completely
    110                  crc32_update(&crcInfo, (uint8_t *)config->crcStartAddress, bypassStartAddress - config->crcStartAddress);
    111                  crc32_update(&crcInfo, (uint8_t *)bypassEndAddress, config->crcStartAddress + config->crcByteCount - bypassEndAddress);
    112              }
    113          
    114              // Finalize the CRC calculations
    115              crc32_finalize(&crcInfo, &crc32);
    116          
    117              return crc32;
    118          }
    119          
    120          //! @brief Check if crc check addresses reside in the range of valid memory space (Pflash or QSPIflash)
    121          static bool is_crc_check_address_valid(bootloader_configuration_data_t * config)
    122          {
    123              bool isAddressValid;
    124          
    125              // Check if crc byte count is not equal to zero and crc end address does't exceed 4G address space
    126              isAddressValid = (config->crcByteCount != 0) && (config->crcStartAddress <= 0xffffffff - config->crcByteCount + 1);
    127          
    128              // Check if addresses reside in internal flash
    129              const memory_map_entry_t* map = (const memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
    130              if (isAddressValid)
    131              {
    132                  isAddressValid = ( (config->crcStartAddress >= map->startAddress) &&
    133                                     (config->crcStartAddress + config->crcByteCount - 1 <= map->endAddress) );
    134          #if BL_HAS_QSPI_MODULE
    135                  // Check if addresses reside in external QSPI flash
    136                  if ((!isAddressValid) && is_qspi_present())
    137                  {
    138                      map = (const memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexQspiMemory];
    139          
    140                      isAddressValid = ( (config->crcStartAddress >=  map->startAddress) &&
    141                                         (config->crcStartAddress + config->crcByteCount - 1 <= map->endAddress) );
    142                  }
    143          #endif // BL_HAS_QSPI_MODULE
    144              }
    145          
    146              return isAddressValid;
    147          }
    148          
    149          // See app_crc_check.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    150          bool is_application_crc_check_pass(void)
    151          {
   \                     is_application_crc_check_pass: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
    152              bool isCrcCheckPassed = true;
    153          
    154              property_store_t * propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000002   0x....             LDR.N    R0,??DataTable0
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x690C             LDR      R4,[R1, #+16]
    155              if (kStatus_AppCrcCheckInvalid != propertyStore->crcCheckStatus)
   \   00000008   0x6AE1             LDR      R1,[R4, #+44]
   \   0000000A   0x2501             MOVS     R5,#+1
   \   0000000C   0xF642 0x02A3      MOVW     R2,#+10403
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xD03F             BEQ.N    ??is_application_crc_check_pass_0
    156              {
    157                  isCrcCheckPassed = false;
    158          
    159                  // Check if crc check addresses reside in the range of valid memory space (Pflash or QSPIflash)
    160                  if (is_crc_check_address_valid(&propertyStore->configurationData))
   \   00000014   0xF104 0x0170      ADD      R1,R4,#+112
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0x688A             LDR      R2,[R1, #+8]
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD036             BEQ.N    ??is_application_crc_check_pass_1
   \   00000020   0x1D0E             ADDS     R6,R1,#+4
   \   00000022   0x4253             RSBS     R3,R2,#+0
   \   00000024   0x6831             LDR      R1,[R6, #+0]
   \   00000026   0x428B             CMP      R3,R1
   \   00000028   0xBF22             ITTT     CS 
   \   0000002A   0x6840             LDRCS    R0,[R0, #+4]
   \   0000002C   0x6803             LDRCS    R3,[R0, #+0]
   \   0000002E   0x4299             CMPCS    R1,R3
   \   00000030   0xBF21             ITTTT    CS 
   \   00000032   0x6840             LDRCS    R0,[R0, #+4]
   \   00000034   0x1851             ADDCS    R1,R2,R1
   \   00000036   0x1E49             SUBCS    R1,R1,#+1
   \   00000038   0x4288             CMPCS    R0,R1
   \   0000003A   0xD328             BCC.N    ??is_application_crc_check_pass_1
    161                  {
    162                      uint32_t calculated_crc = calculate_application_crc32(&propertyStore->configurationData);
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x.... 0x....      BL       crc32_init
   \   00000042   0x200C             MOVS     R0,#+12
   \   00000044   0xF500 0x4023      ADD      R0,R0,#+41728
   \   00000048   0x30C0             ADDS     R0,R0,#+192
   \   0000004A   0x6831             LDR      R1,[R6, #+0]
   \   0000004C   0x6872             LDR      R2,[R6, #+4]
   \   0000004E   0x1D07             ADDS     R7,R0,#+4
   \   00000050   0x42B9             CMP      R1,R7
   \   00000052   0xBF3C             ITT      CC 
   \   00000054   0x1853             ADDCC    R3,R2,R1
   \   00000056   0x4298             CMPCC    R0,R3
   \   00000058   0xD208             BCS.N    ??is_application_crc_check_pass_2
   \   0000005A   0x1A42             SUBS     R2,R0,R1
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x.... 0x....      BL       crc32_update
   \   00000062   0x6830             LDR      R0,[R6, #+0]
   \   00000064   0x6871             LDR      R1,[R6, #+4]
   \   00000066   0x1808             ADDS     R0,R1,R0
   \   00000068   0x1BC2             SUBS     R2,R0,R7
   \   0000006A   0x4639             MOV      R1,R7
   \                     ??is_application_crc_check_pass_2: (+1)
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       crc32_update
   \   00000072   0xA902             ADD      R1,SP,#+8
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x.... 0x....      BL       crc32_finalize
    163          
    164                      if (calculated_crc != propertyStore->configurationData.crcExpectedValue)
   \   0000007A   0x9802             LDR      R0,[SP, #+8]
   \   0000007C   0x6FE1             LDR      R1,[R4, #+124]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xBF06             ITTE     EQ 
   \   00000082   0x2501             MOVEQ    R5,#+1
   \   00000084   0xF642 0x00A0      MOVWEQ   R0,#+10400
   \   00000088   0xF642 0x00A1      MOVWNE   R0,#+10401
    165                      {
    166                          propertyStore->crcCheckStatus = kStatus_AppCrcCheckFailed;
    167                      }
    168                      else
    169                      {
    170                          isCrcCheckPassed = true;
    171                          propertyStore->crcCheckStatus = kStatus_AppCrcCheckPassed;
   \   0000008C   0xE001             B.N      ??is_application_crc_check_pass_3
    172                      }
    173                  }
    174                  else
    175                  {
    176                      propertyStore->crcCheckStatus = kStatus_AppCrcCheckOutOfRange;
   \                     ??is_application_crc_check_pass_1: (+1)
   \   0000008E   0xF642 0x00A4      MOVW     R0,#+10404
   \                     ??is_application_crc_check_pass_3: (+1)
   \   00000092   0x62E0             STR      R0,[R4, #+44]
    177                  }
    178          #if BL_FEATURE_CRC_ASSERT
    179                  if (!isCrcCheckPassed)
    180                  {
    181                      assert_pin_to_indicate_crc_check_failure();
    182                  }
    183          #endif        
    184              }
    185          
    186              return isCrcCheckPassed;
   \                     ??is_application_crc_check_pass_0: (+1)
   \   00000094   0x4628             MOV      R0,R5
   \   00000096   0xBDFE             POP      {R1-R7,PC}       ;; return
    187          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     g_bootloaderContext
    188          
    189          ////////////////////////////////////////////////////////////////////////////////
    190          // EOF
    191          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   init_crc_check_status
      32   is_application_crc_check_pass
        32   -> crc32_finalize
        32   -> crc32_init
        32   -> crc32_update


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      36  init_crc_check_status
     152  is_application_crc_check_pass

 
 192 bytes in section .text
 
 192 bytes of CODE memory

Errors: none
Warnings: none
