###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\khci\khci_dev.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\khci\khci_dev.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\khci_dev.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\khci_dev.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\controller\khci\khci_dev.c
      1          /**HEADER**********************************************************************
      2          *
      3          * Copyright (c) 2009, 2013 - 2014 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          *******************************************************************************
      7          *
      8          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
      9          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     10          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     11          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     12          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     13          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     14          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     15          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     16          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     17          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     18          * THE POSSIBILITY OF SUCH DAMAGE.
     19          *
     20          **************************************************************************
     21          *
     22          * $FileName: khci_dev.c$
     23          * $Version : 
     24          * $Date    : 
     25          *
     26          * Comments:
     27          *
     28          *   This file contains the main usbfs USB Device Controller interface
     29          *   functions.
     30          *
     31          *END************************************************************************/
     32          
     33          /******************************************************************************
     34           *               BUFFER DISCRIPTOR TABLE (BDT) DISCRIPTION                    *
     35           ******************************************************************************/
     36           /**
     37           * The USB-FS implements a Buffer Descriptor Table (BDT) in system memory. The
     38           * BDT resides on a 512 byte boundary in system memory and is pointed to by the
     39           * BDT Page Registers. Every endpoint direction requires two eight-byte Buffer
     40           * Descriptor entries.Therefore, a system with 16 fully bidirectional endpoints
     41           * would require 512 bytes of system memory to implement the BDT.The two Buffer
     42           * Descriptor (BD) entries allows for an EVEN BD and ODD BD entry for each
     43           * endpoint direction. This allows the microprocessor to process one BD while
     44           * the USB-FS is processing the other BD. Double buffering BDs in this way
     45           * allows the USB-FS to easily transfer data at the maximum throughput provided
     46           * by USB.
     47           *
     48           * Because the buffers are shared between the microprocessor and the USB-FS a
     49           * simple semaphore mechanism is used to distinguish who is allowed to update
     50           * the BDT and buffers in system memory. A semaphore bit, the OWN bit, is
     51           * cleared to 0 when the BD entry is owned by the microprocessor. The
     52           * microprocessor is allowed read and write access to the BD entry and the
     53           * buffer in system memory when the OWN bit is 0.
     54           * When the OWN bit is set to 1, the BD entry and the buffer in system memory
     55           * are owned by the USB-FS. The USB-FS now has full read and write access and
     56           * the microprocessor should not modify the BD or its corresponding data buffer.
     57           * The BD also contains indirect address pointers to where the actual buffer
     58           * resides in system memory.
     59           ******************************************************************************
     60           *                 BUFFER DISCRIPTOR FORMAT DISCRIPTION
     61           ******************************************************************************
     62           * The Buffer Descriptors have different meaning based on who is reading the BD
     63           * in memory.The USB-FS Controller uses the data stored in BDs to determine:
     64           *
     65           *       # Who owns the buffer in system memory
     66           *       # Data0 or Data1 PID
     67           *       # Release Own upon packet completion
     68           *       # No address increment (FIFO Mode)
     69           *       # Data toggle synchronization enable
     70           *       # How much data is to be transmitted or received
     71           *       # Where the buffer resides in system memory
     72           *
     73           * While the microprocessor uses the data stored in the BDs to determine:
     74           *       # Who owns the buffer in system memory
     75           *       # Data0 or Data1 PID
     76           *       # The received TOKEN PID
     77           *       # How much data was transmitted or received
     78           *       # Where the buffer resides in system memory
     79           *
     80           *    ------ ------ ------ ------ -------- ---------- ---------- ---------- ---------- ---------- ----------
     81           *   |31-26 |25-16 | 15-8 |  7   |   6    |   5      |   4      |   3      |   2      |   1      |   0      |
     82           *   |RSVD  | BC   | RSVD | OWN  |DATA0/1 |TOK_PID[3]|TOK_PID[2]|TOK_PID[1]|TOK_PID[0]|TOK_PID[n]| reserved |
     83           *    ------ ------ ------ ------ -------- ---------- ---------- ---------- ---------- ---------- ----------
     84           *   |                             ADDRESS[31--0]                                                           |
     85           *   |                                                                                                      |
     86           *    -------------------------------------------------------------------------------------------------------
     87           *
     88           * This Buffer Discriptor table is represented by the variable "BDT_BASE"
     89           * defined in file usbfs_dev_main.h. Macros such as "BD_ADDR_RX" and
     90           * "BD_ADDR_TX" is used to manipulate the address field and Macros such as
     91           * BD_CTRL_RX and BD_CTRL_TX is used to manipulate the control fields.
     92           */
     93          
     94          
     95          /******************************************************************************
     96           * Includes
     97           *****************************************************************************/
     98          #include "usb_device_config.h"
     99          #if USBCFG_DEV_KHCI
    100          #include "usb.h"
    101          #include "usb_device_stack_interface.h"
    102          #include "khci_dev.h"
    103          #include "khci_dev_misc.h"
    104          #include "fsl_usb_khci_hal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void usb_hal_khci_endpoint_enable_handshake(uint32_t, uint32_t, uint32_t)
   \                     usb_hal_khci_endpoint_enable_handshake: (+1)
   \   00000000   0x2A01             CMP      R2,#+1
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0x400720c0
   \   00000006   0xBF0C             ITE      EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   \   0000000A   0x2000             MOVNE    R0,#+0
   \   0000000C   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1
   \   00000002   0xF812 0x3021      LDRB     R3,[R2, R1, LSL #+2]
   \   00000006   0x4318             ORRS     R0,R0,R3
   \   00000008   0xF802 0x0021      STRB     R0,[R2, R1, LSL #+2]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void usb_hal_khci_endpoint_set_direction(uint32_t, uint32_t, uint8_t)
   \                     usb_hal_khci_endpoint_set_direction: (+1)
   \   00000000   0x2A01             CMP      R2,#+1
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0x400720c0
   \   00000006   0xBF0C             ITE      EQ 
   \   00000008   0x2004             MOVEQ    R0,#+4
   \   0000000A   0x2008             MOVNE    R0,#+8
   \   0000000C                      REQUIRE ?Subroutine0
   \   0000000C                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void usb_hal_khci_endpoint_clr_stall(uint32_t, uint32_t)
   \                     usb_hal_khci_endpoint_clr_stall: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x400720c0
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0xF810 0x2021      LDRB     R2,[R0, R1, LSL #+2]
   \   0000000A   0xF002 0x02FD      AND      R2,R2,#0xFD
   \   0000000E   0xF800 0x2021      STRB     R2,[R0, R1, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
    105          #ifdef   USBCFG_OTG
    106          #include "usb_otg_main.h"
    107          #include "usb_otg_private.h"
    108          #endif
    109          #define MAX_KHCI_DEV_NUM 1
    110          
    111          /****************************************************************************
    112           * Global Variables
    113           ****************************************************************************/
    114          static uint8_t *bdt;
    115          #if ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK))
    116          #if defined( __ICCARM__ )
    117              #pragma data_alignment=512

   \                                 In section .noinit, align 512
    118              __no_init usb_device_khci_data_t g_khci_data;
   \                     g_khci_data:
   \   00000000                      DS8 928

   \                                 In section .bss, align 4
    119          #elif defined (__CC_ARM) || defined(__GNUC__)
    120              __attribute__((aligned(512))) usb_device_khci_data_t g_khci_data;
    121          #else
    122              #error Unsupported compiler, please use IAR, Keil or arm gcc compiler and rebuild the project.
    123          #endif
    124          
    125          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
    126              usb_device_khci_data_t* g_khci_data_ptr = NULL;
    127          #endif
    128          
    129          
    130          
    131          static bool g_zero_pkt_send = FALSE;
   \                     g_zero_pkt_send:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
    132          

   \                                 In section .bss, align 4
    133          static usb_khci_dev_state_struct_t g_khci_dev[MAX_KHCI_DEV_NUM];
   \                     g_khci_dev:
   \   00000000                      DS8 176
    134          
    135          #if USBCFG_KHCI_4BYTE_ALIGN_FIX

   \                                 In section .bss, align 4
    136          static uint8_t *_usb_khci_dev_swap_buf_ptr = NULL;
   \                     _usb_khci_dev_swap_buf_ptr:
   \   00000000                      DS8 4
    137          #endif
    138          
    139          
    140          extern usb_status _usb_device_call_service(uint8_t,usb_event_struct_t*);
    141          extern uint32_t soc_get_usb_base_address(uint8_t controller_id);
    142          
    143          #ifdef USBCFG_OTG
    144          extern usb_otg_handle *  g_usb_otg_handle;
    145          #endif
    146          extern uint8_t soc_get_usb_vector_number(uint8_t);
    147          
    148          #if USBCFG_DEV_DETACH_ENABLE
    149          /*FUNCTION*-------------------------------------------------------------
    150          *
    151          *  Function Name  : usb_dci_khci_detach
    152          *  Returned Value : void
    153          *  Comments       :
    154          *        this function is called if device known it's detached.
    155          *
    156          *END*-----------------------------------------------------------------*/
    157          void usb_dci_khci_detach(void)
    158          {
    159              usb_event_struct_t event;
    160              usb_khci_dev_state_struct_t* state_ptr;
    161              state_ptr = (usb_khci_dev_state_struct_t*)(&g_khci_dev[0]);
    162              
    163              /* Initialize the event strucutre to be passed to the upper layer*/
    164              event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
    165              event.ep_num = 0;
    166              event.setup = 0;
    167              event.direction = 0;
    168           
    169              /* propagate control to upper layers for processing */
    170              _usb_device_call_service(USB_SERVICE_DETACH, &event);
    171          }
    172          #endif
    173          
    174          /*FUNCTION*-------------------------------------------------------------
    175          *
    176          *  Function Name  : usb_dci_khci_free_xd
    177          *  Returned Value : void
    178          *  Comments       :
    179          *        Enqueues a XD onto the free XD ring.
    180          *
    181          *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    182          void usb_dci_khci_free_xd
    183          (
    184              usb_device_handle  handle,
    185              /* [IN] the dTD to enqueue */
    186              xd_struct_t*       xd_ptr
    187          )
    188          { /* Body */
   \                     usb_dci_khci_free_xd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    189              usb_khci_dev_state_struct_t* usb_dev_ptr = (usb_khci_dev_state_struct_t*)handle;
    190          
    191              /*
    192               ** This function can be called from any context, and it needs mutual
    193               ** exclusion with itself.
    194               */
    195              OS_Lock();
   \   00000006   0x.... 0x....      BL       sys_lock
    196          
    197              /*
    198               ** Add the XD to the free XD queue (linked via PRIVATE) and
    199               ** increment the tail to the next descriptor
    200               */
    201              if (usb_dev_ptr->xd_head == NULL)
   \   0000000A   0x6920             LDR      R0,[R4, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xBF0E             ITEE     EQ 
   \   00000010   0x6125             STREQ    R5,[R4, #+16]
   \   00000012   0x6960             LDRNE    R0,[R4, #+20]
   \   00000014   0x6105             STRNE    R5,[R0, #+16]
    202              {
    203                  usb_dev_ptr->xd_head = xd_ptr;
    204              }
    205              else
    206              {
    207                  usb_dev_ptr->xd_tail->next = xd_ptr;
    208              }
    209              usb_dev_ptr->xd_tail = xd_ptr;
   \   00000016   0x6165             STR      R5,[R4, #+20]
    210              xd_ptr->next = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6128             STR      R0,[R5, #+16]
    211              usb_dev_ptr->xd_entries ++;
   \   0000001C   0x69A0             LDR      R0,[R4, #+24]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x61A0             STR      R0,[R4, #+24]
    212          
    213              OS_Unlock();
   \   00000022   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      sys_unlock
    214          } /* Endbody */
    215          
    216           /*FUNCTION*-------------------------------------------------------------
    217           *
    218           *  Function Name  : usb_dci_khci_get_xd
    219           *  Returned Value : void
    220           *  Comments       :
    221           *        get an XD from the free XD ring.
    222           *
    223           *END*-----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    224          usb_status usb_dci_khci_get_xd
    225          (
    226              usb_device_handle handle,
    227              /* [IN] the dTD to enqueue */
    228              xd_struct_t**      xd_ptr_ptr
    229          )
    230          {   /* Body */
   \                     usb_dci_khci_get_xd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    231              usb_khci_dev_state_struct_t*   usb_dev_ptr = handle;
    232              
    233              /* This function can be called from any context, and it needs mutual
    234                 exclusion with itself.*/
    235              OS_Lock();
   \   00000006   0x.... 0x....      BL       sys_lock
    236              
    237              /* Get a transfer descriptor for the specified endpoint 
    238               ** and direction 
    239               */
    240              if (!usb_dev_ptr->xd_entries)
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0xB918             CBNZ.N   R0,??usb_dci_khci_get_xd_0
    241              {
    242                  OS_Unlock();
   \   0000000E   0x.... 0x....      BL       sys_unlock
    243                  return USBERR_DEVICE_BUSY;
   \   00000012   0x20C1             MOVS     R0,#+193
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}
    244              }
    245          
    246              *xd_ptr_ptr = usb_dev_ptr->xd_head;
   \                     ??usb_dci_khci_get_xd_0: (+1)
   \   00000016   0x6920             LDR      R0,[R4, #+16]
   \   00000018   0x6028             STR      R0,[R5, #+0]
    247              if (usb_dev_ptr->xd_head)
   \   0000001A   0x6920             LDR      R0,[R4, #+16]
   \   0000001C   0xB118             CBZ.N    R0,??usb_dci_khci_get_xd_1
    248              {
    249                  usb_dev_ptr->xd_head = usb_dev_ptr->xd_head->next;
   \   0000001E   0x6900             LDR      R0,[R0, #+16]
   \   00000020   0x6120             STR      R0,[R4, #+16]
    250                  if (usb_dev_ptr->xd_head == NULL)
   \   00000022   0xB900             CBNZ.N   R0,??usb_dci_khci_get_xd_1
    251                  {
    252                      usb_dev_ptr->xd_tail = NULL;
   \   00000024   0x6160             STR      R0,[R4, #+20]
    253                  }
    254              }
    255              usb_dev_ptr->xd_entries--;
   \                     ??usb_dci_khci_get_xd_1: (+1)
   \   00000026   0x69A0             LDR      R0,[R4, #+24]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x61A0             STR      R0,[R4, #+24]
    256              OS_Unlock();
   \   0000002C   0x.... 0x....      BL       sys_unlock
    257          
    258              return USB_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    259          } /* Endbody */
    260          
    261          /**************************************************************************//*!
    262          *
    263          * @name        : usb_dci_khci_init_xd
    264          * @brief       : initialize the xd.
    265          * @param handle: Handle to USB Device to be filled
    266          * @return   USB_OK on successful.
    267          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    268          usb_status usb_dci_khci_init_xd
    269          (
    270              /* [IN] the USB device handle */
    271              usb_device_handle handle
    272          )
    273          {
    274              usb_khci_dev_state_struct_t* usb_dev_ptr = (usb_khci_dev_state_struct_t*)handle;
    275              xd_struct_t*                 xd_ptr;
    276              uint32_t                     j;
    277          
    278          #if ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK))
    279              usb_dev_ptr->setup_buff = (uint8_t *) g_khci_data.setup_packet;   
   \                     usb_dci_khci_init_xd: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000004   0xF501 0x7200      ADD      R2,R1,#+512
    280              usb_dev_ptr->xd_head = usb_dev_ptr->xd_base = (xd_struct_t*) g_khci_data.xd_base;
   \   00000008   0xF501 0x7114      ADD      R1,R1,#+592
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0x6101             STR      R1,[R0, #+16]
   \   00000010   0x62C2             STR      R2,[R0, #+44]
    281          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
    282              usb_dev_ptr->setup_buff = (uint8_t *) g_khci_data_ptr->setup_packet;   
    283              usb_dev_ptr->xd_head = usb_dev_ptr->xd_base = (xd_struct_t*) g_khci_data_ptr->xd_base;
    284          #endif
    285          
    286              usb_dev_ptr->xd_entries = USBCFG_DEV_MAX_XDS;
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0x6181             STR      R1,[R0, #+24]
    287          
    288              /* Enqueue all the XDs */   
    289              xd_ptr = (xd_struct_t*) usb_dev_ptr->xd_base;
    290          
    291              for (j = 0; j < USBCFG_DEV_MAX_XDS - 1; j++) 
   \   00000016   0x220B             MOVS     R2,#+11
   \   00000018   0x68C1             LDR      R1,[R0, #+12]
    292              {
    293                  xd_ptr->next = xd_ptr + 1;
   \                     ??usb_dci_khci_init_xd_0: (+1)
   \   0000001A   0xF101 0x031C      ADD      R3,R1,#+28
   \   0000001E   0x610B             STR      R3,[R1, #+16]
    294                  //usb_dci_khci_free_xd(usb_dev_ptr, xd_ptr);
    295                  xd_ptr++;
    296              }
   \   00000020   0x1E52             SUBS     R2,R2,#+1
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0xD1F9             BNE.N    ??usb_dci_khci_init_xd_0
    297              xd_ptr->next = 0;
   \   00000026   0x610A             STR      R2,[R1, #+16]
    298              usb_dev_ptr->xd_tail = xd_ptr;
   \   00000028   0x6141             STR      R1,[R0, #+20]
    299          
    300              return USB_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
    301          }  
    302          
    303          
    304          /*****************************************************************************
    305           * Local Functions
    306           *****************************************************************************/
    307           /*****************************************************************************
    308           * Local Functions
    309           *****************************************************************************/
    310          
    311          
    312          /******************************************************************************
    313           *
    314           * @name  _usb_khci_next_setup_token_prep
    315           *
    316           * @brief The function prepares for next setup token
    317           *
    318           * @param state_ptr:      Device info Structure.
    319           *
    320           * @return NONE
    321           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    322          static void _usb_khci_next_setup_token_prep
    323          (
    324              usb_khci_dev_state_struct_t* state_ptr
    325          )
    326          {
   \                     _usb_khci_next_setup_token_prep: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    327              xd_struct_t* xd_ptr_temp;
    328              usb_dci_khci_get_xd (state_ptr, &xd_ptr_temp);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       usb_dci_khci_get_xd
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000016   0x0A40             LSRS     R0,R0,#+9
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x7DCB             LDRB     R3,[R1, #+23]
   \   0000001C   0x0240             LSLS     R0,R0,#+9
   \   0000001E   0xB90B             CBNZ.N   R3,??_usb_khci_next_setup_token_prep_0
    329              /* prepare XD queue for RECV CONTROL ENDPOINT*/
    330              if (state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_buf_odd == 0x0)
    331              {
    332                  //BD_ADDR_RX(USB_CONTROL_ENDPOINT, state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_buf_odd) =
    333                  //    USB_LONG_LE_TO_HOST((uint32_t)state_ptr->setup_buff);
    334                  usb_hal_khci_bdt_set_address( (uint32_t)bdt, USB_CONTROL_ENDPOINT, USB_RECV, 0, (uint32_t)state_ptr->setup_buff);
   \   00000020   0x6042             STR      R2,[R0, #+4]
    335                  xd_ptr_temp->wstartaddress = state_ptr->setup_buff;
   \   00000022   0xE005             B.N      ??_usb_khci_next_setup_token_prep_1
    336              }
    337              else
    338              {
    339                  //BD_ADDR_RX(USB_CONTROL_ENDPOINT, state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_buf_odd) =
    340                  //    USB_LONG_LE_TO_HOST((uint32_t)state_ptr->setup_buff+ SETUP_PACKET_LENGTH);
    341                  usb_hal_khci_bdt_set_address( (uint32_t)bdt, USB_CONTROL_ENDPOINT, USB_RECV, 1, (uint32_t)(state_ptr->setup_buff+SETUP_PACKET_LENGTH));
   \                     ??_usb_khci_next_setup_token_prep_0: (+1)
   \   00000024   0xF040 0x0408      ORR      R4,R0,#0x8
   \   00000028   0xF102 0x0308      ADD      R3,R2,#+8
   \   0000002C   0x6063             STR      R3,[R4, #+4]
    342                  xd_ptr_temp->wstartaddress = state_ptr->setup_buff + SETUP_PACKET_LENGTH;
   \   0000002E   0x3208             ADDS     R2,R2,#+8
   \                     ??_usb_khci_next_setup_token_prep_1: (+1)
   \   00000030   0x9B00             LDR      R3,[SP, #+0]
   \   00000032   0x605A             STR      R2,[R3, #+4]
    343              }
    344              xd_ptr_temp->ep_num = USB_CONTROL_ENDPOINT;
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x9B00             LDR      R3,[SP, #+0]
   \   00000038   0x701A             STRB     R2,[R3, #+0]
    345              xd_ptr_temp->bdirection = USB_RECV;
   \   0000003A   0x9B00             LDR      R3,[SP, #+0]
   \   0000003C   0x705A             STRB     R2,[R3, #+1]
    346              xd_ptr_temp->wtotallength = ZERO_LENGTH;
   \   0000003E   0x9B00             LDR      R3,[SP, #+0]
   \   00000040   0x609A             STR      R2,[R3, #+8]
    347              xd_ptr_temp->ep_type = USB_CONTROL_PIPE;
   \   00000042   0x9B00             LDR      R3,[SP, #+0]
   \   00000044   0x709A             STRB     R2,[R3, #+2]
    348          #if USBCFG_KHCI_4BYTE_ALIGN_FIX
    349              xd_ptr_temp->internal_dma_align = TRUE;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x9B00             LDR      R3,[SP, #+0]
   \   0000004A   0x75DA             STRB     R2,[R3, #+23]
    350          #endif
    351              //USB_XD_QUEUE_ENQUEUE(&state_ptr->ep_info[USB_CONTROL_ENDPOINT].xd_queue_recv, xd_ptr_temp);
    352              state_ptr->ep_info[USB_CONTROL_ENDPOINT].recv_xd = xd_ptr_temp;
   \   0000004C   0x9A00             LDR      R2,[SP, #+0]
   \   0000004E   0x608A             STR      R2,[R1, #+8]
    353              /* toggle send buffer */
    354              //state_ptr->ep_info[USB_CONTROL_ENDPOINT].tx_buf_odd ^= 1;
    355              
    356              /* configure data pid for setup token and give control to SEI*/
    357              state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_data0 = 0;
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x754A             STRB     R2,[R1, #+21]
    358              usb_hal_khci_bdt_set_control( (uint32_t)bdt, USB_CONTROL_ENDPOINT, USB_RECV, state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_buf_odd,
    359                                           USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(SETUP_PACKET_LENGTH)| USB_BD_OWN | USB_BD_DTS | USB_BD_DATA01(state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_data0))));
   \   00000054   0x7DC9             LDRB     R1,[R1, #+23]
   \   00000056   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000005A   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable20_3  ;; 0x80088
   \   00000062   0x6001             STR      R1,[R0, #+0]
    360              //BD_CTRL_RX(USB_CONTROL_ENDPOINT, state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_buf_odd) =
    361              //USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(SETUP_PACKET_LENGTH)|
    362              //    USB_BD_OWN | USB_BD_DTS | USB_BD_DATA01(state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_data0)));
    363              //USB_PRINTF("ready to receive on EP0 setup\n");
    364              /* setup token is always on DATA0 PID */
    365              return;
   \   00000064   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    366          }
    367          
    368          /**************************************************************************//*!
    369           *
    370           * @name  _usb_khci_ep_read
    371           *
    372           * @brief The function reads the endpoint buffers
    373           *
    374           * @param state_ptr:      Device info Structure.
    375           * @param ep_num:         endpoint number
    376           * @param buf_ptr:        buffer to receive in
    377           * @param buf_num_bytes:  number of bytes to read
    378           *
    379           * @return USB_OK         When Successfull
    380           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    381          static usb_status _usb_khci_ep_read
    382          (
    383               /*[IN]*/
    384              usb_khci_dev_state_struct_t* state_ptr,
    385               /*[IN]*/
    386              uint8_t ep_num,
    387               /*[OUT]*/
    388              uint8_t * buf_ptr,
    389               /*[IN]*/
    390              uint32_t buf_num_bytes
    391          )
    392          {   
   \                     _usb_khci_ep_read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    393              OS_Lock();
   \   0000000A   0x.... 0x....      BL       sys_lock
    394              
    395              /* USB data is directly transferred to App Buffer to Avoid one level of
    396               * memcpy. (i.e from Endpoint buffer to App buffer). So a hack here
    397               * is been provided. This hack stores the current endpoint buffer
    398               * address to a variable and programes the buffer address in the BDT
    399               * as APP buffer. Later when TOKEN_DNE interrupt is received for this Token
    400               * this buffer address saved is restored. Please note that at present
    401               * App should not release the buffer passed till he gets a notification from
    402               * interrupt handler.
    403               */
    404              
    405              usb_hal_khci_bdt_set_address( (uint32_t)bdt, ep_num, USB_RECV, state_ptr->ep_info[ep_num].rx_buf_odd, (uint32_t)buf_ptr);
   \   0000000E   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000012   0xF007 0x010F      AND      R1,R7,#0xF
   \   00000016   0xEA40 0x1041      ORR      R0,R0,R1, LSL #+5
   \   0000001A   0x2114             MOVS     R1,#+20
   \   0000001C   0xFB11 0x6107      SMLABB   R1,R1,R7,R6
   \   00000020   0x3141             ADDS     R1,R1,#+65
   \   00000022   0x788A             LDRB     R2,[R1, #+2]
   \   00000024   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000028   0xEA40 0x02C2      ORR      R2,R0,R2, LSL #+3
   \   0000002C   0x6054             STR      R4,[R2, #+4]
    406              //BD_ADDR_RX(ep_num, state_ptr->ep_info[ep_num].rx_buf_odd) =
    407              //    USB_LONG_LE_TO_HOST((uint32_t)buf_ptr);
    408          
    409              /* Program number of bytes to be received and give
    410               * the Control to the SEI
    411               */
    412              usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep_num, USB_RECV, state_ptr->ep_info[ep_num].rx_buf_odd,
    413                                           USB_LONG_LE_TO_HOST(USB_BD_BC(buf_num_bytes) | USB_BD_OWN | USB_BD_DTS | USB_BD_DATA01(state_ptr->ep_info[ep_num].rx_data0)));
   \   0000002E   0x788A             LDRB     R2,[R1, #+2]
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000036   0xEA40 0x00C2      ORR      R0,R0,R2, LSL #+3
   \   0000003A   0x05AA             LSLS     R2,R5,#+22
   \   0000003C   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000040   0x0D92             LSRS     R2,R2,#+22
   \   00000042   0x0189             LSLS     R1,R1,#+6
   \   00000044   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000048   0xF041 0x0188      ORR      R1,R1,#0x88
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    414              //BD_CTRL_RX(ep_num, state_ptr->ep_info[ep_num].rx_buf_odd) =
    415              //    USB_LONG_LE_TO_HOST(USB_BD_BC(buf_num_bytes) |
    416              //        USB_BD_OWN | USB_BD_DTS | USB_BD_DATA01(state_ptr->ep_info[ep_num].rx_data0));
    417              
    418              OS_Unlock();
   \   0000004E   0x.... 0x....      BL       sys_unlock
    419              
    420              usb_hal_khci_clr_token_busy(state_ptr->usbRegBase);
   \   00000052   0x.... 0x....      BL       ??Subroutine4_0
    421              return USB_OK;
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    422          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_2
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x0A40             LSRS     R0,R0,#+9
   \   00000006   0x0240             LSLS     R0,R0,#+9
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6008             STR      R0,[R1, #+0]
   \                     ??Subroutine4_0: (+1)
   \   00000002   0x....             LDR.N    R0,??DataTable20_12  ;; 0x40072094
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
    423          
    424          /**************************************************************************//*!
    425           *
    426           * @name  _usb_khci_ep_write
    427           *
    428           * @brief The function writes the endpoint buffers
    429           *
    430           * @param state_ptr:      Device info Structure.
    431           * @param ep_num:         endpoint number
    432           * @param buf_ptr:        buffer to send from
    433           * @param buf_num_bytes:  number of bytes to write
    434           * @param bytes_written_ptr: buffer that will  contian Number of bytes written
    435           *                           to device.
    436           *
    437           * @return USB_OK         When Successfull
    438           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    439          static usb_status _usb_khci_ep_write
    440          (
    441              /*[IN]*/
    442              usb_khci_dev_state_struct_t* state_ptr, 
    443              /*[IN]*/
    444              uint8_t ep_num,
    445              /*[IN]*/
    446              uint8_t * buf_ptr,
    447              /*[IN]*/
    448              uint32_t buf_num_bytes,
    449               /*[OUT]*/
    450              uint32_t* bytes_written_ptr 
    451          )
    452          {
   \                     _usb_khci_ep_write: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    453              uint16_t max_packet_size;
    454            
    455              /* If the number of bytes to be sent is greater than the
    456               * maximum data that can be sent on the USB bus, then split the
    457               * transaction, into multiple transaction.
    458               */
    459              max_packet_size = state_ptr->ep_info[ep_num].max_packet_size;
   \   00000002   0x2414             MOVS     R4,#+20
   \   00000004   0xFB14 0x0001      SMLABB   R0,R4,R1,R0
    460              
    461              if (buf_num_bytes > max_packet_size)
    462              {
    463                  buf_num_bytes = max_packet_size;
    464              }
    465              
    466              *bytes_written_ptr = buf_num_bytes;
   \   00000008   0xF001 0x010F      AND      R1,R1,#0xF
   \   0000000C   0xF830 0x4F38      LDRH     R4,[R0, #+56]!
   \   00000010   0x429C             CMP      R4,R3
   \   00000012   0xBF88             IT       HI 
   \   00000014   0x461C             MOVHI    R4,R3
   \   00000016   0x9B02             LDR      R3,[SP, #+8]
   \   00000018   0x601C             STR      R4,[R3, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable20_2
   \   0000001E   0x685B             LDR      R3,[R3, #+4]
   \   00000020   0x0A5B             LSRS     R3,R3,#+9
   \   00000022   0x025B             LSLS     R3,R3,#+9
   \   00000024   0xEA43 0x1141      ORR      R1,R3,R1, LSL #+5
   \   00000028   0x7A83             LDRB     R3,[R0, #+10]
   \   0000002A   0xF003 0x0301      AND      R3,R3,#0x1
   \   0000002E   0xEA41 0x03C3      ORR      R3,R1,R3, LSL #+3
   \   00000032   0xF043 0x0310      ORR      R3,R3,#0x10
   \   00000036   0x605A             STR      R2,[R3, #+4]
    467              
    468              /* Program the endpoint buffer address in BDT
    469               * from where DMA will pick the Data to be sent over USB bus.
    470               */
    471              //BD_ADDR_TX(ep_num, state_ptr->ep_info[ep_num].tx_buf_odd) =
    472              //    USB_LONG_LE_TO_HOST((uint32_t)buf_ptr);
    473              usb_hal_khci_bdt_set_address( (uint32_t)bdt, ep_num, USB_SEND, state_ptr->ep_info[ep_num].tx_buf_odd, (uint32_t)buf_ptr);
    474              /* Program the number of bytes to be sent in BDT and Give
    475               * the onership to SEI
    476               */
    477              //BD_CTRL_TX(ep_num, state_ptr->ep_info[ep_num].tx_buf_odd) =
    478              //    USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(buf_num_bytes) |
    479              //        USB_BD_OWN | USB_BD_DTS | USB_BD_DATA01(state_ptr->ep_info[ep_num].tx_data0)));
    480              usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep_num, USB_SEND, state_ptr->ep_info[ep_num].tx_buf_odd,
    481                                           USB_LONG_LE_TO_HOST(USB_BD_BC(buf_num_bytes) | USB_BD_OWN | USB_BD_DTS | USB_BD_DATA01(state_ptr->ep_info[ep_num].tx_data0)));
   \   00000038   0x7A82             LDRB     R2,[R0, #+10]
   \   0000003A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000003C   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000040   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000044   0xEA41 0x01C2      ORR      R1,R1,R2, LSL #+3
   \   00000048   0x05A2             LSLS     R2,R4,#+22
   \   0000004A   0x0D92             LSRS     R2,R2,#+22
   \   0000004C   0x0180             LSLS     R0,R0,#+6
   \   0000004E   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000052   0xEA40 0x4002      ORR      R0,R0,R2, LSL #+16
   \   00000056   0xF040 0x0088      ORR      R0,R0,#0x88
   \   0000005A   0x.... 0x....      BL       ?Subroutine4
    482              
    483              usb_hal_khci_clr_token_busy(state_ptr->usbRegBase);
    484              return USB_OK;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
    485          }
    486              
    487          /**************************************************************************//*!
    488           *
    489           * @name  _usb_khci_reset_ep_state
    490           *
    491           * @brief This Function Resets all the parameters required for End Point
    492           *        Initialization
    493           *
    494           * @param state_ptr: Device info Structure.
    495           * @return USB_OK         When Successfull
    496           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    497          static usb_status _usb_khci_reset_ep_state
    498          (
    499               /*[IN]*/
    500              usb_khci_dev_state_struct_t* state_ptr
    501          )
    502          {
   \                     _usb_khci_reset_ep_state: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    503              //volatile USB_MemMapPtr usb_ptr;
    504              uint32_t  ep;
    505          
    506              uint8_t   interrupt_enable;
    507              
    508              /* Clear all the error Status registor */
    509              usb_hal_khci_clr_all_error_interrupts(state_ptr->usbRegBase);
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40072080
    510              
    511              /*Reset all ODD and Even BDTs to Zero */
    512              usb_hal_khci_set_oddrst(state_ptr->usbRegBase);
    513              
    514              /* Initialize the address as zero in the Address register of USB IP*/
    515              usb_hal_khci_set_device_addr(state_ptr->usbRegBase, 0);
    516              
    517              for (ep = 0; ep < USBCFG_DEV_MAX_ENDPOINTS; ep++)
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable20_2
   \   0000000A   0x22FF             MOVS     R2,#+255
   \   0000000C   0x720A             STRB     R2,[R1, #+8]
   \   0000000E   0x7D0B             LDRB     R3,[R1, #+20]
   \   00000010   0xF043 0x0302      ORR      R3,R3,#0x2
   \   00000014   0x750B             STRB     R3,[R1, #+20]
   \   00000016   0x7E0B             LDRB     R3,[R1, #+24]
   \   00000018   0xF003 0x0380      AND      R3,R3,#0x80
   \   0000001C   0x760B             STRB     R3,[R1, #+24]
   \   0000001E   0x2300             MOVS     R3,#+0
    518              {
    519                  /* Clearing all buffer descriptors for both ODD and even
    520                   * for Both Receive and Transmit direction
    521                   */
    522                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep, USB_RECV, 0, 0);
   \                     ??_usb_khci_reset_ep_state_0: (+1)
   \   00000020   0x6865             LDR      R5,[R4, #+4]
   \   00000022   0x0A6D             LSRS     R5,R5,#+9
   \   00000024   0x026D             LSLS     R5,R5,#+9
   \   00000026   0xF003 0x060F      AND      R6,R3,#0xF
   \   0000002A   0xEA45 0x1546      ORR      R5,R5,R6, LSL #+5
   \   0000002E   0x2600             MOVS     R6,#+0
    523                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep, USB_RECV, 1, 0);
   \   00000030   0xF045 0x0708      ORR      R7,R5,#0x8
   \   00000034   0x602E             STR      R6,[R5, #+0]
   \   00000036   0x603E             STR      R6,[R7, #+0]
    524                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep, USB_SEND, 0, 0);
   \   00000038   0xF045 0x0710      ORR      R7,R5,#0x10
    525                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep, USB_SEND, 1, 0);
   \   0000003C   0xF045 0x0518      ORR      R5,R5,#0x18
   \   00000040   0x603E             STR      R6,[R7, #+0]
   \   00000042   0x602E             STR      R6,[R5, #+0]
    526                  //BD_CTRL_RX(ep, EVEN_BUFF) = 0;
    527                  //BD_CTRL_RX(ep, ODD_BUFF) = 0;
    528          
    529                  //BD_CTRL_TX(ep, EVEN_BUFF) = 0;
    530                  //BD_CTRL_TX(ep, ODD_BUFF) = 0;
    531          
    532                  state_ptr->ep_info[ep].rx_buf_odd = EVEN_BUFF;
   \   00000044   0x2514             MOVS     R5,#+20
   \   00000046   0xFB05 0x0503      MLA      R5,R5,R3,R0
   \   0000004A   0x3542             ADDS     R5,R5,#+66
   \   0000004C   0x706E             STRB     R6,[R5, #+1]
    533                  state_ptr->ep_info[ep].tx_buf_odd = EVEN_BUFF;
   \   0000004E   0x702E             STRB     R6,[R5, #+0]
    534                  //state_ptr->ep_info[ep].data_buffer = NULL;
    535          #if 0        
    536                  if(ep == USB_CONTROL_ENDPOINT)
    537                  {
    538                      state_ptr->ep_info[ep].tx_buf_odd = ODD_BUFF;
    539                  }
    540          #endif
    541                  /* Initialize All End Point Control Registers with default value of 0*/
    542                  usb_hal_khci_endpoint_shut_down(state_ptr->usbRegBase,ep);
   \   00000050   0x2500             MOVS     R5,#+0
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable20  ;; 0x400720c0
   \   00000056   0xB2DF             UXTB     R7,R3
    543              }
   \   00000058   0x1C5B             ADDS     R3,R3,#+1
   \   0000005A   0xF806 0x5027      STRB     R5,[R6, R7, LSL #+2]
   \   0000005E   0x2B06             CMP      R3,#+6
   \   00000060   0xD3DE             BCC.N    ??_usb_khci_reset_ep_state_0
    544              
    545              g_zero_pkt_send = FALSE;
   \   00000062   0x7025             STRB     R5,[R4, #+0]
    546          
    547              /* Clear Reset Interrupt */
    548              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_USBRST);
   \   00000064   0x2301             MOVS     R3,#+1
   \   00000066   0x700B             STRB     R3,[R1, #+0]
    549              
    550              usb_hal_khci_clr_oddrst(state_ptr->usbRegBase);
    551              
    552              /* initializing device address to default  address
    553               * value for USB in Device strucutre.
    554               */
    555              state_ptr->device_address = 0;
   \   00000068   0x301C             ADDS     R0,R0,#+28
   \   0000006A   0x7D0B             LDRB     R3,[R1, #+20]
   \   0000006C   0xF003 0x03FD      AND      R3,R3,#0xFD
   \   00000070   0x750B             STRB     R3,[R1, #+20]
   \   00000072   0x73C5             STRB     R5,[R0, #+15]
    556          
    557              /* Set Default state of USB in Device Structure.*/
    558              state_ptr->usb_state = USB_STATE_DEFAULT;
   \   00000074   0x2302             MOVS     R3,#+2
   \   00000076   0x8003             STRH     R3,[R0, #+0]
    559          
    560              /* Set Default device status */
    561              state_ptr->usb_device_status = 
    562              (USBCFG_DEV_SELF_POWER << (USB_GET_STATUS_ATTRIBUTES_SELF_POWERED_SHIFT)) |
    563              (USBCFG_DEV_REMOTE_WAKEUP << (USB_GET_STATUS_ATTRIBUTES_REMOTE_WAKEUP_SHIFT));
   \   00000078   0x2301             MOVS     R3,#+1
   \   0000007A   0x8043             STRH     R3,[R0, #+2]
    564          
    565              /* Enable All Error Interrupts */
    566              usb_hal_khci_enable_all_error_interrupts(state_ptr->usbRegBase);
   \   0000007C   0x730A             STRB     R2,[R1, #+12]
    567          
    568              interrupt_enable = INTR_USBRST | INTR_SOFTOK | INTR_TOKDNE | INTR_STALL;
    569          
    570              /* Enable All Interrupts except RESUME */
    571          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME
    572              interrupt_enable |= INTR_SLEEP;
    573          #endif
    574          
    575          #if USBCFG_DEV_KHCI_ADVANCED_ERROR_HANDLING
    576              interrupt_enable |= INTR_ERROR;
    577          #endif
    578              usb_hal_khci_enable_interrupts(state_ptr->usbRegBase, interrupt_enable);
   \   0000007E   0x7908             LDRB     R0,[R1, #+4]
   \   00000080   0xF040 0x008D      ORR      R0,R0,#0x8D
   \   00000084   0x7108             STRB     R0,[R1, #+4]
    579              /* SEI if, has suspended packet trasmission resume packet transmission by
    580               * clearing TXD_SUSPEND in CTL register.
    581               */
    582              usb_hal_khci_clr_token_busy(state_ptr->usbRegBase);
   \   00000086   0x7D08             LDRB     R0,[R1, #+20]
   \   00000088   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   0000008C   0x7508             STRB     R0,[R1, #+20]
    583          
    584              return USB_OK;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBDF0             POP      {R4-R7,PC}       ;; return
    585          }
    586          
    587          #if 0
    588          /**************************************************************************//*!
    589           *
    590           * @name  _usb_khci_process_transmit_request
    591           *
    592           * @brief : Service TOKEN DONE Interrupt when there is transmission of packet.
    593           *
    594           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
    595           *                   same stracutre which was passed in function OS_install_isr
    596           *                   During ISR installation.
    597           * @param ep_num:    endpoint number
    598           * @param buffer_ptr:Holds Data that is send to Host.
    599           * @return USB_STATUS_TRANSFER_PENDING when there is split transaction or
    600           *                   USB_OK.
    601           *****************************************************************************/
    602          static usb_status _usb_khci_process_transmit_request
    603          (
    604               /*[IN]*/
    605              usb_khci_dev_state_struct_t* state_ptr, 
    606              /*[IN]*/
    607              uint8_t ep_num,
    608               /*[OUT]*/
    609              uint8_t** buffer_ptr
    610          )
    611          {
    612              xd_struct_t* xd_ptr = state_ptr->ep_info[ep_num].send_xd;
    613              
    614              //USB_XD_QUEUE_GET_HEAD(&state_ptr->ep_info[ep_num].xd_queue_send,&xd_ptr);
    615          
    616              //*buffer_ptr = (uint8_t *) USB_LONG_LE_TO_HOST(BD_ADDR_TX(ep_num,
    617              //    state_ptr->ep_info[ep_num].tx_buf_odd));
    618          
    619              //*buffer_ptr = (uint8_t *)USB_LONG_LE_TO_HOST(usb_hal_khci_bdt_get_address(usb_dev_ptr->usbRegBase, (uint32_t)bdt, ep_num, USB_SEND, state_ptr->ep_info[ep_num].tx_buf_odd));
    620          
    621              usb_dci_khci_send(state_ptr, xd_ptr);
    622          
    623              return USB_OK;
    624          }
    625          
    626          /**************************************************************************//*!
    627           *
    628           * @name  _usb_khci_process_receive_request
    629           *
    630           * @brief : Service TOKEN DONE Interrupt when there is receive packet scenario.
    631           *
    632           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
    633           *                   same stracutre which was passed in function
    634           *                   OS_install_isr during ISR installation.
    635           * @param ep_num:    endpoint number
    636           * @param stat:      status of last transaction.
    637           * @param buffer_ptr:buffer holding data received from Host.
    638           *
    639           * @return USB_STATUS_TRANSFER_PENDING when there is split transaction else
    640           *                   USB_OK
    641           *****************************************************************************/
    642          static usb_status _usb_khci_process_receive_request
    643          (
    644               /*[IN]*/
    645              usb_khci_dev_state_struct_t* state_ptr, 
    646              /*[IN]*/
    647              uint8_t ep_num, 
    648              /*[IN]*/
    649              uint8_t stat, 
    650               /*[OUT]*/
    651              uint8_t** buffer_ptr
    652          )
    653          {
    654              xd_struct_t* xd_ptr = state_ptr->ep_info[ep_num].recv_xd;
    655              
    656              //*buffer_ptr = (uint8_t *) USB_LONG_LE_TO_HOST(BD_ADDR_RX(ep_num,
    657              //    state_ptr->ep_info[ep_num].rx_buf_odd));
    658              //*buffer_ptr = (uint8_t *)USB_LONG_LE_TO_HOST(usb_hal_khci_bdt_get_address(usb_dev_ptr->usbRegBase, (uint32_t)bdt, ep_num, USB_RECV, state_ptr->ep_info[ep_num].rx_buf_odd));
    659              
    660              usb_dci_khci_recv(state_ptr, xd_ptr);
    661              return USB_OK;
    662          }
    663          #endif
    664          
    665          #if USBCFG_DEV_KHCI_ADVANCED_ERROR_HANDLING
    666          /**************************************************************************//*!
    667           *
    668           * @name  _usb_khci_service_err_intr
    669           *
    670           * @brief : Service Error Interrupt.
    671           *
    672           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
    673           *                   same stracutre which was passed in function OS_install_isr
    674           *                   During ISR installation.
    675           *
    676           * @return NONE
    677           *****************************************************************************/
    678          static void _usb_khci_service_err_intr
    679          (
    680               /*[IN]*/
    681              usb_khci_dev_state_struct_t* state_ptr 
    682          )
    683          {
    684              uint8_t device_error = 0, stat, ep_num;
    685              //volatile USB_MemMapPtr usb_ptr;
    686              usb_event_struct_t event;
    687          
    688              stat = usb_hal_khci_get_transfer_status(state_ptr->usbRegBase);
    689          
    690              /* Clear the Error Interrupt */
    691              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_ERROR);
    692              
    693              /* Get the Endpoint number on which the transaction occured.
    694               * This is (7 - 5) [3:0] bit in STAT register.
    695               */
    696              ep_num = usb_hal_khci_get_transfer_done_ep_number(state_ptr->usbRegBase);
    697              
    698              /* Read the ERRSTAT register to determine the source of the error
    699               * It is Andded with ERREN register to find out which of the
    700               * Error was enabled and report only the enabled error to the App layer
    701               */
    702              device_error = (uint8_t)(usb_hal_khci_get_error_interrupt_status(state_ptr->usbRegBase) &
    703                                       usb_hal_khci_get_error_interrupt_enable_status(state_ptr->usbRegBase));
    704              
    705              #ifdef _DEBUG
    706          //        USB_PRINTF("USB Err: 0x%x\n", device_error);
    707              #endif   
    708              
    709              /* Initialize the event strucutre to be passed to the upper layer*/
    710              event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
    711              event.ep_num = ep_num;
    712              event.setup = FALSE;
    713              event.direction = (bool)(stat >> 3 & 1);
    714              event.buffer_ptr = (uint8_t*)device_error;
    715              event.len = ZERO_LENGTH;
    716              
    717              /* Invoke Service Call */
    718              (void)_usb_device_call_service(USB_SERVICE_ERROR,&event);
    719              
    720              /*clear all errors*/
    721              usb_hal_khci_clr_all_error_interrupts(state_ptr->usbRegBase); 
    722          }
    723          #endif
    724          
    725          /**************************************************************************//*!
    726           *
    727           * @name  _usb_khci_service_reset_intr
    728           *
    729           * @brief : Service reset Interrupt.
    730           *
    731           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
    732           *                   same stracutre which was passed in function OS_install_isr
    733           *                   During ISR installation.
    734           *
    735           * @return NONE
    736           *****************************************************************************/
    737          static void _usb_khci_service_reset_intr
    738          (
    739               /*[IN]*/
    740              usb_khci_dev_state_struct_t* state_ptr 
    741          )
    742          {
    743              uint8_t ep_num;
    744              //volatile USB_MemMapPtr usb_ptr;
    745              usb_event_struct_t event;
    746              
    747              /* Clear Reset Interrupt */
    748              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_USBRST);
    749              
    750              /* Get the Endpoint number on which the transaction occured.
    751               * This is (7 - 5) [3:0] bit in STAT register.
    752               */
    753              ep_num = usb_hal_khci_get_transfer_done_ep_number(state_ptr->usbRegBase);
    754          
    755              /* Initialize the event strucutre to be passed to the upper layer*/
    756              event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
    757              event.ep_num = ep_num;
    758              event.setup = FALSE;
    759              event.direction = USB_RECV;
    760              event.buffer_ptr = (uint8_t*)NULL;
    761              event.len = ZERO_LENGTH;
    762              /* Inform Upper Layer of Reset Signal.
    763               * Remember Upper layer i.e class driver invokes
    764               * usb_dci_khci_init_endpoint() as part of reset callback
    765               */
    766              (void)_usb_device_call_service(USB_SERVICE_BUS_RESET,&event);
    767          }
    768          
    769          /**************************************************************************//*!
    770           *
    771           * @name  _usb_khci_service_tk_dne_intr
    772           *
    773           * @brief : Service Error Interrupt.
    774           *
    775           * @param state_ptr: Device Structure Pointer Passed to ISR. It is the same
    776           *                   stracutre which was passed in function OS_install_isr
    777           *                   During ISR installation.
    778           *
    779           * @return NONE
    780           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    781          static void _usb_khci_service_tk_dne_intr
    782          (
    783               /*[IN]*/
    784              usb_khci_dev_state_struct_t* state_ptr
    785          )
    786          {
   \                     _usb_khci_service_tk_dne_intr: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    787              uint8_t ep_num,stat,dir,buf_odd,setup,token_pid;
    788              uint32_t len = 0;
    789              //usb_status error;
    790              uint32_t buf_num_bytes;
    791              //volatile USB_MemMapPtr usb_ptr;
    792              xd_struct_t* xd_ptr;
    793          //    uint8_t * buffer_ptr = NULL;
    794              uint32_t control = 0;
    795          #if USBCFG_KHCI_4BYTE_ALIGN_FIX
    796              uint8_t *src, *dst = NULL;
    797          #endif
    798              usb_event_struct_t event;
    799          
    800                /* Get the status of previous transaction*/
    801              stat = usb_hal_khci_get_transfer_status(state_ptr->usbRegBase);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable20_4  ;; 0x40072080
   \   00000008   0xB088             SUB      SP,SP,#+32
   \   0000000A   0x4681             MOV      R9,R0
   \   0000000C   0x7C28             LDRB     R0,[R5, #+16]
    802          
    803          
    804              /* Get the Endpoint number on which the transaction occured.
    805               * This is (7 - 5) [3:0] bit in STAT register.
    806               */
    807              ep_num = usb_hal_khci_get_transfer_done_ep_number(state_ptr->usbRegBase);
    808              if( (ep_num == 1) || (ep_num == 2))
    809              {
    810                dir = usb_hal_khci_get_transfer_done_direction(state_ptr->usbRegBase);
    811              }
    812          
    813              /* Get the Direction of transaction. (i.e the transaction was a receive
    814               * operation or transaction was a Transmit operation).It is Bit [3] in STAT
    815               * register.
    816               */
    817              dir = usb_hal_khci_get_transfer_done_direction(state_ptr->usbRegBase);
    818          
    819              /* Get the last buffer transaction was in ODD buffer or Even Buffer*/
    820              buf_odd = usb_hal_khci_get_transfer_done_odd(state_ptr->usbRegBase);
    821          
    822          
    823              /* Clear TOKEN  Done Interrupt. This clearing of TOKEN_DONE
    824               * should happen after STAT register is read. This is becouse
    825               * STAT register has four byte fifo and if TOKEN_DONE is cleared
    826               * in INT_STAT then the content of STAT register is updated with
    827               * the next value in the STAT fifo.
    828               */
    829              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_TOKDNE);
    830          
    831              control = usb_hal_khci_bdt_get_control( (uint32_t)bdt, ep_num, dir, buf_odd);
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable20_2
   \   00000012   0xF88D 0x001C      STRB     R0,[SP, #+28]
   \   00000016   0x7C28             LDRB     R0,[R5, #+16]
   \   00000018   0x0900             LSRS     R0,R0,#+4
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xBF14             ITE      NE 
   \   00000020   0x2802             CMPNE    R0,#+2
   \   00000022   0x7C28             LDRBEQ   R0,[R5, #+16]
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x7C28             LDRB     R0,[R5, #+16]
   \   00000028   0x7C2A             LDRB     R2,[R5, #+16]
   \   0000002A   0x7029             STRB     R1,[R5, #+0]
   \   0000002C   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000030   0x6871             LDR      R1,[R6, #+4]
   \   00000032   0x9B00             LDR      R3,[SP, #+0]
   \   00000034   0x0A49             LSRS     R1,R1,#+9
   \   00000036   0x0249             LSLS     R1,R1,#+9
   \   00000038   0xEA41 0x1143      ORR      R1,R1,R3, LSL #+5
   \   0000003C   0xEA41 0x1300      ORR      R3,R1,R0, LSL #+4
   \   00000040   0xF3C2 0x0280      UBFX     R2,R2,#+2,#+1
   \   00000044   0xEA43 0x02C2      ORR      R2,R3,R2, LSL #+3
   \   00000048   0x6812             LDR      R2,[R2, #+0]
    832              
    833              /* Get length of Data transmited or recevied in the last transaction. */
    834              len = (USB_HOST_TO_LE_LONG(control) >> 16) & 0x3ff;
   \   0000004A   0xF3C2 0x4A09      UBFX     R10,R2,#+16,#+10
    835          
    836              /* Get PID for this token */
    837              token_pid = (uint8_t)((USB_HOST_TO_LE_LONG(control) >> 2) & 0x0000000f);
   \   0000004E   0xF3C2 0x0283      UBFX     R2,R2,#+2,#+4
   \   00000052   0x9202             STR      R2,[SP, #+8]
    838          
    839              /* if token PID is a setup token */
    840              setup = (token_pid == USB_SETUP_TOKEN) ? TRUE : FALSE;
   \   00000054   0x2A0D             CMP      R2,#+13
   \   00000056   0xBF0C             ITE      EQ 
   \   00000058   0xF04F 0x0801      MOVEQ    R8,#+1
   \   0000005C   0xF04F 0x0800      MOVNE    R8,#+0
    841          
    842              //USB_PRINTF("23tk_dne ep %d dir %d len %d buff_odd %d\n", ep_num, dir, len, buf_odd);
    843              if(dir)
   \   00000060   0x9A00             LDR      R2,[SP, #+0]
   \   00000062   0x2314             MOVS     R3,#+20
   \   00000064   0xFB03 0x9202      MLA      R2,R3,R2,R9
   \   00000068   0xF102 0x0430      ADD      R4,R2,#+48
   \   0000006C   0x9A00             LDR      R2,[SP, #+0]
   \   0000006E   0xEA4A 0x0202      ORR      R2,R10,R2
   \   00000072   0x9201             STR      R2,[SP, #+4]
   \   00000074   0xB370             CBZ.N    R0,??_usb_khci_service_tk_dne_intr_0
    844              {
    845                  /* direction is USB_SEND*/
    846                  /* Get head of the send queue */
    847                  //USB_XD_QUEUE_GET_HEAD(&state_ptr->ep_info[ep_num].xd_queue_send,&xd_ptr);
    848                  //USB_PRINTF("get send xd_ptr 0x%x\n", xd_ptr);
    849                  /* updating the WSOFAR field */
    850                  xd_ptr = state_ptr->ep_info[ep_num].send_xd;
   \   00000076   0x6827             LDR      R7,[R4, #+0]
    851                  if(xd_ptr == NULL)
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD025             BEQ.N    ??_usb_khci_service_tk_dne_intr_1
    852                  {
    853                      return;
    854                  }
    855                  xd_ptr->wsofar += len;
   \   0000007C   0x68F8             LDR      R0,[R7, #+12]
   \   0000007E   0x4450             ADD      R0,R10,R0
   \   00000080   0x60F8             STR      R0,[R7, #+12]
    856          
    857                  buf_num_bytes = (uint32_t)(xd_ptr->wtotallength - xd_ptr->wsofar);
   \   00000082   0x68B9             LDR      R1,[R7, #+8]
   \   00000084   0x1A09             SUBS     R1,R1,R0
    858                  
    859                  /* dequeue if all bytes have been send or the last send transaction was
    860                     of length less then the max packet size length configured for
    861                     corresponding endpoint */
    862                  state_ptr->ep_info[ep_num].tx_buf_odd ^= 1;
   \   00000086   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000088   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000008C   0x74A0             STRB     R0,[R4, #+18]
    863                  state_ptr->ep_info[ep_num].tx_data0 ^= 1;
   \   0000008E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000090   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000094   0x7420             STRB     R0,[R4, #+16]
    864                  if ((buf_num_bytes == 0) || (state_ptr->ep_info[ep_num].max_packet_size > len))
   \   00000096   0xD002             BEQ.N    ??_usb_khci_service_tk_dne_intr_2
   \   00000098   0x8920             LDRH     R0,[R4, #+8]
   \   0000009A   0x4582             CMP      R10,R0
   \   0000009C   0xD215             BCS.N    ??_usb_khci_service_tk_dne_intr_3
    865                  {
    866                      event.len = xd_ptr->wsofar;
   \                     ??_usb_khci_service_tk_dne_intr_2: (+1)
   \   0000009E   0x.... 0x....      BL       ?Subroutine5
    867                      /* buffer address is updated for upper layer */
    868                      event.buffer_ptr = xd_ptr->wstartaddress; 
    869                      state_ptr->ep_info[ep_num].send_xd = NULL;  
    870                      usb_dci_khci_free_xd(state_ptr, xd_ptr);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   000000A2   0x6020             STR      R0,[R4, #+0]
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x.... 0x....      BL       usb_dci_khci_free_xd
    871                      if ((len == state_ptr->ep_info[ep_num].max_packet_size) && 
    872                          (ep_num == USB_CONTROL_ENDPOINT))
   \   000000AA   0x8920             LDRH     R0,[R4, #+8]
   \   000000AC   0x4582             CMP      R10,R0
   \   000000AE   0xBF04             ITT      EQ 
   \   000000B0   0x9800             LDREQ    R0,[SP, #+0]
   \   000000B2   0x2800             CMPEQ    R0,#+0
   \   000000B4   0xD15E             BNE.N    ??_usb_khci_service_tk_dne_intr_4
    873                      {
    874                          g_zero_pkt_send = TRUE;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x7030             STRB     R0,[R6, #+0]
    875                          usb_device_send_data((usb_device_handle)state_ptr->upper_layer_handle, ep_num, NULL, 0);
   \   000000BA   0x2300             MOVS     R3,#+0
   \   000000BC   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x.... 0x....      BL       usb_device_send_data
    876                          return;
   \                     ??_usb_khci_service_tk_dne_intr_1: (+1)
   \   000000C8   0xE074             B.N      ??_usb_khci_service_tk_dne_intr_5
    877                      }
    878                  }
    879                  else
    880                  {
    881                      usb_dci_khci_send(state_ptr, xd_ptr);
   \                     ??_usb_khci_service_tk_dne_intr_3: (+1)
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x4648             MOV      R0,R9
   \   000000CE   0x.... 0x....      BL       usb_dci_khci_send
    882                      //_usb_khci_process_transmit_request(state_ptr, ep_num, &buffer_ptr);
    883                      return;/*if above call returned USB_STATUS_TRANSFER_PENDING */ 
   \   000000D2   0xE06F             B.N      ??_usb_khci_service_tk_dne_intr_5
    884                  }
    885              }
    886              else
    887              {
    888                  
    889                  if((ep_num == USB_CONTROL_ENDPOINT) && (!len))
   \                     ??_usb_khci_service_tk_dne_intr_0: (+1)
   \   000000D4   0x9801             LDR      R0,[SP, #+4]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD054             BEQ.N    ??_usb_khci_service_tk_dne_intr_6
    890                  {
    891                          goto callservice; // call up layer service function
    892                  }
    893                  /* direction is USB_RECV*/
    894                  if(g_zero_pkt_send == TRUE)
   \   000000DA   0x7830             LDRB     R0,[R6, #+0]
   \   000000DC   0xB108             CBZ.N    R0,??_usb_khci_service_tk_dne_intr_7
    895                  {
    896                      g_zero_pkt_send = FALSE;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x7030             STRB     R0,[R6, #+0]
    897                  }
    898                  //USB_PRINTF("before ep %d : xd_head_ptr 0x%x xd_tail_ptr 0x%x\n", ep_num, 
    899                  //        state_ptr->EP_INFO[ep_num].xd_queue_recv.xd_head_ptr,
    900                  //        state_ptr->EP_INFO[ep_num].xd_queue_recv.xd_tail_ptr);
    901                  /* Get head of the send queue */
    902                  //USB_XD_QUEUE_GET_HEAD(&state_ptr->ep_info[ep_num].xd_queue_recv, &xd_ptr);
    903                  xd_ptr = state_ptr->ep_info[ep_num].recv_xd;
   \                     ??_usb_khci_service_tk_dne_intr_7: (+1)
   \   000000E2   0x6867             LDR      R7,[R4, #+4]
    904                  if(xd_ptr == NULL)
   \   000000E4   0x2F00             CMP      R7,#+0
   \   000000E6   0xD065             BEQ.N    ??_usb_khci_service_tk_dne_intr_5
    905                  {
    906                      return;
    907                  }
    908          #if USBCFG_KHCI_4BYTE_ALIGN_FIX
    909                  if (!xd_ptr->internal_dma_align)
   \   000000E8   0x7DF8             LDRB     R0,[R7, #+23]
   \   000000EA   0xB968             CBNZ.N   R0,??_usb_khci_service_tk_dne_intr_8
    910                  {
    911                      //src = (uint8_t *)USB_LONG_LE_TO_HOST(BD_ADDR_RX(ep_num, state_ptr->ep_info[ep_num].rx_buf_odd));
    912                      src = (uint8_t*)USB_LONG_LE_TO_HOST(usb_hal_khci_bdt_get_address( (uint32_t)bdt, ep_num, USB_RECV, state_ptr->ep_info[ep_num].rx_buf_odd));
   \   000000EC   0x7CE0             LDRB     R0,[R4, #+19]
    913                      dst = xd_ptr->wstartaddress + xd_ptr->wsofar;
   \   000000EE   0x68FA             LDR      R2,[R7, #+12]
   \   000000F0   0xF000 0x0001      AND      R0,R0,#0x1
   \   000000F4   0xEA41 0x00C0      ORR      R0,R1,R0, LSL #+3
   \   000000F8   0x6841             LDR      R1,[R0, #+4]
   \   000000FA   0x6878             LDR      R0,[R7, #+4]
   \   000000FC   0x1810             ADDS     R0,R2,R0
    914                      if (src != dst)
   \   000000FE   0x4281             CMP      R1,R0
   \   00000100   0xBF1C             ITT      NE 
    915                      {
    916                          OS_Mem_copy(src, dst, len);
   \   00000102   0x4652             MOVNE    R2,R10
   \   00000104   0x.... 0x....      BLNE     memcpy
    917                      }
    918                  }
    919          #endif
    920                  xd_ptr->wsofar += len;/* updating the WSOFAR field */
   \                     ??_usb_khci_service_tk_dne_intr_8: (+1)
   \   00000108   0x68F8             LDR      R0,[R7, #+12]
   \   0000010A   0x4450             ADD      R0,R10,R0
   \   0000010C   0x60F8             STR      R0,[R7, #+12]
    921                  
    922                  buf_num_bytes = (uint32_t)(xd_ptr->wtotallength - xd_ptr->wsofar);
   \   0000010E   0x68B9             LDR      R1,[R7, #+8]
   \   00000110   0x1A0E             SUBS     R6,R1,R0
    923          
    924                  if ((ep_num == USB_CONTROL_ENDPOINT) && (token_pid == USB_SETUP_TOKEN))
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xBF04             ITT      EQ 
   \   00000118   0x9802             LDREQ    R0,[SP, #+8]
   \   0000011A   0x280D             CMPEQ    R0,#+13
   \   0000011C   0xD10E             BNE.N    ??_usb_khci_service_tk_dne_intr_9
    925                  {
    926                      /* cancel any pending transfers in SEND QUEUE if present*/
    927                      usb_dci_khci_cancel((usb_device_handle)state_ptr, ep_num, USB_SEND);
   \   0000011E   0x2201             MOVS     R2,#+1
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x4648             MOV      R0,R9
   \   00000124   0x.... 0x....      BL       usb_dci_khci_cancel
    928                      /* for first In/OUT after setup token DATA PID has to be always one */
    929                      state_ptr->ep_info[ep_num].tx_data0 = 1;
   \   00000128   0xF109 0x0040      ADD      R0,R9,#+64
   \   0000012C   0x2101             MOVS     R1,#+1
   \   0000012E   0x7001             STRB     R1,[R0, #+0]
    930                      state_ptr->ep_info[ep_num].rx_data0 = 1;
   \   00000130   0x7041             STRB     R1,[R0, #+1]
    931                      state_ptr->ep_info[ep_num].rx_buf_odd ^= 1;
   \   00000132   0x78C1             LDRB     R1,[R0, #+3]
   \   00000134   0xF081 0x0101      EOR      R1,R1,#0x1
   \   00000138   0x70C1             STRB     R1,[R0, #+3]
   \   0000013A   0xE007             B.N      ??_usb_khci_service_tk_dne_intr_10
    932                      //state_ptr->ep_info[ep_num].tx_buf_odd ^= 1;
    933                  }
    934                  else
    935                  {
    936                      /* set DATA PID and buffer for next recv transaction */
    937                      state_ptr->ep_info[ep_num].rx_data0 ^= 1;
   \                     ??_usb_khci_service_tk_dne_intr_9: (+1)
   \   0000013C   0x7C60             LDRB     R0,[R4, #+17]
   \   0000013E   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000142   0x7460             STRB     R0,[R4, #+17]
    938                      state_ptr->ep_info[ep_num].rx_buf_odd ^= 1;
   \   00000144   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000146   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000014A   0x74E0             STRB     R0,[R4, #+19]
    939                  }
    940          
    941                  //USB_PRINTF("max packet size %d\n",state_ptr->EP_INFO[ep_num].max_packet_size);
    942                  /* dequeue if all bytes have been received or the last send transaction
    943                     was of length less then the max packet size length configured for
    944                     corresponding endpoint */
    945                  if ((!xd_ptr->wtotallength)||(buf_num_bytes == 0)||
    946                     (state_ptr->ep_info[ep_num].max_packet_size > len))
   \                     ??_usb_khci_service_tk_dne_intr_10: (+1)
   \   0000014C   0x68B8             LDR      R0,[R7, #+8]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xBF18             IT       NE 
   \   00000152   0x2E00             CMPNE    R6,#+0
   \   00000154   0xD002             BEQ.N    ??_usb_khci_service_tk_dne_intr_11
   \   00000156   0x8920             LDRH     R0,[R4, #+8]
   \   00000158   0x4582             CMP      R10,R0
   \   0000015A   0xD206             BCS.N    ??_usb_khci_service_tk_dne_intr_12
    947                  {
    948                      event.len = xd_ptr->wsofar;
   \                     ??_usb_khci_service_tk_dne_intr_11: (+1)
   \   0000015C   0x.... 0x....      BL       ?Subroutine5
    949                      /* buffer address is updated for upper layer */
    950                      event.buffer_ptr = xd_ptr->wstartaddress;
    951                      state_ptr->ep_info[ep_num].recv_xd = NULL;  
    952                      usb_dci_khci_free_xd(state_ptr, xd_ptr);
    953                  }
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000160   0x6060             STR      R0,[R4, #+4]
   \   00000162   0x4648             MOV      R0,R9
   \   00000164   0x.... 0x....      BL       usb_dci_khci_free_xd
   \   00000168   0xE00C             B.N      ??_usb_khci_service_tk_dne_intr_6
    954                  else
    955                  {
    956                      usb_dci_khci_recv(state_ptr, xd_ptr);
   \                     ??_usb_khci_service_tk_dne_intr_12: (+1)
   \   0000016A   0x4639             MOV      R1,R7
   \   0000016C   0x4648             MOV      R0,R9
   \   0000016E   0x.... 0x....      BL       usb_dci_khci_recv
    957                      //_usb_khci_process_receive_request(state_ptr,ep_num, stat, &buffer_ptr);
    958                      return;/*if above call returned USB_STATUS_TRANSFER_PENDING */  
   \   00000172   0xE01F             B.N      ??_usb_khci_service_tk_dne_intr_5
    959                  }
    960              }
    961          
    962              /* prepare for next setup token if needed*/
    963              if ((ep_num == USB_CONTROL_ENDPOINT) && (!len) && (g_zero_pkt_send ==FALSE))
   \                     ??_usb_khci_service_tk_dne_intr_4: (+1)
   \   00000174   0x9801             LDR      R0,[SP, #+4]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xBF01             ITTTT    EQ 
   \   0000017A   0x7830             LDRBEQ   R0,[R6, #+0]
   \   0000017C   0x2800             CMPEQ    R0,#+0
    964              {
    965                  _usb_khci_next_setup_token_prep(state_ptr);
   \   0000017E   0x4648             MOVEQ    R0,R9
   \   00000180   0x.... 0x....      BLEQ     _usb_khci_next_setup_token_prep
    966              }
    967          callservice:    
    968              /* Initialize the event strucutre to be passed to the upper layer*/
    969              event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
   \                     ??_usb_khci_service_tk_dne_intr_6: (+1)
   \   00000184   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000188   0x9003             STR      R0,[SP, #+12]
    970              event.ep_num = ep_num;
    971              event.setup = setup;
   \   0000018A   0xF88D 0x801A      STRB     R8,[SP, #+26]
    972              event.direction = (bool)(stat >> 3 & 1);
    973           
    974              /* propagate control to upper layers for processing */
    975              _usb_device_call_service(ep_num,&event);
   \   0000018E   0xA903             ADD      R1,SP,#+12
   \   00000190   0x9800             LDR      R0,[SP, #+0]
   \   00000192   0xF88D 0x0018      STRB     R0,[SP, #+24]
   \   00000196   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   0000019A   0x08C0             LSRS     R0,R0,#+3
   \   0000019C   0xF000 0x0001      AND      R0,R0,#0x1
   \   000001A0   0xF88D 0x001B      STRB     R0,[SP, #+27]
   \   000001A4   0x9800             LDR      R0,[SP, #+0]
   \   000001A6   0xB2C0             UXTB     R0,R0
   \   000001A8   0x.... 0x....      BL       _usb_device_call_service
    976          
    977              //USB_PRINTF("_usb_khci_service_tk_dne_intr 3-- :%d \n",ep_num);
    978              
    979              usb_hal_khci_clr_token_busy(state_ptr->usbRegBase);
   \   000001AC   0x7D28             LDRB     R0,[R5, #+20]
   \   000001AE   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   000001B2   0x7528             STRB     R0,[R5, #+20]
    980              
    981           }
   \                     ??_usb_khci_service_tk_dne_intr_5: (+1)
   \   000001B4   0xB008             ADD      SP,SP,#+32
   \   000001B6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x68F8             LDR      R0,[R7, #+12]
   \   00000002   0x9005             STR      R0,[SP, #+20]
   \   00000004   0x4639             MOV      R1,R7
   \   00000006   0x6878             LDR      R0,[R7, #+4]
   \   00000008   0x9004             STR      R0,[SP, #+16]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    982          
    983          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME
    984          /**************************************************************************//*!
    985           *
    986           * @name  _usb_khci_service_sleep_intr
    987           *
    988           * @brief : Service Sleep Interrupt.
    989           *
    990           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
    991           *                   same stracutre which was passed in function OS_install_isr
    992           *                   During ISR installation.
    993           *
    994           * @return NONE
    995           *****************************************************************************/
    996          static void _usb_khci_service_sleep_intr
    997          (
    998               /*[IN]*/
    999              usb_khci_dev_state_struct_t* state_ptr
   1000          )
   1001          {
   1002              //volatile USB_MemMapPtr usb_ptr;
   1003              usb_event_struct_t event;
   1004          
   1005              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_RESUME);
   1006              
   1007              /* clear suspend interrupt */
   1008              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_SLEEP);
   1009          
   1010              state_ptr->usb_dev_state_b4_suspend = state_ptr->usb_state;
   1011          
   1012              state_ptr->usb_state = USB_STATE_SUSPEND;
   1013              
   1014              /* Initialize the event strucutre to be passed to the upper layer*/
   1015              event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
   1016              event.ep_num = (uint8_t)USB_UNINITIALIZED_VAL_32;
   1017              event.setup = 0;
   1018              event.direction = 0;
   1019              event.buffer_ptr = (uint8_t*)NULL;
   1020              event.len = ZERO_LENGTH;
   1021          
   1022              /* Notify Device Layer of SLEEP Event */
   1023              /* this callback need only handle and type -
   1024                 all other arguments are redundant */
   1025              (void)_usb_device_call_service(USB_SERVICE_SUSPEND, &event);
   1026              
   1027              /* Enable RESUME Interrupt */
   1028              usb_hal_khci_enable_interrupts(state_ptr->usbRegBase, (INTR_RESUME));
   1029          }
   1030          
   1031          /************************************************************************//*!
   1032           *
   1033           * @name  _usb_khci_service_resume_intr
   1034           *
   1035           * @brief : Service resume Interrupt.
   1036           *
   1037           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
   1038           *                   same stracutre which was passed in function OS_install_isr
   1039           *                   During ISR installation.
   1040           *
   1041           * @return NONE
   1042           *****************************************************************************/
   1043          static void _usb_khci_service_resume_intr
   1044          (
   1045               /*[IN]*/
   1046              usb_khci_dev_state_struct_t* state_ptr
   1047          )
   1048          {
   1049              usb_event_struct_t event;  
   1050          
   1051              /* clear resume interrupt status bit */
   1052              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_RESUME);
   1053          
   1054              state_ptr->usb_state = state_ptr->usb_dev_state_b4_suspend;
   1055          
   1056              /* Initialize the event strucutre to be passed to the upper layer*/
   1057              event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
   1058              event.ep_num = (uint8_t)USB_UNINITIALIZED_VAL_32;
   1059              event.setup = 0;
   1060              event.direction = 0;
   1061              event.buffer_ptr = (uint8_t*)NULL;
   1062              event.len = ZERO_LENGTH;
   1063              
   1064              /* Notify Device Layer of RESUME Event */
   1065              /* this callback need only handle and type -
   1066                 all other arguments are redundant */
   1067              (void)_usb_device_call_service(USB_SERVICE_RESUME,&event);
   1068              
   1069              /* Disable RESUME Interrupt */
   1070              usb_hal_khci_disable_interrupts(state_ptr->usbRegBase, INTR_RESUME);
   1071          }
   1072          #endif
   1073          /***********************************************************************//*!
   1074           *
   1075           * @name  _usb_khci_service_sof_token_intr
   1076           *
   1077           * @brief : Service SOF Interrupt.
   1078           *
   1079           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
   1080           *                   same stracutre which was passed in function OS_install_isr
   1081           *                   During ISR installation.
   1082           *
   1083           * @return NONE
   1084           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1085          static void _usb_khci_service_sof_token_intr
   1086          (
   1087               /*[IN]*/
   1088              usb_khci_dev_state_struct_t* state_ptr
   1089          )
   1090          {
   1091              /* Clear SOF Interrupt */
   1092              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_SOFTOK);
   \                     _usb_khci_service_sof_token_intr: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40072080
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x700A             STRB     R2,[R1, #+0]
   1093              
   1094              state_ptr->usb_sof_count = usb_hal_khci_get_frame_number(state_ptr->usbRegBase);
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable20_5  ;; 0x400720a0
   \   0000000C   0x7913             LDRB     R3,[R2, #+4]
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000014   0x8402             STRH     R2,[R0, #+32]
   1095              
   1096              /* address of Lower byte of Frame number.
   1097               */
   1098              //buffer_ptr = (uint8_t *)&(state_ptr->USB_SOF_COUNT);
   1099                  
   1100              /* clear resume interrupt status bit */
   1101              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_RESUME);
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   1102          }
   \   0000001A   0x4770             BX       LR               ;; return
   1103          
   1104          #if 0
   1105          /**************************************************************************//*!
   1106           *
   1107           * @name  _usb_khci_service_attach_intr
   1108           *
   1109           * @brief : Service attach Interrupt.
   1110           *
   1111           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
   1112           *                   same stracutre which was passed in function OS_install_isr
   1113           *                   During ISR installation.
   1114           *
   1115           * @return NONE
   1116           *****************************************************************************/
   1117          static void _usb_khci_service_attach_intr
   1118          (
   1119               /*[IN]*/
   1120              usb_khci_dev_state_struct_t* state_ptr 
   1121          )
   1122          {
   1123              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_ATTACH);
   1124          }
   1125          #endif
   1126          
   1127          /************************************************************************//*!
   1128           *
   1129           * @name  _usb_khci_service_stall_intr
   1130           *
   1131           * @brief : Service stall Interrupt.
   1132           *
   1133           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
   1134           *                   same stracutre which was passed in function OS_install_isr
   1135           *                   During ISR installation.
   1136           *
   1137           * @return NONE
   1138           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1139          static void _usb_khci_service_stall_intr
   1140          (
   1141               /*[IN]*/
   1142              usb_khci_dev_state_struct_t* state_ptr 
   1143          )
   1144          {
   \                     _usb_khci_service_stall_intr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1145          
   1146          	uint8_t ep;
   1147          
   1148          	for (ep = 0; ep < USBCFG_DEV_MAX_ENDPOINTS; ep++)
   \   00000004   0x2500             MOVS     R5,#+0
   1149          	{
   1150          		if (state_ptr->ep_info[ep].endpoint_status == USB_STATUS_STALLED)
   \                     ??_usb_khci_service_stall_intr_0: (+1)
   \   00000006   0x2014             MOVS     R0,#+20
   \   00000008   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000000C   0xF100 0x0638      ADD      R6,R0,#+56
   \   00000010   0x78B0             LDRB     R0,[R6, #+2]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD122             BNE.N    ??CrossCallReturnLabel_10
   1151          		{
   1152          			usb_hal_khci_endpoint_clr_stall(state_ptr->usbRegBase, ep);
   \   00000016   0xF8D4 0x00AC      LDR      R0,[R4, #+172]
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x.... 0x....      BL       usb_hal_khci_endpoint_clr_stall
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000024   0x8832             LDRH     R2,[R6, #+0]
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x0A40             LSRS     R0,R0,#+9
   \   0000002A   0x0240             LSLS     R0,R0,#+9
   \   0000002C   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000030   0xEA40 0x1041      ORR      R0,R0,R1, LSL #+5
   \   00000034   0x7AB1             LDRB     R1,[R6, #+10]
   \   00000036   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000003A   0xEA40 0x01C1      ORR      R1,R0,R1, LSL #+3
   \   0000003E   0x0592             LSLS     R2,R2,#+22
   \   00000040   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000044   0x0992             LSRS     R2,R2,#+6
   \   00000046   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000004A   0x600A             STR      R2,[R1, #+0]
   1153          			usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep, USB_SEND, state_ptr->ep_info[ep].tx_buf_odd,
   1154          							 USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep].max_packet_size)| USB_BD_DTS | USB_BD_DATA01(0))));
   1155          			usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep, USB_RECV, state_ptr->ep_info[ep].rx_buf_odd,
   1156          							 USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep].max_packet_size)| USB_BD_DTS | USB_BD_DATA01(0))));
   \   0000004C   0x7AF1             LDRB     R1,[R6, #+11]
   \   0000004E   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000052   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \   00000056   0x8831             LDRH     R1,[R6, #+0]
   \   00000058   0x.... 0x....      BL       ?Subroutine6
   1157          		}
   1158          	}
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \   0000005E   0x2D06             CMP      R5,#+6
   \   00000060   0xDBD1             BLT.N    ??_usb_khci_service_stall_intr_0
   1159               
   1160          	/* Clear Stall Interrupt */
   1161              usb_hal_khci_clr_interrupt(state_ptr->usbRegBase, INTR_STALL);
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40072080
   \   00000066   0x2080             MOVS     R0,#+128
   \   00000068   0x7008             STRB     R0,[R1, #+0]
   1162          
   1163              /* check if the stall interrupt received was for CONTROL ENDPOINT */
   1164              if (state_ptr->ep_info[USB_CONTROL_ENDPOINT].endpoint_status == USB_STATUS_STALLED)
   \   0000006A   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD106             BNE.N    ??_usb_khci_service_stall_intr_1
   1165              {
   1166                  state_ptr->ep_info[USB_CONTROL_ENDPOINT].endpoint_status = USB_STATUS_IDLE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF884 0x003A      STRB     R0,[R4, #+58]
   1167                  _usb_khci_next_setup_token_prep(state_ptr);
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007E   0x....             B.N      _usb_khci_next_setup_token_prep
   1168              }
   1169              
   1170          }
   \                     ??_usb_khci_service_stall_intr_1: (+1)
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x0589             LSLS     R1,R1,#+22
   \   00000002   0x0989             LSRS     R1,R1,#+6
   \   00000004   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x4770             BX       LR
   1171          
   1172          /**************************************************************************//*!
   1173           *
   1174           * @name  _usb_khci_isr
   1175           *
   1176           * @brief : Service all the interrupts in the kirin usb hardware
   1177           *
   1178           * @param state_ptr: Device Structure Pointer Passed to ISR. The is the
   1179           *                   same stracutre which was passed in function OS_install_isr
   1180           *                   During ISR installation.
   1181           *
   1182           * @return NONE
   1183           *****************************************************************************/
   1184          #ifdef USBCFG_OTG 
   1185          void _usb_dev_khci_isr
   1186          (
   1187              usb_khci_dev_state_struct_t* state_ptr
   1188          )
   1189          {
   1190                  state_ptr = (usb_khci_dev_state_struct_t*)(&g_khci_dev[0]);
   1191          #else
   1192          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)
   1193          static void _usb_khci_isr()
   1194          {
   1195              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)(&g_khci_dev[0]);
   1196          #else

   \                                 In section .text, align 2, keep-with-next
   1197          static void _usb_khci_isr(usb_khci_dev_state_struct_t* state_ptr)
   1198          {
   \                     _usb_khci_isr: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1199              state_ptr = (usb_khci_dev_state_struct_t*)(&g_khci_dev[0]);
   1200          #endif
   1201          #endif
   1202              /* Get the USB IP base address in the controller */
   1203              //error = (uint8_t)usb_hal_get_interrupt_status(state_ptr->usbRegBase);
   1204          
   1205              /* This interrupt comes when any of the error conditions within
   1206               * the ERRSTAT register occur. The ColdFire core must
   1207               * then read the ERRSTAT register to determine the source of the error.
   1208               */
   1209          #if USBCFG_DEV_KHCI_ADVANCED_ERROR_HANDLING
   1210              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_ERROR))
   1211              {
   1212                  _usb_khci_service_err_intr(state_ptr);
   1213              }
   1214          #endif
   1215              /* This TOKEN_DONE interrupt comes when the current token being processed
   1216               * has completed. The ColdFire core should immediately read the STAT register
   1217               * to determine the EndPoint and BD used for this token. Clearing this bit
   1218               * (by writing a one) causes the STAT register to be cleared or the
   1219               * STAT holding register to be loaded into the STAT register.
   1220               */
   1221              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_TOKDNE))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable20_4  ;; 0x40072080
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable20_6
   \   0000000A   0xB085             SUB      SP,SP,#+20
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x7921             LDRB     R1,[R4, #+4]
   \   00000010   0x4008             ANDS     R0,R1,R0
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0xBF44             ITT      MI 
   1222              {
   1223              //  USB_PRINTF("done ++");
   1224                  _usb_khci_service_tk_dne_intr(state_ptr);
   \   00000016   0x4628             MOVMI    R0,R5
   \   00000018   0x.... 0x....      BLMI     _usb_khci_service_tk_dne_intr
   1225              }
   1226              /* This reset interrupt comes when the USB Module has decoded a valid USB reset.
   1227               * This informs the Microprocessor that it should write 0x00 into the address
   1228               * register and enable endpoint 0. USB_RST bit is set after a USB reset has been
   1229               * detected for 2.5 microseconds. It is not asserted again until the USB reset
   1230               * condition has been removed and then reasserted.
   1231               */
   1232              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_USBRST))
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x7921             LDRB     R1,[R4, #+4]
   \   00000020   0x4008             ANDS     R0,R1,R0
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD510             BPL.N    ??_usb_khci_isr_0
   1233              {
   1234                  _usb_khci_service_reset_intr(state_ptr);
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   \   0000002A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000002C   0x6869             LDR      R1,[R5, #+4]
   \   0000002E   0x9100             STR      R1,[SP, #+0]
   \   00000030   0x0900             LSRS     R0,R0,#+4
   \   00000032   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x9002             STR      R0,[SP, #+8]
   \   00000042   0x2010             MOVS     R0,#+16
   \   00000044   0x.... 0x....      BL       _usb_device_call_service
   1235              }
   1236          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME    
   1237              /* This sleep interrupt comes when the USB Module detects a constant idle
   1238               * on the USB bus for 3 milliseconds.
   1239               */
   1240              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_SLEEP))
   1241              {
   1242                  _usb_khci_service_sleep_intr(state_ptr);
   1243              }
   1244              
   1245              /* This interrupt comes depending upon the DP/DM signals, and can be used
   1246               * to signal remote wake-up signaling on the USB bus. When not in suspend
   1247               * mode this interrupt should be disabled
   1248               */
   1249              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_RESUME))
   1250              {
   1251                  _usb_khci_service_resume_intr(state_ptr);
   1252              }
   1253          #endif
   1254              /* Thisinterrupt comes when the USB Module receives a Start Of Frame
   1255               * (SOF) token.
   1256               */
   1257              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_SOFTOK))
   \                     ??_usb_khci_isr_0: (+1)
   \   00000048   0x7820             LDRB     R0,[R4, #+0]
   \   0000004A   0x7921             LDRB     R1,[R4, #+4]
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x0740             LSLS     R0,R0,#+29
   \   00000050   0xBF44             ITT      MI 
   1258              {
   1259                  _usb_khci_service_sof_token_intr(state_ptr);
   \   00000052   0x4628             MOVMI    R0,R5
   \   00000054   0x.... 0x....      BLMI     _usb_khci_service_sof_token_intr
   1260              }
   1261          
   1262          #if 0    
   1263              /* This interrupt comes when the USB Module detects an attach of a 
   1264               * USB device. This signal is only valid if HOST_MODE_EN is true. 
   1265               * This interrupt signifies that a peripheral is now present and must
   1266               * be configured.
   1267               */
   1268              if(usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_ATTACH))
   1269              {
   1270                  _usb_khci_service_attach_intr(state_ptr);
   1271              }
   1272          #endif    
   1273              /* In Target mode this interrupt comes when a STALL handshake is sent 
   1274                 by the SIE.*/
   1275              if (usb_hal_khci_is_interrupt_issued(state_ptr->usbRegBase, INTR_STALL))
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x7921             LDRB     R1,[R4, #+4]
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x0600             LSLS     R0,R0,#+24
   \   00000060   0xBF44             ITT      MI 
   1276              {
   1277                  _usb_khci_service_stall_intr(state_ptr);
   \   00000062   0x4628             MOVMI    R0,R5
   \   00000064   0x.... 0x....      BLMI     _usb_khci_service_stall_intr
   1278              }
   1279          
   1280              return;
   \   00000068   0xB005             ADD      SP,SP,#+20
   \   0000006A   0xBD30             POP      {R4,R5,PC}       ;; return
   1281          }
   1282          
   1283          /*****************************************************************************
   1284           * Global Functions
   1285           *****************************************************************************/
   1286          /**************************************************************************//*!
   1287          *
   1288          * @name        : usb_dci_khci_preinit
   1289          * @brief       : Allocates space for the USB device controller.
   1290          * @param handle: Handle to USB Device to be filled
   1291          * @return   USB_OK on successful.
   1292          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1293          usb_status usb_dci_khci_preinit
   1294          (
   1295              /* [IN] the USB device handle */
   1296              usb_device_handle upper_layer_handle,
   1297          
   1298              usb_device_handle * handle_ptr
   1299          )
   1300          {
   \                     usb_dci_khci_preinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1301              usb_khci_dev_state_struct_t* usb_dev_ptr = (usb_khci_dev_state_struct_t*) (&g_khci_dev[0]);
   1302          
   1303          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
   1304              if(NULL == g_khci_data_ptr)
   1305              {
   1306                  g_khci_data_ptr = OS_Mem_alloc_uncached_align(sizeof(usb_device_khci_data_t), 512);
   1307              }
   1308          #endif
   1309          
   1310              usb_dci_khci_init_xd((usb_device_handle)usb_dev_ptr);
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable20_6
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       usb_dci_khci_init_xd
   1311              
   1312          #if USBCFG_KHCI_4BYTE_ALIGN_FIX
   1313              
   1314          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK)
   1315              _usb_khci_dev_swap_buf_ptr = g_khci_data.swap_buf;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1316          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
   1317              _usb_khci_dev_swap_buf_ptr = g_khci_data_ptr->swap_buf;
   1318          #endif
   1319              
   1320          #endif
   1321          	usb_dev_ptr->mutex = OS_Mutex_create();
   \   0000001A   0x.... 0x....      BL       OS_Mutex_create
   \   0000001E   0xF8C6 0x00A8      STR      R0,[R6, #+168]
   1322              *handle_ptr = (usb_device_handle) usb_dev_ptr;
   \   00000022   0x602E             STR      R6,[R5, #+0]
   1323              usb_dev_ptr->upper_layer_handle = upper_layer_handle;
   \   00000024   0x6074             STR      R4,[R6, #+4]
   1324          
   1325              return USB_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1326          }   
   1327          
   1328          /**************************************************************************//*!
   1329          *
   1330          * @name        : usb_dci_khci_init
   1331          * @brief       : Initializes the USB device controller.
   1332          * @param handle: USB device handle.
   1333          * @param init_param: initialization parameters specific for device
   1334          * @return   USB_OK on successful.
   1335          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1336          usb_status usb_dci_khci_init
   1337          (
   1338              uint8_t     controller_id,
   1339              /* [IN] the USB device handle */
   1340              
   1341              usb_device_handle         handle
   1342          )
   1343          {
   \                     usb_dci_khci_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1344          #ifdef USBCFG_OTG
   1345              usb_otg_state_struct_t *   usb_otg_struct_ptr = (usb_otg_state_struct_t *)g_usb_otg_handle;
   1346              usb_otg_status_t *         otg_status_ptr     = &usb_otg_struct_ptr->otg_status;
   1347          #endif
   1348              usb_khci_dev_state_struct_t* usb_dev_ptr = (usb_khci_dev_state_struct_t*)handle;
   1349              //volatile USB_MemMapPtr             usb_ptr;
   1350          
   1351              usb_dev_ptr->dev_vec = soc_get_usb_vector_number(controller_id);
   \   00000006   0xF104 0x0528      ADD      R5,R4,#+40
   \   0000000A   0x.... 0x....      BL       soc_get_usb_vector_number
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
   1352              
   1353              usb_dev_ptr->usbRegBase = soc_get_usb_base_address(controller_id);
   \   00000010   0x4630             MOV      R0,R6
   \   00000012   0x.... 0x....      BL       soc_get_usb_base_address
   \   00000016   0xF8C4 0x00AC      STR      R0,[R4, #+172]
   1354              /* Get the maximum number of endpoints supported by this USB controller */
   1355              usb_dev_ptr->max_endpoints = KHCI_MAX_ENDPOINT;
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x70A8             STRB     R0,[R5, #+2]
   1356          
   1357              /* Clear all interrupts and bring it to finite
   1358               * state before device starts functioning.
   1359               */
   1360              usb_hal_khci_clr_all_interrupts(usb_dev_ptr->usbRegBase);
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable20_4  ;; 0x40072080
   \   00000024   0x7030             STRB     R0,[R6, #+0]
   1361              usb_hal_khci_disable_dp_pull_up(usb_dev_ptr->usbRegBase);
   1362          
   1363          
   1364          
   1365          #ifndef USBCFG_OTG 
   1366              /* Install the ISR
   1367               * Device Pointer is passed as an Argument when the
   1368               * ISR is invoked.
   1369               */
   1370          #if (OS_ADAPTER_ACTIVE_OS != OS_ADAPTER_SDK)
   1371              if (!(OS_install_isr(usb_dev_ptr->dev_vec, (void (*)(void *))_usb_khci_isr, usb_dev_ptr)))
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x4007201c
   \   0000002C   0x7801             LDRB     R1,[R0, #+0]
   \   0000002E   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000032   0x7001             STRB     R1,[R0, #+0]
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   0000003A   0x.... 0x....      BL       bm_install_isr
   \   0000003E   0xB908             CBNZ.N   R0,??usb_dci_khci_init_0
   1372                  return USBERR_INSTALL_ISR;
   \   00000040   0x208A             MOVS     R0,#+138
   \   00000042   0xBD70             POP      {R4-R6,PC}
   1373          #else
   1374              OS_install_isr(usb_dev_ptr->dev_vec, (void (*)(void))_usb_khci_isr, usb_dev_ptr);
   1375          #endif
   1376          #endif
   1377          
   1378              
   1379          #if ((OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_BM) || (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_SDK))
   1380              bdt = (uint8_t *)g_khci_data.bdt;
   \                     ??usb_dci_khci_init_0: (+1)
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000004C   0x6048             STR      R0,[R1, #+4]
   1381          #elif (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
   1382              bdt = (uint8_t *)g_khci_data_ptr->bdt;
   1383          #endif
   1384              
   1385              /* Initialize BDT Page register 1,2,3. The Buffer
   1386                   * Descriptor Table Page Register 1 2,3 contains an
   1387                   * 8-bit value used to compute the address where
   1388                   * the current Buffer Descriptor Table (BDT)
   1389                   * resides in system memory.
   1390                   */    
   1391              usb_hal_khci_set_buffer_descriptor_table_addr(usb_dev_ptr->usbRegBase,(uint32_t)bdt);
   \   0000004E   0x0A01             LSRS     R1,R0,#+8
   \   00000050   0x7731             STRB     R1,[R6, #+28]
   \   00000052   0x0C02             LSRS     R2,R0,#+16
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable20_11  ;; 0x400720b0
   \   00000058   0x700A             STRB     R2,[R1, #+0]
   \   0000005A   0x0E00             LSRS     R0,R0,#+24
   \   0000005C   0x7108             STRB     R0,[R1, #+4]
   1392              
   1393               /* Initialize the end point state*/
   1394              _usb_khci_reset_ep_state(usb_dev_ptr); 
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       _usb_khci_reset_ep_state
   1395                    
   1396              
   1397              //USB_PRINTF("11usb_dci_khci_init ++");
   1398              /* Enable Sleep,Token Done,Error,USB Reset,Stall,
   1399               * Resume and SOF Interrupt.
   1400               */
   1401              //usb_hal_khci_enable_interrupts(usb_dev_ptr->usbRegBase,(INTR_USBRST | INTR_ERROR | INTR_SOFTOK | INTR_TOKDNE | INTR_SLEEP | INTR_STALL));
   1402              
   1403          #ifdef USBCFG_OTG
   1404              usb_dev_ptr->otg_handle = g_usb_otg_handle;
   1405              otg_status_ptr->active_stack = USB_ACTIVE_STACK_DEVICE;
   1406              /* set otg status to 0 */
   1407              usb_dci_khci_set_status(handle, USB_STATUS_OTG, 0);
   1408              /**/
   1409          #endif
   1410              return USB_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
   1411          }
   1412          
   1413          /**************************************************************************//*!
   1414          *
   1415          * @name        : usb_dci_khci_init
   1416          * @brief       : Initializes the USB device controller.
   1417          * @param handle: USB device handle.
   1418          * @param init_param: initialization parameters specific for device
   1419          * @return   USB_OK on successful.
   1420          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1421          usb_status usb_dci_khci_postinit
   1422          (
   1423              uint8_t     controller_id,
   1424              /* [IN] the USB device handle */
   1425              
   1426              usb_device_handle         handle
   1427          )
   1428          {
   1429              /* Enable D+ pull up register
   1430               * Note, that this D+ external resistor is not applicable for some devices
   1431               */
   1432              usb_khci_dev_state_struct_t* usb_dev_ptr = (usb_khci_dev_state_struct_t*)(&g_khci_dev[0]);;
   1433              //usb_khci_dev_state_struct_t* state_ptr = *usb_dev_ptr;
   1434              
   1435              usb_hal_khci_enable_dp_pull_up(usb_dev_ptr->usbRegBase);
   \                     usb_dci_khci_postinit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x4007201c
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   1436               /* Enable USB module*/
   1437              usb_hal_khci_enable_sof(usb_dev_ptr->usbRegBase);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable20_12  ;; 0x40072094
   \   00000010   0x7801             LDRB     R1,[R0, #+0]
   \   00000012   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   1438          
   1439              /* Remove suspend state */
   1440              usb_hal_khci_clr_suspend(usb_dev_ptr->usbRegBase);
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable20_13  ;; 0x40072100
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000022   0x7001             STRB     R1,[R0, #+0]
   1441              return USB_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
   1442          }
   1443          
   1444          /**************************************************************************//*!
   1445          * @name        : usb_dci_khci_init_endpoint
   1446          *
   1447          * @brief       : Initialize the Endpoint
   1448          * @param handle: Handle to USB Device.
   1449          * @param xd_ptr: Transaction Discriptor.
   1450          * @return      :  USB_OK or error code
   1451          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1452          usb_status usb_dci_khci_init_endpoint
   1453          (
   1454               /*[IN]*/
   1455              usb_device_handle handle, 
   1456              /*[IN]*/
   1457              xd_struct_t*       xd_ptr
   1458          )
   1459          {
   \                     usb_dci_khci_init_endpoint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   1460              //usb_status error = USB_OK;
   1461              uint16_t max_pkt_size = 0;
   1462          
   1463              /* Get the device pointer initialized in usb_dci_khci_init*/
   1464              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1465              //volatile USB_MemMapPtr usb_ptr;
   1466          #if 0
   1467              if (state_ptr == NULL)
   1468              {
   1469                  return USBERR_ERROR;
   1470              }
   1471          
   1472              if((xd_ptr->ep_type > USB_INTERRUPT_PIPE) || 
   1473                  (xd_ptr->bdirection > USB_SEND))
   1474              {
   1475                  return USBERR_EP_INIT_FAILED;
   1476              }
   1477          #endif
   1478              //USB_PRINTF("init ep %d dir %d\n", xd_ptr->EP_NUM, xd_ptr->BDIRECTION);
   1479          
   1480              /* mark this endpoint as initialized */
   1481              state_ptr->ep_info[xd_ptr->ep_num].ep_init_flag[xd_ptr->bdirection] = TRUE;
   \   00000006   0x7829             LDRB     R1,[R5, #+0]
   \   00000008   0x786A             LDRB     R2,[R5, #+1]
   \   0000000A   0x2014             MOVS     R0,#+20
   \   0000000C   0xFB10 0x4101      SMLABB   R1,R0,R1,R4
   \   00000010   0x1851             ADDS     R1,R2,R1
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xF881 0x203C      STRB     R2,[R1, #+60]
   1482                  
   1483              /*before initializing cancel all transfers on EP as there may be calls
   1484                for endpoint initialization more than once. This will free any allocated
   1485                queue*/
   1486          
   1487              /*
   1488               * Since this is endpoint initialization section there will
   1489               * not be any pending transfers on this endpoint
   1490               */
   1491          
   1492                  
   1493              /* The end point buffer size will be set as required by app.
   1494               * but if the size crosses MAX_EP_BUFFER_SIZE size then truncate the
   1495               * max packet size.
   1496               */
   1497              if (xd_ptr->ep_type == USB_ISOCHRONOUS_PIPE)
   \   00000018   0x78AB             LDRB     R3,[R5, #+2]
   \   0000001A   0x8AA9             LDRH     R1,[R5, #+20]
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD105             BNE.N    ??usb_dci_khci_init_endpoint_0
   1498              {
   1499                  max_pkt_size = (uint16_t)((xd_ptr->wmaxpacketsize > MAX_FS_ISO_EP_BUFFER_SIZE)?
   1500                  MAX_FS_ISO_EP_BUFFER_SIZE:xd_ptr->wmaxpacketsize);
   \   00000020   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000024   0xDB05             BLT.N    ??usb_dci_khci_init_endpoint_1
   \   00000026   0xF240 0x31FF      MOVW     R1,#+1023
   \   0000002A   0xE002             B.N      ??usb_dci_khci_init_endpoint_1
   1501              }
   1502              else
   1503              {
   1504                  max_pkt_size = (uint16_t)((xd_ptr->wmaxpacketsize > MAX_FS_NON_ISO_EP_BUFFER_SIZE)?
   1505                  MAX_FS_NON_ISO_EP_BUFFER_SIZE:xd_ptr->wmaxpacketsize);
   \                     ??usb_dci_khci_init_endpoint_0: (+1)
   \   0000002C   0x2941             CMP      R1,#+65
   \   0000002E   0xBFA8             IT       GE 
   \   00000030   0x2140             MOVGE    R1,#+64
   1506              }
   1507              
   1508              /* Initialize the End Point Information Structure which is part of device
   1509               * structure. It is done so that it can be used at later point of time
   1510               * like ISR handler, any other function call.
   1511               */
   1512              state_ptr->ep_info[xd_ptr->ep_num].type = xd_ptr->ep_type;
   \                     ??usb_dci_khci_init_endpoint_1: (+1)
   \   00000032   0x782A             LDRB     R2,[R5, #+0]
   \   00000034   0xFB10 0x4202      SMLABB   R2,R0,R2,R4
   \   00000038   0xF882 0x303E      STRB     R3,[R2, #+62]
   1513              state_ptr->ep_info[xd_ptr->ep_num].direction = xd_ptr->bdirection;
   \   0000003C   0x782A             LDRB     R2,[R5, #+0]
   \   0000003E   0x786B             LDRB     R3,[R5, #+1]
   \   00000040   0xFB10 0x4202      SMLABB   R2,R0,R2,R4
   \   00000044   0xF882 0x303F      STRB     R3,[R2, #+63]
   1514              state_ptr->ep_info[xd_ptr->ep_num].max_packet_size = max_pkt_size;
   \   00000048   0x782A             LDRB     R2,[R5, #+0]
   \   0000004A   0xFB10 0x4202      SMLABB   R2,R0,R2,R4
   \   0000004E   0x8711             STRH     R1,[R2, #+56]
   1515              state_ptr->ep_info[xd_ptr->ep_num].endpoint_status = USB_STATUS_IDLE;
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x7829             LDRB     R1,[R5, #+0]
   \   00000054   0xFB10 0x4101      SMLABB   R1,R0,R1,R4
   \   00000058   0xF881 0x203A      STRB     R2,[R1, #+58]
   1516              state_ptr->ep_info[xd_ptr->ep_num].stall_flag = FALSE;
   \   0000005C   0x7829             LDRB     R1,[R5, #+0]
   \   0000005E   0xFB10 0x4101      SMLABB   R1,R0,R1,R4
   \   00000062   0xF881 0x203B      STRB     R2,[R1, #+59]
   1517              if (USB_RECV == xd_ptr->bdirection)
   \   00000066   0x7829             LDRB     R1,[R5, #+0]
   \   00000068   0x786A             LDRB     R2,[R5, #+1]
   \   0000006A   0xFB10 0x4101      SMLABB   R1,R0,R1,R4
   \   0000006E   0x3140             ADDS     R1,R1,#+64
   \   00000070   0xB932             CBNZ.N   R2,??usb_dci_khci_init_endpoint_2
   1518              {
   1519                  state_ptr->ep_info[xd_ptr->ep_num].rx_data0 = 0;
   \   00000072   0x704A             STRB     R2,[R1, #+1]
   1520                  state_ptr->ep_info[xd_ptr->ep_num].recv_xd = NULL;
   \   00000074   0x7829             LDRB     R1,[R5, #+0]
   \   00000076   0xFB10 0x4001      SMLABB   R0,R0,R1,R4
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6341             STR      R1,[R0, #+52]
   \   0000007E   0xE005             B.N      ??usb_dci_khci_init_endpoint_3
   1521              }
   1522              else
   1523              {
   1524                  state_ptr->ep_info[xd_ptr->ep_num].tx_data0 = 0;
   \                     ??usb_dci_khci_init_endpoint_2: (+1)
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x700A             STRB     R2,[R1, #+0]
   1525                  state_ptr->ep_info[xd_ptr->ep_num].send_xd = NULL;
   \   00000084   0x7829             LDRB     R1,[R5, #+0]
   \   00000086   0xFB10 0x4001      SMLABB   R0,R0,R1,R4
   \   0000008A   0x6302             STR      R2,[R0, #+48]
   1526              }
   1527              
   1528              usb_hal_khci_endpoint_enable_handshake(state_ptr->usbRegBase, xd_ptr->ep_num, ((xd_ptr->ep_type != USB_ISOCHRONOUS_PIPE) ? 1 : 0));
   \                     ??usb_dci_khci_init_endpoint_3: (+1)
   \   0000008C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xBF18             IT       NE 
   \   00000092   0x2201             MOVNE    R2,#+1
   \   00000094   0x7829             LDRB     R1,[R5, #+0]
   \   00000096   0xF8D4 0x00AC      LDR      R0,[R4, #+172]
   \   0000009A   0x.... 0x....      BL       usb_hal_khci_endpoint_enable_handshake
   1529              usb_hal_khci_endpoint_set_direction(state_ptr->usbRegBase, xd_ptr->ep_num, (xd_ptr->bdirection ? 1 : 0));
   \   0000009E   0x786A             LDRB     R2,[R5, #+1]
   \   000000A0   0xB102             CBZ.N    R2,??usb_dci_khci_init_endpoint_4
   \   000000A2   0x2201             MOVS     R2,#+1
   \                     ??usb_dci_khci_init_endpoint_4: (+1)
   \   000000A4   0x7829             LDRB     R1,[R5, #+0]
   \   000000A6   0xF8D4 0x00AC      LDR      R0,[R4, #+172]
   \   000000AA   0x.... 0x....      BL       usb_hal_khci_endpoint_set_direction
   1530              if ((USB_RECV == xd_ptr->bdirection) && (xd_ptr->ep_num == USB_CONTROL_ENDPOINT) )
   \   000000AE   0x7868             LDRB     R0,[R5, #+1]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xBF01             ITTTT    EQ 
   \   000000B4   0x7828             LDRBEQ   R0,[R5, #+0]
   \   000000B6   0x2800             CMPEQ    R0,#+0
   1531              {
   1532                  _usb_khci_next_setup_token_prep(state_ptr);
   \   000000B8   0x4620             MOVEQ    R0,R4
   \   000000BA   0x.... 0x....      BLEQ     _usb_khci_next_setup_token_prep
   1533              }
   1534          #if 0
   1535              /* Write the initialized control values to end point control register*/
   1536              //usb_hal_set_endpoint_ephshk(state_ptr->usbRegBase, xd_ptr->ep_num, (xd_ptr->ep_type != USB_ISOCHRONOUS_PIPE ? 1 : 0));
   1537              
   1538              /*Configure this endpoint for receive or Send direction as reuired by APP*/
   1539              //usb_hal_set_endpoint_direction(state_ptr->usbRegBase, xd_ptr->ep_num, (xd_ptr->bdirection ? 1: 0));
   1540              
   1541              /* Set the BDT and buffer data pointer for Receive Direction*/
   1542              if ((USB_RECV == xd_ptr->bdirection) && (xd_ptr->ep_num == USB_CONTROL_ENDPOINT) )
   1543              {
   1544                  const uint8_t control[2] = { 
   1545                      USB_BD_DATA01(0) | USB_BD_DTS | USB_BD_OWN,
   1546                      USB_BD_DATA01(1) | USB_BD_DTS
   1547                  };
   1548          
   1549                  /* configure first start address for recv transaction */
   1550                  usb_dci_khci_get_xd (state_ptr, &xd_temp_ptr);
   1551                  xd_temp_ptr->ep_num = xd_ptr->ep_num;
   1552                  xd_temp_ptr->bdirection = xd_ptr->bdirection;
   1553                  xd_temp_ptr->wtotallength =xd_ptr->wtotallength;
   1554          #if USBCFG_4BYTE_ALIGN_FIX
   1555                  xd_temp_ptr->internal_dma_align = TRUE;
   1556          #endif
   1557                  xd_temp_ptr->wsofar = xd_ptr->wsofar;
   1558                  xd_temp_ptr->ep_type = xd_ptr->ep_type;
   1559                  xd_temp_ptr->dont_zero_terminate = xd_ptr->dont_zero_terminate;
   1560                  xd_temp_ptr->wstartaddress = (uint8_t *)USB_LONG_LE_TO_HOST((uint32_t)state_ptr->setup_buff);
   1561                  USB_XD_QUEUE_ENQUEUE(&state_ptr->ep_info[xd_ptr->ep_num].xd_queue_recv, xd_temp_ptr);
   1562          
   1563                  /*Configure Even buff for the end point*/
   1564                  BD_ADDR_RX(xd_ptr->ep_num, state_ptr->ep_info[xd_ptr->ep_num].rx_buf_odd) =
   1565                          USB_LONG_LE_TO_HOST((uint32_t)state_ptr->setup_buff);
   1566                  
   1567                  BD_CTRL_RX(xd_ptr->ep_num, state_ptr->ep_info[xd_ptr->ep_num].rx_buf_odd) =
   1568                          USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(SETUP_PACKET_LENGTH) | control[0]));
   1569          
   1570                  /*Configure Even buff for odd end point*/
   1571                  BD_ADDR_RX(xd_ptr->ep_num, state_ptr->ep_info[xd_ptr->ep_num].rx_buf_odd ^ 1) =
   1572                          USB_LONG_LE_TO_HOST((uint32_t)
   1573                          (state_ptr->setup_buff + SETUP_PACKET_LENGTH));
   1574                  BD_CTRL_RX(xd_ptr->ep_num, state_ptr->ep_info[xd_ptr->ep_num].rx_buf_odd ^ 1) =
   1575                          USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(SETUP_PACKET_LENGTH) | control[1]));
   1576              }
   1577              else /* Set the BDT and buffer data pointer for Send direction */
   1578              {
   1579                  /* Initialize the DATA PID to DATA0*/
   1580                  //state_ptr->EP_INFO[xd_ptr->EP_NUM].tx_data0 = 0;
   1581          
   1582              }
   1583          #endif
   1584              return USB_OK;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1585          }
   1586          
   1587          /**************************************************************************//*!
   1588          * @name  : usb_dci_khci_deinit_endpoint
   1589          *
   1590          * @brief       : De-Initialize the Endpoint
   1591          * @param handle: Handle to USB Device.
   1592          * @param ep_num: End Point Number.
   1593          * @param direction: USB_SEND or USB_RECV.
   1594          * @return      :  USB_OK or error code
   1595          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1596          usb_status usb_dci_khci_deinit_endpoint
   1597          (
   1598               /*[IN]*/
   1599              usb_device_handle handle, 
   1600              /*[IN]*/
   1601              uint8_t ep_num,
   1602              /*[IN]*/
   1603              uint8_t direction 
   1604          )
   1605          {
   \                     usb_dci_khci_deinit_endpoint: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
   1606              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1607              //volatile USB_MemMapPtr usb_ptr;
   1608          
   1609              /*before de-initializing cancel all transfers on EP */
   1610              usb_dci_khci_cancel(handle, ep_num, direction);
   \   00000008   0x.... 0x....      BL       usb_dci_khci_cancel
   1611              
   1612              /*Disable the trasmit or receive endpoint*/
   1613              usb_hal_khci_endpoint_shut_down(state_ptr->usbRegBase, ep_num);
   \   0000000C   0x....             LDR.N    R1,??DataTable20  ;; 0x400720c0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF801 0x0026      STRB     R0,[R1, R6, LSL #+2]
   1614            
   1615              /* uninitialise the strucrure for this endpoint */
   1616              usb_hal_khci_bdt_set_address( (uint32_t)bdt, ep_num, direction, EVEN_BUFF, USB_LONG_LE_TO_HOST_CONST((uint32_t)USB_UNINITIALIZED_VAL_32));
   \   00000014   0xF006 0x010F      AND      R1,R6,#0xF
   \   00000018   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000001C   0xEA40 0x1041      ORR      R0,R0,R1, LSL #+5
   \   00000020   0xF004 0x0101      AND      R1,R4,#0x1
   \   00000024   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \   00000028   0xF04F 0x31FF      MOV      R1,#-1
   \   0000002C   0x6041             STR      R1,[R0, #+4]
   1617              usb_hal_khci_bdt_set_address( (uint32_t)bdt, ep_num, direction, ODD_BUFF, USB_LONG_LE_TO_HOST_CONST((uint32_t)USB_UNINITIALIZED_VAL_32));
   \   0000002E   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000032   0x6041             STR      R1,[R0, #+4]
   1618              //BD_ADDR(ep_num,direction,EVEN_BUFF) =
   1619              //    USB_LONG_LE_TO_HOST_CONST((uint32_t)USB_UNINITIALIZED_VAL_32);
   1620              //BD_ADDR(ep_num,direction,ODD_BUFF) =
   1621              //    USB_LONG_LE_TO_HOST_CONST((uint32_t)USB_UNINITIALIZED_VAL_32);
   1622              
   1623              state_ptr->ep_info[ep_num].max_packet_size =    
   1624                  (uint16_t)USB_UNINITIALIZED_VAL_32;
   \   00000034   0x2014             MOVS     R0,#+20
   \   00000036   0xFB10 0x5006      SMLABB   R0,R0,R6,R5
   \   0000003A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000003E   0x8701             STRH     R1,[R0, #+56]
   1625          
   1626              /* mark this endpoint as de-initialized */
   1627              state_ptr->ep_info[ep_num].ep_init_flag[direction] = FALSE;
   \   00000040   0x1820             ADDS     R0,R4,R0
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xF880 0x103C      STRB     R1,[R0, #+60]
   1628                  
   1629              return USB_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   1630          }
   1631          
   1632          /**************************************************************************//*!
   1633          * @name  usb_dci_khci_send
   1634          * @brief       : Sends data. Non-blocking.
   1635          * @param handle: Handle to USB Device.
   1636          * @param xd_ptr: Transaction Discriptor.
   1637          * @return      :  USB_OK or error code
   1638          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1639          usb_status usb_dci_khci_send
   1640          (
   1641               /*[IN]*/
   1642              usb_device_handle handle, 
   1643              /*[IN]*/
   1644              xd_struct_t*       xd_ptr 
   1645          )
   1646          {
   \                     usb_dci_khci_send: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   1647              usb_status error = USBERR_TX_FAILED;/* initializing to failed value */
   1648              uint32_t buf_num_bytes = (uint32_t)(xd_ptr->wtotallength - xd_ptr->wsofar);
   \   00000008   0x68A8             LDR      R0,[R5, #+8]
   \   0000000A   0x68E9             LDR      R1,[R5, #+12]
   \   0000000C   0x1A40             SUBS     R0,R0,R1
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   1649              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1650          
   1651              /* Allocate XD stucutre from Free List maintained by Device strucutre,
   1652               * if it is not any split transaction.
   1653               */
   1654              if (xd_ptr->wsofar == 0)
   \   00000010   0x2614             MOVS     R6,#+20
   \   00000012   0x68E8             LDR      R0,[R5, #+12]
   \   00000014   0xB918             CBNZ.N   R0,??usb_dci_khci_send_0
   1655              {
   1656                  state_ptr->ep_info[xd_ptr->ep_num].send_xd = xd_ptr;
   \   00000016   0x7829             LDRB     R1,[R5, #+0]
   \   00000018   0xFB16 0x4101      SMLABB   R1,R6,R1,R4
   \   0000001C   0x630D             STR      R5,[R1, #+48]
   1657                  //USB_XD_QUEUE_ENQUEUE(&state_ptr->ep_info[xd_ptr->ep_num].xd_queue_send, xd_ptr);
   1658                  //USB_PRINTF("after send ep %d enqueue: xd_head_ptr 0x%x xd_tail_ptr 0x%x\n", xd_ptr->EP_NUM, 
   1659                  //        state_ptr->EP_INFO[xd_ptr->EP_NUM].xd_queue_send.xd_head_ptr,
   1660                  //        state_ptr->EP_INFO[xd_ptr->EP_NUM].xd_queue_send.xd_tail_ptr);
   1661                  
   1662              }
   1663          
   1664          
   1665          #if 0
   1666              /* Upper layer wants to send Zero Packet data
   1667               * Note that this situation will only come when
   1668               * Upper layer wants to send Zero packet data not
   1669               * in case of split transaction
   1670               */
   1671              if (buf_num_bytes == 0)
   1672              {
   1673                  error = _usb_khci_ep_write(state_ptr, xd_ptr->ep_num,
   1674                      xd_ptr->wstartaddress, buf_num_bytes, (uint32_t*)&buf_num_bytes);
   1675                  
   1676                  if (error != USB_OK)
   1677                  {
   1678                      /* If write returns error release the XD pointer
   1679                               * from Endpoint send queue and return it to Free list of XD pointers.
   1680                               */
   1681                      xd_ptr->bstatus = USB_STATUS_IDLE;
   1682                      //USB_XD_QUEUE_DEQUEUE (&state_ptr->ep_info[xd_ptr->ep_num].xd_queue_send, &xd_ptr);
   1683                      //if (xd_ptr != NULL)
   1684                      //    _usb_khci_free_XD(state_ptr, xd_ptr);
   1685                  }
   1686                  return error;
   1687              }
   1688          #endif
   1689              /* If not Zero Size packet send the data from here*/
   1690              error = _usb_khci_ep_write(state_ptr, xd_ptr->ep_num,
   1691                  (uint8_t *)xd_ptr->wstartaddress + xd_ptr->wsofar, buf_num_bytes,
   1692                  (uint32_t*)&buf_num_bytes);
   \                     ??usb_dci_khci_send_0: (+1)
   \   0000001E   0xA901             ADD      R1,SP,#+4
   \   00000020   0x9100             STR      R1,[SP, #+0]
   \   00000022   0x6869             LDR      R1,[R5, #+4]
   \   00000024   0x9B01             LDR      R3,[SP, #+4]
   \   00000026   0x1842             ADDS     R2,R0,R1
   \   00000028   0x7829             LDRB     R1,[R5, #+0]
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _usb_khci_ep_write
   \   00000030   0x0007             MOVS     R7,R0
   1693              
   1694              if (error != USB_OK)
   \   00000032   0xD008             BEQ.N    ??usb_dci_khci_send_1
   1695              {
   1696                  /* If write returns error release the XD pointer
   1697                   * from Endpoint send queue and return it to Free list of XD pointers.
   1698                   */
   1699                  //xd_ptr->bstatus = USB_STATUS_IDLE;
   1700                  state_ptr->ep_info[xd_ptr->ep_num].send_xd = NULL;
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0xFB16 0x4000      SMLABB   R0,R6,R0,R4
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x6301             STR      R1,[R0, #+48]
   1701                  //USB_XD_QUEUE_DEQUEUE (&state_ptr->ep_info[xd_ptr->ep_num].xd_queue_send, &xd_ptr);
   1702                  //if (xd_ptr != NULL)
   1703                  usb_dci_khci_free_xd(state_ptr, xd_ptr);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x.... 0x....      BL       usb_dci_khci_free_xd
   1704              }   
   1705              return error;
   \                     ??usb_dci_khci_send_1: (+1)
   \   00000046   0x4638             MOV      R0,R7
   \   00000048   0xBDFE             POP      {R1-R7,PC}       ;; return
   1706          }
   1707          
   1708          /**************************************************************************//*!
   1709          * @name        : usb_dci_khci_recv
   1710          * @brief       : Receives data. Non-blocking.
   1711          * @param handle: Handle to USB Device.
   1712          * @param xd_ptr: Transaction Discriptor.
   1713          * @return      : USB_OK or error code
   1714          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1715          usb_status usb_dci_khci_recv
   1716          (
   1717               /*[IN]*/
   1718              usb_device_handle handle, 
   1719              /*[IN]*/
   1720              xd_struct_t*       xd_ptr 
   1721          )
   1722          {
   \                     usb_dci_khci_recv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4604             MOV      R4,R0
   1723              usb_status error = USBERR_RX_FAILED;/* initializing to failed value */
   1724              uint32_t buf_num_bytes;
   1725              uint8_t *buf_ptr;
   1726              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1727          
   1728              buf_num_bytes = xd_ptr->wtotallength - xd_ptr->wsofar;
   \   00000008   0x68E8             LDR      R0,[R5, #+12]
   \   0000000A   0x68A9             LDR      R1,[R5, #+8]
   \   0000000C   0x1A0E             SUBS     R6,R1,R0
   1729              
   1730              /* Allocate XD stucutre from Free List maintained by Device strucutre,
   1731               * if it is not any split transaction.
   1732               */
   1733          
   1734              if (xd_ptr->wsofar == 0)
   \   0000000E   0x2714             MOVS     R7,#+20
   \   00000010   0xB918             CBNZ.N   R0,??usb_dci_khci_recv_0
   1735              {
   1736                  //USB_XD_QUEUE_ENQUEUE(&state_ptr->ep_info[xd_ptr->ep_num].xd_queue_recv, xd_ptr);
   1737                  state_ptr->ep_info[xd_ptr->ep_num].recv_xd = xd_ptr;
   \   00000012   0x7829             LDRB     R1,[R5, #+0]
   \   00000014   0xFB17 0x4101      SMLABB   R1,R7,R1,R4
   \   00000018   0x634D             STR      R5,[R1, #+52]
   \                     ??usb_dci_khci_recv_0: (+1)
   \   0000001A   0x7829             LDRB     R1,[R5, #+0]
   \   0000001C   0xFB17 0x4101      SMLABB   R1,R7,R1,R4
   \   00000020   0x8F09             LDRH     R1,[R1, #+56]
   \   00000022   0x42B1             CMP      R1,R6
   \   00000024   0xBF38             IT       CC 
   \   00000026   0x460E             MOVCC    R6,R1
   1738              }
   1739          
   1740              /* If the number of bytes to be received is greater than the
   1741               * maximum data that can be received on the USB bus, then split the
   1742               * transaction into multiple receive transaction.
   1743               */
   1744              if (buf_num_bytes > state_ptr->ep_info[xd_ptr->ep_num].max_packet_size)
   1745              {
   1746                  buf_num_bytes = state_ptr->ep_info[xd_ptr->ep_num].max_packet_size;
   1747              }
   1748              
   1749              /* Send the receiv command to the device.*/
   1750              buf_ptr = (uint8_t *)((uint32_t)xd_ptr->wstartaddress + (uint32_t)xd_ptr->wsofar);
   \   00000028   0x6869             LDR      R1,[R5, #+4]
   \   0000002A   0x1842             ADDS     R2,R0,R1
   1751          #if USBCFG_KHCI_4BYTE_ALIGN_FIX
   1752              if ((_usb_khci_dev_swap_buf_ptr) && ((buf_num_bytes & USB_DMA_ALIGN_MASK) || ((uint32_t)buf_ptr & USB_DMA_ALIGN_MASK)))
   \   0000002C   0x....             LDR.N    R0,??DataTable20_7
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xB158             CBZ.N    R0,??usb_dci_khci_recv_1
   \   00000032   0xF016 0x0F03      TST      R6,#0x3
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0xF012 0x0103      ANDSEQ   R1,R2,#0x3
   \   0000003C   0xD005             BEQ.N    ??usb_dci_khci_recv_1
   1753              {
   1754                  xd_ptr->internal_dma_align = FALSE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x75E9             STRB     R1,[R5, #+23]
   1755                  buf_ptr = (uint8_t*)USB_DMA_ALIGN((int32_t)_usb_khci_dev_swap_buf_ptr);
   \   00000042   0x4241             RSBS     R1,R0,#+0
   \   00000044   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000048   0x180A             ADDS     R2,R1,R0
   1756              }
   1757          #endif
   1758              error = _usb_khci_ep_read(handle, xd_ptr->ep_num, buf_ptr, buf_num_bytes);
   \                     ??usb_dci_khci_recv_1: (+1)
   \   0000004A   0x7829             LDRB     R1,[R5, #+0]
   \   0000004C   0x4633             MOV      R3,R6
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _usb_khci_ep_read
   \   00000054   0xEA5F 0x0800      MOVS     R8,R0
   1759              
   1760              if (error != USB_OK)
   \   00000058   0xD008             BEQ.N    ??usb_dci_khci_recv_2
   1761              {
   1762                  //USB_XD_QUEUE_DEQUEUE(&state_ptr->ep_info[xd_ptr->ep_num].xd_queue_recv, &xd_ptr);
   1763                  //_usb_khci_free_XD(state_ptr, xd_ptr);
   1764                  state_ptr->ep_info[xd_ptr->ep_num].recv_xd = NULL;
   \   0000005A   0x7828             LDRB     R0,[R5, #+0]
   \   0000005C   0xFB17 0x4000      SMLABB   R0,R7,R0,R4
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x6341             STR      R1,[R0, #+52]
   1765                  usb_dci_khci_free_xd(state_ptr, xd_ptr);
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x.... 0x....      BL       usb_dci_khci_free_xd
   1766              }
   1767              
   1768              if(buf_num_bytes ==0 && (xd_ptr->ep_num== USB_CONTROL_ENDPOINT))
   \                     ??usb_dci_khci_recv_2: (+1)
   \   0000006C   0x2E00             CMP      R6,#+0
   \   0000006E   0xBF04             ITT      EQ 
   \   00000070   0x7828             LDRBEQ   R0,[R5, #+0]
   \   00000072   0x2800             CMPEQ    R0,#+0
   \   00000074   0xD10C             BNE.N    ??usb_dci_khci_recv_3
   1769              {
   1770                  usb_dci_khci_free_xd(state_ptr, xd_ptr); 
   \   00000076   0x4629             MOV      R1,R5
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       usb_dci_khci_free_xd
   1771          
   1772                  state_ptr->ep_info[USB_CONTROL_ENDPOINT].rx_buf_odd ^= 1;
   \   0000007E   0xF894 0x0043      LDRB     R0,[R4, #+67]
   \   00000082   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000086   0xF884 0x0043      STRB     R0,[R4, #+67]
   1773                  _usb_khci_next_setup_token_prep(state_ptr);  
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       _usb_khci_next_setup_token_prep
   1774                  // prime the next setup transaction here
   1775              }
   1776              return error;
   \                     ??usb_dci_khci_recv_3: (+1)
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1777          }
   1778          
   1779          /**************************************************************************//*!*
   1780          * @name  : usb_dci_khci_stall_endpoint
   1781          * @brief      : Stalls the specified endpoint
   1782          * @param handle: Handle to USB Device.
   1783          * @param ep_num: End Point Number.
   1784          * @param direction: USB_SEND or USB_RECV.
   1785          * @return      :  USB_OK or error code
   1786          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1787          usb_status usb_dci_khci_stall_endpoint
   1788          (
   1789               /*[IN]*/
   1790              usb_device_handle handle, 
   1791              /*[IN]*/
   1792              uint8_t ep_num, 
   1793              /*[IN]*/
   1794              uint8_t direction
   1795          )
   1796          {
   \                     usb_dci_khci_stall_endpoint: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
   1797              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1798              //USB_MemMapPtr usb_ptr;
   1799           
   1800              /* set  the stall flag in device structure to be true */
   1801              state_ptr->ep_info[ep_num].stall_flag = TRUE;
   \   00000004   0x2114             MOVS     R1,#+20
   \   00000006   0xFB11 0x0105      SMLABB   R1,R1,R5,R0
   \   0000000A   0xF101 0x0638      ADD      R6,R1,#+56
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x70F1             STRB     R1,[R6, #+3]
   1802              state_ptr->ep_info[ep_num].endpoint_status = USB_STATUS_STALLED;
   \   00000012   0x70B1             STRB     R1,[R6, #+2]
   \   00000014   0x4614             MOV      R4,R2
   1803              
   1804              /* retiring pending IRPs on stall detection */
   1805              usb_dci_khci_cancel(handle,ep_num,direction);
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x.... 0x....      BL       usb_dci_khci_cancel
   1806              
   1807              /* If Stall is for Send packet update Send BDT */
   1808              if (direction)
   \   0000001C   0x....             LDR.N    R1,??DataTable20_2
   \   0000001E   0x8830             LDRH     R0,[R6, #+0]
   \   00000020   0x6849             LDR      R1,[R1, #+4]
   \   00000022   0x0580             LSLS     R0,R0,#+22
   \   00000024   0x0A49             LSRS     R1,R1,#+9
   \   00000026   0x0980             LSRS     R0,R0,#+6
   \   00000028   0x0249             LSLS     R1,R1,#+9
   \   0000002A   0xF005 0x020F      AND      R2,R5,#0xF
   \   0000002E   0xF040 0x008C      ORR      R0,R0,#0x8C
   \   00000032   0xEA41 0x1142      ORR      R1,R1,R2, LSL #+5
   \   00000036   0xB13C             CBZ.N    R4,??usb_dci_khci_stall_endpoint_0
   1809              {
   1810                  /* USB_SEND */
   1811                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep_num, USB_SEND, state_ptr->ep_info[ep_num].tx_buf_odd,
   1812                                           USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size)| USB_BD_OWN | USB_BD_STALL | USB_BD_DTS)));
   \   00000038   0x7AB2             LDRB     R2,[R6, #+10]
   \   0000003A   0xF002 0x0201      AND      R2,R2,#0x1
   \   0000003E   0xEA41 0x01C2      ORR      R1,R1,R2, LSL #+3
   \   00000042   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000046   0xE004             B.N      ??usb_dci_khci_stall_endpoint_1
   1813                  //BD_CTRL_TX(ep_num, state_ptr->ep_info[ep_num].tx_buf_odd) =
   1814                  //    USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size)| USB_BD_OWN | USB_BD_STALL | USB_BD_DTS));
   1815              }
   1816              else
   1817              {
   1818                  /* USB_RECV */
   1819                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep_num, USB_RECV, state_ptr->ep_info[ep_num].rx_buf_odd,
   1820                                           USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size)| USB_BD_OWN | USB_BD_STALL | USB_BD_DTS)));
   \                     ??usb_dci_khci_stall_endpoint_0: (+1)
   \   00000048   0x7AF2             LDRB     R2,[R6, #+11]
   \   0000004A   0xF002 0x0201      AND      R2,R2,#0x1
   \   0000004E   0xEA41 0x01C2      ORR      R1,R1,R2, LSL #+3
   1821                  /* If Stall is for Receive transaction, Update Recevice BDT*/
   1822                  //BD_CTRL_RX(ep_num, state_ptr->ep_info[ep_num].rx_buf_odd) =
   1823                  //    USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size) | USB_BD_OWN | USB_BD_STALL | USB_BD_DTS));
   1824              }
   \                     ??usb_dci_khci_stall_endpoint_1: (+1)
   \   00000052   0x.... 0x....      BL       ?Subroutine4
   1825              
   1826              /* Continue Further processing as the IP stops on receiving
   1827               * Setup Token.
   1828               */
   1829              usb_hal_khci_clr_token_busy(state_ptr->usbRegBase);
   1830              
   1831              return USB_OK;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   1832          }
   1833          
   1834          /**************************************************************************//*!*
   1835          * @name  : usb_dci_khci_unstall_endpoint
   1836          * @brief       : Unstall the Endpoint in specific direction
   1837          * @param handle: Handle to USB Device.
   1838          * @param ep_num: End Point Number.
   1839          * @param direction: USB_SEND or USB_RECV.
   1840          * @return      :  USB_OK or error code
   1841          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1842          usb_status usb_dci_khci_unstall_endpoint
   1843          (
   1844               /*[IN]*/
   1845              usb_device_handle handle, 
   1846              /*[IN]*/
   1847              uint8_t ep_num, 
   1848              /*[IN]*/
   1849              uint8_t direction 
   1850          )
   1851          {
   \                     usb_dci_khci_unstall_endpoint: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x460D             MOV      R5,R1
   1852              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1853              //USB_MemMapPtr usb_ptr;
   1854          
   1855              /* clear  the stall flag in device structure */
   1856              state_ptr->ep_info[ep_num].stall_flag = FALSE;
   \   00000008   0x2014             MOVS     R0,#+20
   \   0000000A   0xFB10 0x9005      SMLABB   R0,R0,R5,R9
   \   0000000E   0xF100 0x0738      ADD      R7,R0,#+56
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x70F8             STRB     R0,[R7, #+3]
   1857              state_ptr->ep_info[ep_num].endpoint_status = USB_STATUS_IDLE;
   \   00000016   0x70B8             STRB     R0,[R7, #+2]
   \   00000018   0x4616             MOV      R6,R2
   1858              
   1859              usb_hal_khci_endpoint_clr_stall(state_ptr->usbRegBase, ep_num);
   \   0000001A   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \   0000001E   0x....             LDR.N    R4,??DataTable20_2
   \   00000020   0x.... 0x....      BL       usb_hal_khci_endpoint_clr_stall
   1860          
   1861              if (direction)
   \   00000024   0xF005 0x000F      AND      R0,R5,#0xF
   \   00000028   0xEA4F 0x1840      LSL      R8,R0,#+5
   \   0000002C   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \   00000030   0xB196             CBZ.N    R6,??usb_dci_khci_unstall_endpoint_0
   1862              {/* USB_SEND */
   1863                  usb_hal_khci_endpoint_enable_handshake(state_ptr->usbRegBase, ep_num, 1);
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x.... 0x....      BL       usb_hal_khci_endpoint_enable_handshake
   1864                  usb_hal_khci_endpoint_set_direction(state_ptr->usbRegBase, ep_num, 1);
   \   0000003A   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x.... 0x....      BL       usb_hal_khci_endpoint_set_direction
   1865                  state_ptr->ep_info[ep_num].tx_data0 = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x7238             STRB     R0,[R7, #+8]
   1866                  /*BD_CTRL_TX(ep_num, state_ptr->ep_info[ep_num].tx_buf_odd) =
   1867                      USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size) |
   1868                      USB_BD_DTS | USB_BD_DATA01(0)));*/
   1869                  usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep_num, USB_SEND, state_ptr->ep_info[ep_num].tx_buf_odd,
   1870                                           USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size)| USB_BD_DTS | USB_BD_DATA01(0))));
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x7AB9             LDRB     R1,[R7, #+10]
   \   0000004E   0x.... 0x....      BL       ?Subroutine2
   1871              }
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000052   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000056   0xE014             B.N      ??CrossCallReturnLabel_1
   1872              else
   1873              {/* USB_RECV */
   1874                  usb_hal_khci_endpoint_enable_handshake(state_ptr->usbRegBase, ep_num, 1);
   \                     ??usb_dci_khci_unstall_endpoint_0: (+1)
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x.... 0x....      BL       usb_hal_khci_endpoint_enable_handshake
   1875                  usb_hal_khci_endpoint_set_direction(state_ptr->usbRegBase, ep_num, 0);
   \   00000060   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x.... 0x....      BL       usb_hal_khci_endpoint_set_direction
   1876                  state_ptr->ep_info[ep_num].rx_data0 = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7278             STRB     R0,[R7, #+9]
   1877                  if (ep_num == USB_CONTROL_ENDPOINT)
   \   00000070   0xB91D             CBNZ.N   R5,??usb_dci_khci_unstall_endpoint_1
   1878                  {
   1879                      /* something important need to do is toggle the tx buffer odd */
   1880                      //state_ptr->ep_info[USB_CONTROL_ENDPOINT].tx_buf_odd ^= 1;
   1881                      _usb_khci_next_setup_token_prep(state_ptr);
   \   00000072   0x4648             MOV      R0,R9
   \   00000074   0x.... 0x....      BL       _usb_khci_next_setup_token_prep
   \   00000078   0xE006             B.N      ??CrossCallReturnLabel_11
   1882                  }
   1883                  else
   1884                  {
   1885                      usb_hal_khci_bdt_set_control( (uint32_t)bdt, ep_num, USB_RECV, state_ptr->ep_info[ep_num].rx_buf_odd,
   1886                                           USB_LONG_LE_TO_HOST((uint32_t)(USB_BD_BC(state_ptr->ep_info[ep_num].max_packet_size)| USB_BD_DTS | USB_BD_DATA01(0))));
   \                     ??usb_dci_khci_unstall_endpoint_1: (+1)
   \   0000007A   0x6860             LDR      R0,[R4, #+4]
   \   0000007C   0x7AF9             LDRB     R1,[R7, #+11]
   \   0000007E   0x.... 0x....      BL       ?Subroutine2
   1887                  }
   1888              }
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000082   0x8839             LDRH     R1,[R7, #+0]
   \   00000084   0x.... 0x....      BL       ?Subroutine6
   1889          
   1890              usb_hal_khci_clr_token_busy(state_ptr->usbRegBase);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000088   0x.... 0x....      BL       ??Subroutine4_0
   1891              return USB_OK;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000008C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1892          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x0A40             LSRS     R0,R0,#+9
   \   00000002   0xEA48 0x2040      ORR      R0,R8,R0, LSL #+9
   \   00000006   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000000A   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \   0000000E   0x4770             BX       LR
   1893          
   1894          /**************************************************************************//*!*
   1895          * @name  : usb_dci_khci_cancel
   1896          * @brief : Cancels all pending transfers on an endpoint.
   1897          * @param handle: Handle to USB Device.
   1898          * @param ep_num: End Point Number.
   1899          * @param direction: USB_SEND or USB_RECV.
   1900          * @return      :  USB_OK or error code
   1901          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1902          usb_status usb_dci_khci_cancel
   1903          (
   1904               /*[IN]*/
   1905              usb_device_handle handle,
   1906              /*[IN]*/
   1907              uint8_t ep_num, 
   1908              /*[IN]*/
   1909              uint8_t direction 
   1910          )
   1911          {
   \                     usb_dci_khci_cancel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1912              usb_event_struct_t event;
   1913              xd_struct_t*     xd_ptr = NULL;
   1914              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1915          
   1916              if (direction == USB_RECV)
   \   00000006   0x2014             MOVS     R0,#+20
   \   00000008   0xB085             SUB      SP,SP,#+20
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0xFB10 0x6004      SMLABB   R0,R0,R4,R6
   \   00000010   0xB91D             CBNZ.N   R5,??usb_dci_khci_cancel_0
   1917              {
   1918                  xd_ptr = state_ptr->ep_info[ep_num].recv_xd;
   \   00000012   0x6B47             LDR      R7,[R0, #+52]
   1919                  state_ptr->ep_info[ep_num].recv_xd = NULL;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6341             STR      R1,[R0, #+52]
   \   00000018   0xE002             B.N      ??usb_dci_khci_cancel_1
   1920              }
   1921              else
   1922              {
   1923                  xd_ptr = state_ptr->ep_info[ep_num].send_xd;
   \                     ??usb_dci_khci_cancel_0: (+1)
   \   0000001A   0x6B07             LDR      R7,[R0, #+48]
   1924                  state_ptr->ep_info[ep_num].send_xd = NULL;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6301             STR      R1,[R0, #+48]
   1925              }
   1926              if (xd_ptr != NULL)
   \                     ??usb_dci_khci_cancel_1: (+1)
   \   00000020   0xB1C7             CBZ.N    R7,??usb_dci_khci_cancel_2
   1927              {
   1928                  usb_dci_khci_free_xd(handle, xd_ptr);
   \   00000022   0x4639             MOV      R1,R7
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       usb_dci_khci_free_xd
   1929                  event.len = 0xFFFFFFFF;
   \   0000002A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000002E   0x9002             STR      R0,[SP, #+8]
   1930                  event.buffer_ptr = xd_ptr->wstartaddress;
   1931                  event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
   1932                  event.ep_num = ep_num;
   1933                  event.setup = FALSE;
   1934                  event.direction = direction;
   1935                  _usb_device_call_service(ep_num,&event);
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x6878             LDR      R0,[R7, #+4]
   \   00000034   0x9001             STR      R0,[SP, #+4]
   \   00000036   0x6870             LDR      R0,[R6, #+4]
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0xF88D 0x400C      STRB     R4,[SP, #+12]
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF88D 0x000E      STRB     R0,[SP, #+14]
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0xBF18             IT       NE 
   \   00000048   0x2001             MOVNE    R0,#+1
   \   0000004A   0xF88D 0x000F      STRB     R0,[SP, #+15]
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _usb_device_call_service
   1936              }
   1937          #if 0
   1938              if (direction)
   1939              {
   1940                  tempQueue = &state_ptr->ep_info[ep_num].xd_queue_send;
   1941              }
   1942              else
   1943              {
   1944                  tempQueue = &state_ptr->ep_info[ep_num].xd_queue_recv;
   1945              }    
   1946          
   1947              /* Empty the queue and add the XD release stucture to the Free list*/
   1948              do
   1949              {
   1950                  USB_XD_QUEUE_DEQUEUE(tempQueue, &xd_temp_ptr);
   1951                  
   1952                  if (xd_temp_ptr)
   1953                  {
   1954                      xd_temp_ptr->bstatus = USB_STATUS_IDLE;
   1955                      event.len = 0xFFFFFFFF;
   1956                      event.buffer_ptr = xd_temp_ptr->wstartaddress;
   1957                      event.handle = (usb_device_handle)state_ptr->upper_layer_handle;
   1958                      event.ep_num = ep_num;
   1959                      event.setup = FALSE;
   1960                      event.direction = direction;
   1961                      _usb_khci_free_XD(state_ptr, xd_temp_ptr);
   1962                      _usb_device_call_service(ep_num,&event);
   1963                  }  
   1964              }
   1965              while (xd_temp_ptr);
   1966          #endif
   1967              return USB_OK;
   \                     ??usb_dci_khci_cancel_2: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xB005             ADD      SP,SP,#+20
   \   00000058   0xBDF0             POP      {R4-R7,PC}       ;; return
   1968          }
   1969          
   1970          /**************************************************************************//*!*
   1971          * @name  : usb_dci_khci_set_addr
   1972          * @brief       : Set device address.
   1973          * @param handle : Device handle.
   1974          * @param addr :   Address to be set into Device Address register.
   1975          * @return     :   Returns USB_OK or error code.
   1976          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1977          usb_status usb_dci_khci_set_addr
   1978          (
   1979               /*[IN]*/
   1980              usb_device_handle handle, 
   1981              /*[IN]*/
   1982              uint8_t addr
   1983          )
   1984          {
   1985              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   1986              //volatile USB_MemMapPtr usb_ptr;
   1987          
   1988              /* Update USB address in Device registers. This 7-bit value
   1989                * defines the USB address that the USB Module decodes
   1990                * in device mode
   1991                */
   1992              usb_hal_khci_set_device_addr(state_ptr->usbRegBase, addr);
   \                     usb_dci_khci_set_addr: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable20_14  ;; 0x40072098
   \   00000002   0x7813             LDRB     R3,[R2, #+0]
   \   00000004   0xF003 0x0380      AND      R3,R3,#0x80
   \   00000008   0x430B             ORRS     R3,R1,R3
   1993                
   1994                /* Update the USB device address in Device Info Strucutre for
   1995                * Future Referances.
   1996                */
   1997              state_ptr->device_address = addr;
   \   0000000A   0x301C             ADDS     R0,R0,#+28
   \   0000000C   0x7013             STRB     R3,[R2, #+0]
   \   0000000E   0x73C1             STRB     R1,[R0, #+15]
   1998                /* Set the Device Start as Address Asigned State.*/
   1999              state_ptr->usb_state = USB_STATE_ADDRESS;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x8001             STRH     R1,[R0, #+0]
   2000              
   2001              return USB_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   2002          }
   2003          
   2004          /**************************************************************************//*!*
   2005          * @name : usb_dci_khci_shutdown
   2006          * @brief      : Shuts down the usbfs Device Controller
   2007          *                   Note: There is no function in MQX to uninstall ISR.
   2008          *                         Hence ISR is not Uninstalled here.However, installing
   2009          *                         ISR twice will not have any negative impact.
   2010          * @param handle : Device handle.
   2011          * @return     :   Returns USB_OK or error code.
   2012          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2013          usb_status usb_dci_khci_shutdown
   2014          (
   2015               /*[IN]*/
   2016              usb_device_handle handle 
   2017          )
   2018          {
   \                     usb_dci_khci_shutdown: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2019          #ifdef USBCFG_OTG
   2020              usb_otg_state_struct_t *   usb_otg_struct_ptr = (usb_otg_state_struct_t *)g_usb_otg_handle;
   2021              usb_otg_status_t *  otg_status_ptr = &usb_otg_struct_ptr->otg_status;
   2022          #endif    
   2023              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   2024          
   2025              /* Reset the Control Register */
   2026              //usb_hal_khci_reset_controller(handle->usbRegBase);/* disables the USB MODULE */
   2027          
   2028              usb_hal_khci_disable_interrupts(state_ptr->usbRegBase,0xFF);
   \   00000002   0x....             LDR.N    R1,??DataTable20_15  ;; 0x40072084
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x700A             STRB     R2,[R1, #+0]
   2029              usb_hal_khci_set_device_addr(state_ptr->usbRegBase,0);
   \   0000000A   0x7D0A             LDRB     R2,[R1, #+20]
   \   0000000C   0xF002 0x0280      AND      R2,R2,#0x80
   \   00000010   0x750A             STRB     R2,[R1, #+20]
   2030          
   2031              usb_hal_khci_clear_control_register(state_ptr->usbRegBase) ; 
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x740A             STRB     R2,[R1, #+16]
   2032          
   2033              usb_hal_khci_enable_pull_down(state_ptr->usbRegBase);
   \   00000016   0x....             LDR.N    R1,??DataTable20_13  ;; 0x40072100
   \   00000018   0x780A             LDRB     R2,[R1, #+0]
   \   0000001A   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000001E   0x700A             STRB     R2,[R1, #+0]
   2034              usb_hal_khci_set_suspend(state_ptr->usbRegBase);
   \   00000020   0x780A             LDRB     R2,[R1, #+0]
   \   00000022   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000026   0x700A             STRB     R2,[R1, #+0]
   2035          
   2036              state_ptr->usb_state = USB_STATE_UNKNOWN;
   \   00000028   0x21FF             MOVS     R1,#+255
   \   0000002A   0x8381             STRH     R1,[R0, #+28]
   2037              OS_Mutex_destroy(state_ptr->mutex);
   \   0000002C   0xF8D0 0x00A8      LDR      R0,[R0, #+168]
   \   00000030   0x.... 0x....      BL       OS_Mutex_destroy
   2038              
   2039          #if (OS_ADAPTER_ACTIVE_OS == OS_ADAPTER_MQX)
   2040              if (NULL != g_khci_data_ptr)
   2041              {
   2042                  OS_Mem_free(g_khci_data_ptr);
   2043                  g_khci_data_ptr = NULL;
   2044              }
   2045          #endif
   2046          #ifdef USBCFG_OTG
   2047              otg_status_ptr->active_stack = USB_ACTIVE_STACK_NONE;
   2048              usb_otg_struct_ptr->dev_inst_ptr = NULL;
   2049          #endif
   2050              return USB_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD02             POP      {R1,PC}          ;; return
   2051          }
   2052          
   2053          #if USBCFG_DEV_ADVANCED_SUSPEND_RESUME
   2054          /**************************************************************************//*!*
   2055          * @name  : usb_dci_khci_assert_resume
   2056          * @brief : Resume signalling for remote wakeup
   2057          * @param handle: Handle to USB Device.
   2058          * @return      :  USB_OK or error code
   2059          ******************************************************************************/
   2060          usb_status usb_dci_khci_assert_resume
   2061          (
   2062               /*[IN]*/
   2063              usb_device_handle handle 
   2064          )
   2065          {
   2066              uint16_t delay_count;
   2067              //volatile USB_MemMapPtr usb_ptr;
   2068              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;
   2069             
   2070              /* clear resume FLAG*/
   2071              usb_hal_khci_clr_interrupt(handle->usbRegBase, INTR_RESUME);
   2072          
   2073              /* Disable RESUME Interrupt */
   2074          //    usb_ptr->INTEN &= ~USB_INTEN_RESUME_EN_MASK; //already done in RESUME interrupt
   2075          
   2076              /* continue processing */
   2077              usb_hal_khci_clr_token_busy(handle->usbRegBase);
   2078          
   2079              /* Start RESUME signaling and make SUSPEND bit 0*/
   2080              usb_hal_khci_start_resume(handle->usbRegBase);
   2081          
   2082          
   2083              /* Set RESUME line for 1-15 ms*/
   2084              delay_count = ASSERT_RESUME_DELAY_COUNT;
   2085              do
   2086              {
   2087                  delay_count--;
   2088              } while (delay_count);
   2089          
   2090              /* Stop RESUME signalling */
   2091              usb_hal_khci_stop_resume(handle->usbRegBase);
   2092          
   2093              return USB_OK;
   2094          }
   2095          #endif
   2096          
   2097          /**************************************************************************//*!*
   2098          * @name : usb_dci_khci_get_endpoint_status
   2099          * @brief : Get Endpoint Transfer Status
   2100          * @param handle: Handle to USB Device.
   2101          * @param component: End Point Number.
   2102          * @param endp_status: Variable containig endpint status..
   2103          * @return      :  USB_OK or error code
   2104          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2105          usb_status usb_dci_khci_get_endpoint_status
   2106          (
   2107               /*[IN]*/
   2108              usb_device_handle handle,
   2109               /*[IN]*/
   2110              uint8_t component,
   2111              /*[OUT]*/
   2112              uint16_t* endp_status
   2113          )
   2114          {
   2115              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*)handle;       
   2116          
   2117              *endp_status = state_ptr->ep_info[component & USB_STATUS_ENDPOINT_NUMBER_MASK].endpoint_status;
   \                     usb_dci_khci_get_endpoint_status: (+1)
   \   00000000   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000004   0x2314             MOVS     R3,#+20
   \   00000006   0xFB13 0x0001      SMLABB   R0,R3,R1,R0
   \   0000000A   0xF890 0x003A      LDRB     R0,[R0, #+58]
   \   0000000E   0x8010             STRH     R0,[R2, #+0]
   2118              return USB_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   2119          }
   2120          
   2121          /**************************************************************************//*!*
   2122          * @name  : usb_dci_khci_set_endpoint_status
   2123          * @brief   : Set Endpoint Transfer Status
   2124          * @param handle: Handle to USB Device.
   2125          * @param component: End Point Number.
   2126          * @param setting: Variable containing new settings..
   2127          * @return      :  USB_OK or error code
   2128          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2129          usb_status usb_dci_khci_set_endpoint_status
   2130          (
   2131               /*[IN]*/
   2132              usb_device_handle handle,
   2133               /*[IN]*/
   2134              uint8_t component,
   2135               /*[IN]*/
   2136              uint16_t setting
   2137          )
   2138          {
   \                     usb_dci_khci_set_endpoint_status: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2139              usb_khci_dev_state_struct_t* state_ptr = (usb_khci_dev_state_struct_t*) handle;
   2140              usb_status error = USBERR_ERROR;/* initializing */
   2141              uint8_t ep_num = (uint8_t)(component & USB_STATUS_ENDPOINT_NUMBER_MASK);
   \   00000002   0xF001 0x040F      AND      R4,R1,#0xF
   2142              /* direction is in most significant bit */
   2143              uint8_t direction = (uint8_t)((component>>COMPONENT_PREPARE_SHIFT) & 0x01);
   2144              
   2145              state_ptr->ep_info[ep_num].endpoint_status = setting;
   \   00000006   0x2514             MOVS     R5,#+20
   \   00000008   0x23FF             MOVS     R3,#+255
   \   0000000A   0xFB15 0x0504      SMLABB   R5,R5,R4,R0
   2146              
   2147              /* check if the setting was to halt endpoint or unhalt it*/
   2148              if (setting == USB_STATUS_STALLED)
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xF805 0x2F3A      STRB     R2,[R5, #+58]!
   \   00000014   0xD104             BNE.N    ??usb_dci_khci_set_endpoint_status_0
   2149              {   /* stall the endpoint */
   2150                  error = usb_dci_khci_stall_endpoint(handle,ep_num,direction);
   \   00000016   0x09CA             LSRS     R2,R1,#+7
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x.... 0x....      BL       usb_dci_khci_stall_endpoint
   \   0000001E   0xE006             B.N      ??usb_dci_khci_set_endpoint_status_1
   2151              }
   2152              else if ((setting == USB_STATUS_IDLE) && (state_ptr->ep_info[ep_num].stall_flag))
   \                     ??usb_dci_khci_set_endpoint_status_0: (+1)
   \   00000020   0xB932             CBNZ.N   R2,??usb_dci_khci_set_endpoint_status_2
   \   00000022   0x7869             LDRB     R1,[R5, #+1]
   \   00000024   0xB121             CBZ.N    R1,??usb_dci_khci_set_endpoint_status_2
   2153              {
   2154                  /* unstall the endpoint*/
   2155                  /* need to update the direction here for unstalling
   2156                     (as it was not passed from above layers for unstall because the
   2157                     STAT register doesn't get updated in STALL ISR and we need to unstall
   2158                     directly from STALL_SERVICE for CONTROL ENDPOINT. Therefore, this
   2159                     method of unstall was employed to make the structure generic)*/
   2160                  direction = state_ptr->ep_info[ep_num].direction;
   2161                  error = usb_dci_khci_unstall_endpoint(handle,ep_num,direction);
   \   00000026   0x796A             LDRB     R2,[R5, #+5]
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x.... 0x....      BL       usb_dci_khci_unstall_endpoint
   \                     ??usb_dci_khci_set_endpoint_status_1: (+1)
   \   0000002E   0x4603             MOV      R3,R0
   2162              }
   2163          
   2164              return error;
   \                     ??usb_dci_khci_set_endpoint_status_2: (+1)
   \   00000030   0x4618             MOV      R0,R3
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2165          }
   2166          
   2167          
   2168          /*FUNCTION*----------------------------------------------------------------
   2169          * 
   2170          * Function Name  : usb_dci_khci_set_status
   2171          * Returned Value : USB_OK or error code
   2172          * Comments       :
   2173          *     Provides API to set internal state
   2174          * 
   2175          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   2176          usb_status usb_dci_khci_set_status
   2177             (
   2178                /* [IN] Handle to the usb device */
   2179                usb_device_handle   handle,
   2180                
   2181                /* [IN] What to set the error of */
   2182                uint8_t               component,
   2183                
   2184                /* [IN] What to set the error to */
   2185                uint16_t              setting
   2186             )
   2187          { 
   \                     usb_dci_khci_set_status: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2188              usb_khci_dev_state_struct_t* usb_dev_ptr;
   2189              uint8_t error = USB_OK;
   2190            
   2191              usb_dev_ptr = (usb_khci_dev_state_struct_t*)handle;
   2192              OS_Mutex_lock(usb_dev_ptr->mutex);
   \   00000006   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x.... 0x....      BL       OS_Mutex_lock
   2193              
   2194              switch (component) 
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000016   0xD007             BEQ.N    ??usb_dci_khci_set_status_0
   \   00000018   0x2D04             CMP      R5,#+4
   \   0000001A   0xD007             BEQ.N    ??usb_dci_khci_set_status_1
   \   0000001C   0x2D05             CMP      R5,#+5
   \   0000001E   0xD007             BEQ.N    ??usb_dci_khci_set_status_2
   \   00000020   0x2D06             CMP      R5,#+6
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x8046             STRHEQ   R6,[R0, #+2]
   2195              {
   2196                  case USB_STATUS_DEVICE_STATE:
   2197                      usb_dev_ptr->usb_state = setting;
   2198                      break;
   2199                  case USB_STATUS_DEVICE:
   2200                      usb_dev_ptr->usb_device_status = setting;
   \   00000026   0xE004             B.N      ??usb_dci_khci_set_status_3
   \                     ??usb_dci_khci_set_status_0: (+1)
   \   00000028   0x8006             STRH     R6,[R0, #+0]
   \   0000002A   0xE002             B.N      ??usb_dci_khci_set_status_3
   2201                      break;
   2202                  case USB_STATUS_INTERFACE:
   2203                      break;
   2204                  case USB_STATUS_CURRENT_CONFIG:
   2205                      usb_dev_ptr->usb_curr_config = setting;
   \                     ??usb_dci_khci_set_status_1: (+1)
   \   0000002C   0x8146             STRH     R6,[R0, #+10]
   2206                      break;
   \   0000002E   0xE000             B.N      ??usb_dci_khci_set_status_3
   2207                  case USB_STATUS_SOF_COUNT:
   2208                      usb_dev_ptr->usb_sof_count = setting;
   \                     ??usb_dci_khci_set_status_2: (+1)
   \   00000030   0x8086             STRH     R6,[R0, #+4]
   2209                      break;
   2210          #ifdef USBCFG_OTG
   2211                  case USB_STATUS_OTG:
   2212                      usb_dev_ptr->usb_otg_status = setting;
   2213                      break;
   2214          #endif  
   2215                  default:
   2216                      
   2217                  break;
   2218             }/* Endswitch */
   2219          
   2220             OS_Mutex_unlock(usb_dev_ptr->mutex);
   \                     ??usb_dci_khci_set_status_3: (+1)
   \   00000032   0x....             B.N      ?Subroutine1
   2221             return error;   
   2222          } /* EndBody */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \   00000004   0x.... 0x....      BL       OS_Mutex_unlock
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD70             POP      {R4-R6,PC}       ;; return
   2223          
   2224          /*FUNCTION*----------------------------------------------------------------
   2225          * 
   2226          * Function Name  : usb_dci_khci_get_status
   2227          * Returned Value : USB_OK or error code
   2228          * Comments       :
   2229          *     Provides API to access the USB internal state.
   2230          * 
   2231          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
   2232          usb_status usb_dci_khci_get_status
   2233          (
   2234              /* [IN] Handle to the USB device */
   2235              usb_device_handle   handle,
   2236          
   2237              /* [IN] What to get the error of */
   2238              uint8_t              component,
   2239          
   2240              /* [OUT] The requested error */
   2241              uint16_t*            error
   2242          )
   2243          {
   \                     usb_dci_khci_get_status: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   2244              usb_khci_dev_state_struct_t* usb_dev_ptr;
   2245          
   2246              usb_dev_ptr = (usb_khci_dev_state_struct_t*)handle;
   2247             
   2248              OS_Mutex_lock(usb_dev_ptr->mutex);
   \   00000006   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x.... 0x....      BL       OS_Mutex_lock
   2249              switch (component) 
   \   00000010   0x1E76             SUBS     R6,R6,#+1
   \   00000012   0x2E05             CMP      R6,#+5
   \   00000014   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000018   0xD80E             BHI.N    ??usb_dci_khci_get_status_1
   \   0000001A   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??usb_dci_khci_get_status_0:
   \   0000001E   0x03 0x0D          DC8      0x3,0xD,0x7,0x9
   \              0x07 0x09    
   \   00000022   0x0B 0x05          DC8      0xB,0x5
   2250              {
   2251                  case USB_STATUS_DEVICE_STATE:
   2252                      *error = usb_dev_ptr->usb_state;
   \                     ??usb_dci_khci_get_status_2: (+1)
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0xE006             B.N      ??usb_dci_khci_get_status_3
   2253                      break;
   2254          
   2255                  case USB_STATUS_DEVICE:
   2256                      *error = usb_dev_ptr->usb_device_status;
   \                     ??usb_dci_khci_get_status_4: (+1)
   \   00000028   0x8840             LDRH     R0,[R0, #+2]
   \   0000002A   0xE004             B.N      ??usb_dci_khci_get_status_3
   2257                      break;
   2258          
   2259                  case USB_STATUS_INTERFACE:
   2260                      break;
   2261          
   2262                  case USB_STATUS_ADDRESS:
   2263                      *error = usb_dev_ptr->device_address;
   \                     ??usb_dci_khci_get_status_5: (+1)
   \   0000002C   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000002E   0xE002             B.N      ??usb_dci_khci_get_status_3
   2264                      break;
   2265          
   2266                  case USB_STATUS_CURRENT_CONFIG:
   2267                      *error = usb_dev_ptr->usb_curr_config;
   \                     ??usb_dci_khci_get_status_6: (+1)
   \   00000030   0x8940             LDRH     R0,[R0, #+10]
   \   00000032   0xE000             B.N      ??usb_dci_khci_get_status_3
   2268                      break;
   2269                  case USB_STATUS_SOF_COUNT:
   2270                      *error = usb_dev_ptr->usb_sof_count;
   \                     ??usb_dci_khci_get_status_7: (+1)
   \   00000034   0x8880             LDRH     R0,[R0, #+4]
   \                     ??usb_dci_khci_get_status_3: (+1)
   \   00000036   0x8028             STRH     R0,[R5, #+0]
   2271                      break;
   2272          #ifdef USBCFG_OTG
   2273                  case USB_STATUS_OTG:
   2274                      *error = usb_dev_ptr->usb_otg_status;
   2275                      break;
   2276          #endif 
   2277                  default:    
   2278                      break;
   2279             } /* Endswitch */
   2280             OS_Mutex_unlock(usb_dev_ptr->mutex);
   \                     ??usb_dci_khci_get_status_1: (+1)
   \   00000038                      REQUIRE ?Subroutine1
   \   00000038                      ;; // Fall through to label ?Subroutine1
   2281             return USB_OK;   
   2282          }
   2283          

   \                                 In section .text, align 2, keep-with-next
   2284          usb_status usb_dci_khci_reset
   2285          (
   2286              /* [IN] Handle to the USB device */
   2287              usb_device_handle   handle
   2288          )
   2289          {
   \                     usb_dci_khci_reset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2290              usb_khci_dev_state_struct_t* usb_dev_ptr;
   2291              uint8_t                      cnt=0;
   \   00000004   0x2500             MOVS     R5,#+0
   2292                  
   2293              usb_dev_ptr = (usb_khci_dev_state_struct_t*)handle;
   2294              
   2295              /* De-Init All the End Point.  */
   2296              for (cnt = 0; cnt < USBCFG_DEV_MAX_ENDPOINTS; cnt++)
   2297              {
   2298                  usb_dci_khci_deinit_endpoint(usb_dev_ptr,cnt,USB_RECV);
   \                     ??usb_dci_khci_reset_0: (+1)
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       usb_dci_khci_deinit_endpoint
   2299                  usb_dci_khci_deinit_endpoint(usb_dev_ptr,cnt,USB_SEND);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       usb_dci_khci_deinit_endpoint
   2300              }
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \   0000001C   0x2D06             CMP      R5,#+6
   \   0000001E   0xDBF2             BLT.N    ??usb_dci_khci_reset_0
   2301          
   2302              /* Re-Initialize All the end point */
   2303              _usb_khci_reset_ep_state((usb_khci_dev_state_struct_t*)usb_dev_ptr);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _usb_khci_reset_ep_state
   2304              usb_dci_khci_init_xd((usb_device_handle)usb_dev_ptr);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       usb_dci_khci_init_xd
   2305          
   2306              return USB_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2307          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x400720C0         DC32     0x400720c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     g_khci_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     g_zero_pkt_send

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x00080088         DC32     0x80088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x40072080         DC32     0x40072080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x400720A0         DC32     0x400720a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     g_khci_dev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     _usb_khci_dev_swap_buf_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     g_khci_data+0x210

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x4007201C         DC32     0x4007201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     _usb_khci_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x400720B0         DC32     0x400720b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x40072094         DC32     0x40072094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x40072100         DC32     0x40072100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x40072098         DC32     0x40072098

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x40072084         DC32     0x40072084
   2308          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   _usb_khci_ep_read
        24   -> sys_lock
        24   -> sys_unlock
       8   _usb_khci_ep_write
      32   _usb_khci_isr
        32   -> _usb_device_call_service
        32   -> _usb_khci_service_sof_token_intr
        32   -> _usb_khci_service_stall_intr
        32   -> _usb_khci_service_tk_dne_intr
      16   _usb_khci_next_setup_token_prep
        16   -> usb_dci_khci_get_xd
      20   _usb_khci_reset_ep_state
       0   _usb_khci_service_sof_token_intr
      16   _usb_khci_service_stall_intr
         0   -> _usb_khci_next_setup_token_prep
        16   -> usb_hal_khci_endpoint_clr_stall
      64   _usb_khci_service_tk_dne_intr
        64   -> _usb_device_call_service
        64   -> _usb_khci_next_setup_token_prep
        64   -> memcpy
        64   -> usb_dci_khci_cancel
        64   -> usb_dci_khci_free_xd
        64   -> usb_dci_khci_recv
        64   -> usb_dci_khci_send
        64   -> usb_device_send_data
      40   usb_dci_khci_cancel
        40   -> _usb_device_call_service
        40   -> usb_dci_khci_free_xd
      16   usb_dci_khci_deinit_endpoint
        16   -> usb_dci_khci_cancel
      16   usb_dci_khci_free_xd
        16   -> sys_lock
         0   -> sys_unlock
       0   usb_dci_khci_get_endpoint_status
      16   usb_dci_khci_get_status
        16   -> OS_Mutex_lock
        16   -> OS_Mutex_unlock
      16   usb_dci_khci_get_xd
        16   -> sys_lock
        16   -> sys_unlock
      16   usb_dci_khci_init
        16   -> _usb_khci_reset_ep_state
        16   -> bm_install_isr
        16   -> soc_get_usb_base_address
        16   -> soc_get_usb_vector_number
      16   usb_dci_khci_init_endpoint
        16   -> _usb_khci_next_setup_token_prep
        16   -> usb_hal_khci_endpoint_enable_handshake
        16   -> usb_hal_khci_endpoint_set_direction
       0   usb_dci_khci_init_xd
       0   usb_dci_khci_postinit
      16   usb_dci_khci_preinit
        16   -> OS_Mutex_create
        16   -> usb_dci_khci_init_xd
      24   usb_dci_khci_recv
        24   -> _usb_khci_ep_read
        24   -> _usb_khci_next_setup_token_prep
        24   -> usb_dci_khci_free_xd
      16   usb_dci_khci_reset
        16   -> _usb_khci_reset_ep_state
        16   -> usb_dci_khci_deinit_endpoint
        16   -> usb_dci_khci_init_xd
      32   usb_dci_khci_send
        32   -> _usb_khci_ep_write
        32   -> usb_dci_khci_free_xd
       0   usb_dci_khci_set_addr
      16   usb_dci_khci_set_endpoint_status
        16   -> usb_dci_khci_stall_endpoint
        16   -> usb_dci_khci_unstall_endpoint
      16   usb_dci_khci_set_status
        16   -> OS_Mutex_lock
        16   -> OS_Mutex_unlock
       8   usb_dci_khci_shutdown
         8   -> OS_Mutex_destroy
      16   usb_dci_khci_stall_endpoint
        16   -> usb_dci_khci_cancel
      32   usb_dci_khci_unstall_endpoint
        32   -> _usb_khci_next_setup_token_prep
        32   -> usb_hal_khci_endpoint_clr_stall
        32   -> usb_hal_khci_endpoint_enable_handshake
        32   -> usb_hal_khci_endpoint_set_direction
       0   usb_hal_khci_endpoint_clr_stall
       0   usb_hal_khci_endpoint_enable_handshake
       0   usb_hal_khci_endpoint_set_direction


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      14  ?Subroutine0
      12  ?Subroutine1
      16  ?Subroutine2
      10  ?Subroutine3
      16  ?Subroutine4
      14  ?Subroutine5
      12  ?Subroutine6
       4  _usb_khci_dev_swap_buf_ptr
      88  _usb_khci_ep_read
      96  _usb_khci_ep_write
     108  _usb_khci_isr
     102  _usb_khci_next_setup_token_prep
     146  _usb_khci_reset_ep_state
      28  _usb_khci_service_sof_token_intr
     130  _usb_khci_service_stall_intr
     442  _usb_khci_service_tk_dne_intr
     928  g_khci_data
     176  g_khci_dev
       8  g_zero_pkt_send
          bdt
      90  usb_dci_khci_cancel
      76  usb_dci_khci_deinit_endpoint
      42  usb_dci_khci_free_xd
      20  usb_dci_khci_get_endpoint_status
      56  usb_dci_khci_get_status
      52  usb_dci_khci_get_xd
     104  usb_dci_khci_init
     194  usb_dci_khci_init_endpoint
      46  usb_dci_khci_init_xd
      40  usb_dci_khci_postinit
      42  usb_dci_khci_preinit
     150  usb_dci_khci_recv
      48  usb_dci_khci_reset
      74  usb_dci_khci_send
      24  usb_dci_khci_set_addr
      52  usb_dci_khci_set_endpoint_status
      52  usb_dci_khci_set_status
      56  usb_dci_khci_shutdown
      88  usb_dci_khci_stall_endpoint
     144  usb_dci_khci_unstall_endpoint
      20  usb_hal_khci_endpoint_clr_stall
      14  usb_hal_khci_endpoint_enable_handshake
      12  usb_hal_khci_endpoint_set_direction

 
   188 bytes in section .bss
   928 bytes in section .noinit
 2 794 bytes in section .text
 
 2 794 bytes of CODE memory
 1 116 bytes of DATA memory

Errors: none
Warnings: none
