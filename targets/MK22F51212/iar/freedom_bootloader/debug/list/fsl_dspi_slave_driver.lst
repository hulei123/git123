###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:57
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\dspi\src\fsl_dspi_slave_driver.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\dspi\src\fsl_dspi_slave_driver.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\fsl_dspi_slave_driver.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\fsl_dspi_slave_driver.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\dspi\src\fsl_dspi_slave_driver.c
      1          /*
      2           * Copyright (c) 2013-2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_platform_common.h" // needed for NULL
     32          #include "bootloader/bl_peripheral_interface.h"
     33          #include "bootloader/bl_irq_common.h"
     34          #include "device/fsl_device_registers.h"
     35          #include "dspi/fsl_dspi_slave_driver.h"
     36          #include "dspi/hal/fsl_dspi_hal.h"
     37          #include "fsl_dspi_shared_irqs.h"
     38          #include "bootloader_common.h"
     39          #include <string.h>
     40          #include "utilities/fsl_assert.h"
     41          
     42          
     43          #if BL_CONFIG_DSPI
     44          
     45          /*******************************************************************************
     46           * Definitions
     47           ******************************************************************************/
     48          
     49          /*! SPI slave constants */
     50          enum _spi_slave_constants
     51          {
     52              kEmptyChar = 0,                        /*!< Empty character */
     53          };
     54          
     55          /*******************************************************************************
     56           * Variables
     57           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     58          const uint32_t g_dspiBaseAddr[] = SPI_BASE_ADDRS;
   \                     g_dspiBaseAddr:
   \   00000000   0x4002C000         DC32 1073922048, 1073926144
   \              0x4002D000   
     59          
     60          /*******************************************************************************
     61           * Prototypes
     62           ******************************************************************************/
     63          
     64          /*******************************************************************************
     65           * Code
     66           ******************************************************************************/
     67          
     68          /*!
     69           * @brief DSPI Slave Generic IRQ handler.
     70           *
     71           * This handler uses the callbacks stored in the dspi_slave_state_t struct to transfer data
     72           * either from the data source or to the data sink functions.
     73           * This is not a public API as it is called whenever an interrupt occurs.
     74           */

   \                                 In section .text, align 2, keep-with-next
     75          void dspi_slave_irq_handler(void * state)
     76          {
   \                     dspi_slave_irq_handler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
     77              /* instantiate local variable of type dspi_slave_state_t and equate it to the
     78               * pointer to state
     79               */
     80              dspi_slave_state_t * dspiState = (dspi_slave_state_t *)state;
     81          
     82              uint32_t instance = dspiState->instance;
   \   00000008   0xF8D4 0x8000      LDR      R8,[R4, #+0]
     83              uint32_t baseAddr = g_dspiBaseAddr[instance];
   \   0000000C   0x.... 0x....      ADR.W    R0,g_dspiBaseAddr
   \   00000010   0xF850 0x7028      LDR      R7,[R0, R8, LSL #+2]
     84          
     85              /* Get the callback pointers from the run-time state structure */
     86              dspi_slave_callbacks_t * callbacks = &dspiState->callbacks;
     87          
     88              /* catch tx fifo underflow conditions */
     89              if (dspi_hal_get_status_flag((SPI_Type *)baseAddr, kDspiTxFifoUnderflow))
   \   00000014   0x6AF8             LDR      R0,[R7, #+44]
   \   00000016   0x1D26             ADDS     R6,R4,#+4
   \   00000018   0x0100             LSLS     R0,R0,#+4
   \   0000001A   0xD52B             BPL.N    ??dspi_slave_irq_handler_0
     90              {
     91                  /* Report SPI slave  transmit underrun error */
     92                  if (callbacks->onError)
   \   0000001C   0x68B2             LDR      R2,[R6, #+8]
   \   0000001E   0x0010             MOVS     R0,R2
   \   00000020   0xD028             BEQ.N    ??dspi_slave_irq_handler_0
     93                  {
     94                      callbacks->onError(kStatus_DSPI_SlaveTxUnderrun, instance);
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0xF44F 0x7096      MOV      R0,#+300
   \   00000028   0x4790             BLX      R2
   \   0000002A   0xE023             B.N      ??dspi_slave_irq_handler_0
     95                  }
     96              }
     97          
     98              /* Fill the tx fifo, where the fifo can be 1 entry or more */
     99              while(dspi_hal_get_status_flag((SPI_Type *)baseAddr, kDspiTxFifoFillRequest))
    100              {
    101                  /* SPI transmit interrupt */
    102                  uint32_t sourceWord = kEmptyChar;
    103                  uint8_t sourceWordTemp;
    104          
    105                  /* get the first 8-bits of data */
    106                  callbacks->dataSource(&sourceWordTemp, instance);
   \                     ??dspi_slave_irq_handler_1: (+1)
   \   0000002C   0x.... 0x....      BL       ?Subroutine0
    107                  sourceWord = sourceWordTemp;
    108          
    109                  /* See if the bits/frame is greater than one byte */
    110                  if (dspiState->bitsPerFrame > 8)
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000030   0x6920             LDR      R0,[R4, #+16]
   \   00000032   0xF89D 0x5000      LDRB     R5,[SP, #+0]
   \   00000036   0x2809             CMP      R0,#+9
   \   00000038   0xD305             BCC.N    ??dspi_slave_irq_handler_2
    111                  {
    112                      callbacks->dataSource(&sourceWordTemp, instance);
   \   0000003A   0x.... 0x....      BL       ?Subroutine0
    113                      sourceWord |= (uint32_t)sourceWordTemp << 8U;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xEA45 0x2500      ORR      R5,R5,R0, LSL #+8
    114                  }
    115                  /* See if the bits/frame is greater than two bytes */
    116                  if (dspiState->bitsPerFrame > 16)
   \                     ??dspi_slave_irq_handler_2: (+1)
   \   00000046   0x6920             LDR      R0,[R4, #+16]
   \   00000048   0x2811             CMP      R0,#+17
   \   0000004A   0xD305             BCC.N    ??dspi_slave_irq_handler_3
    117                  {
    118                      callbacks->dataSource(&sourceWordTemp, instance);
   \   0000004C   0x.... 0x....      BL       ?Subroutine0
    119                      sourceWord |= (uint32_t)sourceWordTemp << 16U;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0xEA45 0x4500      ORR      R5,R5,R0, LSL #+16
    120                  }
    121                  /* See if the bits/frame is greater than three bytes */
    122                  if (dspiState->bitsPerFrame > 24)
   \                     ??dspi_slave_irq_handler_3: (+1)
   \   00000058   0x6920             LDR      R0,[R4, #+16]
   \   0000005A   0x2819             CMP      R0,#+25
   \   0000005C   0xD305             BCC.N    ??dspi_slave_irq_handler_4
    123                  {
    124                      callbacks->dataSource(&sourceWordTemp, instance);
   \   0000005E   0x.... 0x....      BL       ?Subroutine0
    125                      sourceWord |= (uint32_t)sourceWordTemp << 24U;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0xEA45 0x6500      ORR      R5,R5,R0, LSL #+24
    126                  }
    127          
    128                  /* Finally, write the data to the DSPI data register */
    129                  dspi_hal_write_data_slave_mode((SPI_Type *)baseAddr, sourceWord);
   \                     ??dspi_slave_irq_handler_4: (+1)
   \   0000006A   0x637D             STR      R5,[R7, #+52]
    130          
    131                  /* try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
    132                  dspi_hal_clear_status_flag((SPI_Type *)baseAddr, kDspiTxFifoFillRequest);
   \   0000006C   0x6AF8             LDR      R0,[R7, #+44]
   \   0000006E   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \   00000072   0x62F8             STR      R0,[R7, #+44]
    133              }
   \                     ??dspi_slave_irq_handler_0: (+1)
   \   00000074   0x6AF8             LDR      R0,[R7, #+44]
   \   00000076   0x0180             LSLS     R0,R0,#+6
   \   00000078   0xD4D8             BMI.N    ??dspi_slave_irq_handler_1
    134          
    135              /* Fill the rx fifo, where the fifo can be 1 entry or more */
    136              while (dspi_hal_get_status_flag((SPI_Type *)baseAddr, kDspiRxFifoDrainRequest))
   \                     ??dspi_slave_irq_handler_5: (+1)
   \   0000007A   0x6AF8             LDR      R0,[R7, #+44]
   \   0000007C   0x0380             LSLS     R0,R0,#+14
   \   0000007E   0xD520             BPL.N    ??dspi_slave_irq_handler_6
    137              {
    138                  /* SPI receive interrupt, read the data from the DSPI data register */
    139                  uint32_t readData = dspi_hal_read_data((SPI_Type *)baseAddr);
   \   00000080   0x6BBD             LDR      R5,[R7, #+56]
    140          
    141                  /* clear the rx fifo drain request, needed for non-DMA applications as this flag
    142                   * will remain set even if the rx fifo is empty. By manually clearing this flag, it
    143                   * either remain clear if no more data is in the fifo, or it will set if there is
    144                   * more data in the fifo.
    145                   */
    146                  dspi_hal_clear_status_flag((SPI_Type *)baseAddr, kDspiRxFifoDrainRequest);
   \   00000082   0x6AF8             LDR      R0,[R7, #+44]
   \   00000084   0xF440 0x3000      ORR      R0,R0,#0x20000
   \   00000088   0x62F8             STR      R0,[R7, #+44]
    147          
    148                  /* Sink the first 8-bits */
    149                  callbacks->dataSink((uint8_t)readData, instance);
   \   0000008A   0x4641             MOV      R1,R8
   \   0000008C   0x6872             LDR      R2,[R6, #+4]
   \   0000008E   0xB2E8             UXTB     R0,R5
   \   00000090   0x4790             BLX      R2
    150          
    151                  /* See if the bits/frame is greater than one byte */
    152                  if (dspiState->bitsPerFrame > 8)
   \   00000092   0x6920             LDR      R0,[R4, #+16]
   \   00000094   0x2809             CMP      R0,#+9
   \   00000096   0xD304             BCC.N    ??dspi_slave_irq_handler_7
    153                  {
    154                      /* Sink the next 8-bits */
    155                      callbacks->dataSink((uint8_t)(readData >> 8), instance);
   \   00000098   0x0428             LSLS     R0,R5,#+16
   \   0000009A   0x6872             LDR      R2,[R6, #+4]
   \   0000009C   0x4641             MOV      R1,R8
   \   0000009E   0x0E00             LSRS     R0,R0,#+24
   \   000000A0   0x4790             BLX      R2
    156                  }
    157                  /* See if the bits/frame is greater than two bytes */
    158                  if (dspiState->bitsPerFrame > 16)
   \                     ??dspi_slave_irq_handler_7: (+1)
   \   000000A2   0x6920             LDR      R0,[R4, #+16]
   \   000000A4   0x2811             CMP      R0,#+17
   \   000000A6   0xD304             BCC.N    ??dspi_slave_irq_handler_8
    159                  {
    160                      /* Sink the next 8-bits */
    161                      callbacks->dataSink((uint8_t)(readData >> 16), instance);
   \   000000A8   0x0228             LSLS     R0,R5,#+8
   \   000000AA   0x6872             LDR      R2,[R6, #+4]
   \   000000AC   0x4641             MOV      R1,R8
   \   000000AE   0x0E00             LSRS     R0,R0,#+24
   \   000000B0   0x4790             BLX      R2
    162                  }
    163                  /* See if the bits/frame is greater than three bytes */
    164                  if (dspiState->bitsPerFrame > 24)
   \                     ??dspi_slave_irq_handler_8: (+1)
   \   000000B2   0x6920             LDR      R0,[R4, #+16]
   \   000000B4   0x2819             CMP      R0,#+25
   \   000000B6   0xD3E0             BCC.N    ??dspi_slave_irq_handler_5
    165                  {
    166                      /* Sink the next 8-bits */
    167                      callbacks->dataSink((uint8_t)(readData >> 24), instance);
   \   000000B8   0x6872             LDR      R2,[R6, #+4]
   \   000000BA   0x4641             MOV      R1,R8
   \   000000BC   0x0E28             LSRS     R0,R5,#+24
   \   000000BE   0x4790             BLX      R2
   \   000000C0   0xE7DB             B.N      ??dspi_slave_irq_handler_5
    168                  }
    169              }
    170          }
   \                     ??dspi_slave_irq_handler_6: (+1)
   \   000000C2   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6832             LDR      R2,[R6, #+0]
   \   00000002   0x4641             MOV      R1,R8
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x4710             BX       R2
    171          
    172          /*FUNCTION**********************************************************************
    173           *
    174           * Function Name : dspi_slave_init
    175           * Description   : Initialize a DSPI instance for slave mode operation.
    176           * This function saves the callbacks to the run-time state structure for later use in the
    177           * interrupt handler. It also ungates the clock to the DSPI module, initializes the DSPI
    178           * for slave mode, enables the module and corresponding interrupts. Once initialized, the
    179           * DSPI module is configured in slave mode and ready to receive data from a SPI master. The
    180           * following is an example of how to set up the dspi_slave_state_t and the dspi_slave_user_config_t
    181           * parameters and how to call the dspi_slave_init function by passing in these parameters:
    182           *   dspi_slave_state_t dspiSlaveState; <- the user simply allocates memory for this struct
    183           *   dspi_slave_user_config_t slaveUserConfig;
    184           *   slaveUserConfig.callbacks.dataSink = data_sink; <- set to user implementation of function
    185           *   slaveUserConfig.callbacks.dataSource = data_source; <- set to user implementation of function
    186           *   slaveUserConfig.callbacks.onError = on_error; <- set to user implementation of function
    187           *   slaveUserConfig.dataConfig.bitsPerFrame = 16;
    188           *   slaveUserConfig.dataConfig.clkPhase = kDspiClockPhase_FirstEdge;
    189           *   slaveUserConfig.dataConfig.clkPolarity = kDspiClockPolarity_ActiveHigh;
    190           *   dspi_slave_init(slaveInstance, &slaveUserConfig, &dspiSlaveState);
    191           *
    192           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    193          status_t dspi_slave_init(uint32_t instance, const dspi_slave_user_config_t * slaveConfig,
    194                               dspi_slave_state_t * dspiState)
    195          {
   \                     dspi_slave_init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    196              assert(slaveConfig);
    197              assert(instance < SPI_INSTANCE_COUNT);
    198          
    199              uint32_t baseAddr = g_dspiBaseAddr[instance];
   \   00000004   0x.... 0x....      ADR.W    R0,g_dspiBaseAddr
   \   00000008   0xB085             SUB      SP,SP,#+20
   \   0000000A   0xF850 0x7024      LDR      R7,[R0, R4, LSL #+2]
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0x4616             MOV      R6,R2
    200              status_t errorCode = kStatus_Success;
    201          
    202              /* DSPI config struct in hal, fill out it's members below */
    203              dspi_slave_config_t dspiConfig;
    204          
    205              /* Clear the run-time state struct for this instance. */
    206              memset(dspiState, 0, sizeof(* dspiState));
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0x4630             MOV      R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memclr4
    207          
    208              /* Save the application info. */
    209              dspiState->callbacks = slaveConfig->callbacks;
   \   0000001A   0xCD0E             LDM      R5!,{R1-R3}
   \   0000001C   0x1D30             ADDS     R0,R6,#+4
   \   0000001E   0x3D0C             SUBS     R5,R5,#+12
   \   00000020   0xC00E             STM      R0!,{R1-R3}
    210          
    211              /* configure the run-time state struct with the instance number */
    212              dspiState->instance = instance;
   \   00000022   0x6034             STR      R4,[R6, #+0]
    213          
    214              /* configure the run-time state struct with the nubmer of bits/frame */
    215              dspiState->bitsPerFrame = slaveConfig->dataConfig.bitsPerFrame;
   \   00000024   0x68E8             LDR      R0,[R5, #+12]
   \   00000026   0x6130             STR      R0,[R6, #+16]
    216          
    217              /* Enable clock for DSPI */
    218              switch(instance)
   \   00000028   0x....             LDR.N    R0,??DataTable2  ;; 0x4004803c
   \   0000002A   0xB114             CBZ.N    R4,??dspi_slave_init_0
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD004             BEQ.N    ??dspi_slave_init_1
   \   00000030   0xE007             B.N      ??dspi_slave_init_2
    219              {
    220                  case 0:
    221                      SIM_SET_SCGC6(SIM, SIM_SCGC6_SPI0_MASK);
   \                     ??dspi_slave_init_0: (+1)
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000038   0xE002             B.N      ??dspi_slave_init_3
    222                      break;
    223          #if (SPI_INSTANCE_COUNT > 1U)
    224                  case 1:
    225                      SIM_SET_SCGC6(SIM, SIM_SCGC6_SPI1_MASK);
   \                     ??dspi_slave_init_1: (+1)
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \                     ??dspi_slave_init_3: (+1)
   \   00000040   0x6001             STR      R1,[R0, #+0]
    226                      break;
    227          #if (SPI_INSTANCE_COUNT > 2U)
    228                  case 2:
    229                      SIM_SET_SCGC3(SIM, SIM_SCGC3_SPI2_MASK);
    230                      break;
    231          #endif // (SPI_INSTANCE_COUNT > 2U)
    232          #endif // (SPI_INSTANCE_COUNT > 1U)
    233              }
    234          
    235              /* Reset the DSPI module */
    236              dspi_hal_reset((SPI_Type *)baseAddr);
   \                     ??dspi_slave_init_2: (+1)
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0x.... 0x....      BL       dspi_hal_reset
    237          
    238              /* Initialize the parameters of the hal DSPI config structure with desired data
    239               * members of the user config struct, then the hal init function will be called
    240               */
    241              dspiConfig.isEnabled = false;  /* disable the DSPI module while we're setting it up */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    242              dspiConfig.isTxFifoDisabled = false;  /* enable tx fifo */
   \   0000004E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    243              dspiConfig.isRxFifoDisabled = false;  /* enable rx fifo */
    244              /* data format field config */
    245              dspiConfig.dataConfig.bitsPerFrame = slaveConfig->dataConfig.bitsPerFrame;
    246              dspiConfig.dataConfig.clkPolarity = slaveConfig->dataConfig.clkPolarity;
    247              dspiConfig.dataConfig.clkPhase = slaveConfig->dataConfig.clkPhase;
    248          
    249              errorCode = dspi_hal_slave_init((SPI_Type *)baseAddr, &dspiConfig);
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x68E8             LDR      R0,[R5, #+12]
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x7C28             LDRB     R0,[R5, #+16]
   \   0000005A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   0000005E   0x7C68             LDRB     R0,[R5, #+17]
   \   00000060   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   00000064   0x4638             MOV      R0,R7
   \   00000066   0x.... 0x....      BL       dspi_hal_slave_init
    250              if (errorCode!= kStatus_Success)
   \   0000006A   0xBB68             CBNZ.N   R0,??dspi_slave_init_4
    251              {
    252                  return errorCode;  /* return immediately if there's a problem with the init */
    253              }
    254          
    255              /* DSPI system enable */
    256              dspi_hal_enable((SPI_Type *)baseAddr);
   \   0000006C   0x6838             LDR      R0,[R7, #+0]
   \   0000006E   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000072   0x6038             STR      R0,[R7, #+0]
    257          
    258              /* flush the fifos*/
    259              dspi_hal_flush_fifos((SPI_Type *)baseAddr, true, true);
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x.... 0x....      BL       dspi_hal_flush_fifos
    260          
    261              /* Configure IRQ state structure, so irq handler can point to the correct state structure */
    262              dspi_set_shared_irq_state(instance, dspiState, false);
   \   0000007E   0x....             LDR.N    R0,??DataTable2_1
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF800 0x1034      STRB     R1,[R0, R4, LSL #+3]
   \   00000086   0xEB00 0x00C4      ADD      R0,R0,R4, LSL #+3
    263          
    264              /* TX FIFO Fill Flag (TFFF) request enable*/
    265              dspi_hal_configure_interrupt((SPI_Type *)baseAddr, kDspiTxFifoFillRequest, true);
   \   0000008A   0x2201             MOVS     R2,#+1
   \   0000008C   0x6046             STR      R6,[R0, #+4]
   \   0000008E   0x2119             MOVS     R1,#+25
   \   00000090   0x4638             MOV      R0,R7
   \   00000092   0x.... 0x....      BL       dspi_hal_configure_interrupt
    266              /* RX FIFO Drain request: RFDF_RE to enable RFDF interrupt */
    267              dspi_hal_configure_interrupt((SPI_Type *)baseAddr, kDspiRxFifoDrainRequest, true);
   \   00000096   0x2201             MOVS     R2,#+1
   \   00000098   0x2111             MOVS     R1,#+17
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       dspi_hal_configure_interrupt
    268              /* TX FIFO underflow request enable*/
    269              dspi_hal_configure_interrupt((SPI_Type *)baseAddr, kDspiTxFifoUnderflow, true);
   \   000000A0   0x2201             MOVS     R2,#+1
   \   000000A2   0x211B             MOVS     R1,#+27
   \   000000A4   0x4638             MOV      R0,R7
   \   000000A6   0x.... 0x....      BL       dspi_hal_configure_interrupt
    270          
    271              /* Write 0 to tx shift register so a master will receive a known first word (0). */
    272              dspi_hal_write_data_slave_mode((SPI_Type *)baseAddr, 0);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x6378             STR      R0,[R7, #+52]
    273          
    274              /* Clear the Tx FIFO Fill Flag (TFFF) status bit
    275               * This should be done after writing the data to the PUSHR register
    276               */
    277              dspi_hal_clear_status_flag((SPI_Type *)baseAddr, kDspiTxFifoFillRequest);
    278          
    279              /* Enable the interrupt */
    280              dspi_set_system_IRQ_gate(instance, kPeripheralEnableIRQ);
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0x6AF8             LDR      R0,[R7, #+44]
   \   000000B2   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \   000000B6   0x62F8             STR      R0,[R7, #+44]
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       dspi_set_system_IRQ_gate
    281          
    282              /* Start DSPI transfers, set to running state */
    283              dspi_hal_start_transfer((SPI_Type *)baseAddr);
   \   000000BE   0x6838             LDR      R0,[R7, #+0]
   \   000000C0   0x0840             LSRS     R0,R0,#+1
   \   000000C2   0x0040             LSLS     R0,R0,#+1
   \   000000C4   0x6038             STR      R0,[R7, #+0]
    284          
    285              return errorCode;
   \   000000C6   0x2000             MOVS     R0,#+0
   \                     ??dspi_slave_init_4: (+1)
   \   000000C8   0xB005             ADD      SP,SP,#+20
   \   000000CA   0xBDF0             POP      {R4-R7,PC}       ;; return
    286          }
    287          
    288          /*FUNCTION**********************************************************************
    289           *
    290           * Function Name : dspi_slave_shutdown
    291           * Description   : Shutdown a DSPI instance.
    292           * Resets the DSPI peripheral, disables the interrupt to the core, and gates its clock.
    293           *
    294           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void dspi_slave_shutdown(dspi_slave_state_t * dspiState)
    296          {
   \                     dspi_slave_shutdown: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    297              uint32_t instance = dspiState->instance;
   \   00000002   0x6805             LDR      R5,[R0, #+0]
    298          
    299              assert(instance < SPI_INSTANCE_COUNT);
    300          
    301              uint32_t baseAddr = g_dspiBaseAddr[instance];
   \   00000004   0x.... 0x....      ADR.W    R0,g_dspiBaseAddr
    302          
    303              /* if SPI is not clocked exit, if so disable the interrupt and proceed*/
    304              switch(instance)
   \   00000008   0x....             LDR.N    R4,??DataTable2  ;; 0x4004803c
   \   0000000A   0xF850 0x6025      LDR      R6,[R0, R5, LSL #+2]
   \   0000000E   0xB115             CBZ.N    R5,??dspi_slave_shutdown_0
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD006             BEQ.N    ??dspi_slave_shutdown_1
   \   00000014   0xE00C             B.N      ??dspi_slave_shutdown_2
    305              {
    306                  case 0:
    307                      if (!(SIM_RD_SCGC6(SIM) & SIM_SCGC6_SPI0_MASK))
   \                     ??dspi_slave_shutdown_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x04C0             LSLS     R0,R0,#+19
   \   0000001A   0xD518             BPL.N    ??dspi_slave_shutdown_3
    308                      {
    309                          return;
    310                      }
    311                      dspi_set_system_IRQ_gate(0, kPeripheralDisableIRQ);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE004             B.N      ??dspi_slave_shutdown_4
    312                      break;
    313          #if (SPI_INSTANCE_COUNT > 1U)
    314                  case 1:
    315                      if (!(SIM_RD_SCGC6(SIM) & SIM_SCGC6_SPI1_MASK))
   \                     ??dspi_slave_shutdown_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x0480             LSLS     R0,R0,#+18
   \   00000026   0xD512             BPL.N    ??dspi_slave_shutdown_3
    316                      {
    317                          return;
    318                      }
    319                      dspi_set_system_IRQ_gate(1, kPeripheralDisableIRQ);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x2001             MOVS     R0,#+1
   \                     ??dspi_slave_shutdown_4: (+1)
   \   0000002C   0x.... 0x....      BL       dspi_set_system_IRQ_gate
    320                      break;
    321          #if (SPI_INSTANCE_COUNT > 2U)
    322                  case 2:
    323                      if (!(SIM_RD_SCGC3(SIM) & SIM_SCGC3_SPI2_MASK))
    324                      {
    325                          return;
    326                      }
    327                      dspi_set_system_IRQ_gate(2, kPeripheralDisableIRQ);
    328                      break;
    329          #endif // (SPI_INSTANCE_COUNT > 2U)
    330          #endif // (SPI_INSTANCE_COUNT > 1U)
    331              }
    332          
    333              /* Restore the module to defaults then power it down. This also disables the DSPI module. */
    334              dspi_hal_reset((SPI_Type *)baseAddr);
   \                     ??dspi_slave_shutdown_2: (+1)
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       dspi_hal_reset
    335          
    336              /* Gate the clock for DSPI. */
    337              switch(instance)
   \   00000036   0xB115             CBZ.N    R5,??dspi_slave_shutdown_5
   \   00000038   0x2D01             CMP      R5,#+1
   \   0000003A   0xD004             BEQ.N    ??dspi_slave_shutdown_6
   \   0000003C   0xBD70             POP      {R4-R6,PC}
    338              {
    339                  case 0:
    340                      SIM_CLR_SCGC6(SIM, SIM_SCGC6_SPI0_MASK);
   \                     ??dspi_slave_shutdown_5: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   00000044   0xE002             B.N      ??dspi_slave_shutdown_7
    341                      break;
    342          #if (SPI_INSTANCE_COUNT > 1U)
    343                  case 1:
    344                      SIM_CLR_SCGC6(SIM, SIM_SCGC6_SPI1_MASK);
   \                     ??dspi_slave_shutdown_6: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xF420 0x5000      BIC      R0,R0,#0x2000
   \                     ??dspi_slave_shutdown_7: (+1)
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    345                      break;
    346          #if (SPI_INSTANCE_COUNT > 2U)
    347                  case 2:
    348                      SIM_CLR_SCGC3(SIM, SIM_SCGC3_SPI2_MASK);
    349                      break;
    350          #endif // (SPI_INSTANCE_COUNT > 2U)
    351          #endif // (SPI_INSTANCE_COUNT > 1U)
    352              }
    353          }
   \                     ??dspi_slave_shutdown_3: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     g_dspiSharedIrqConfig
    354          
    355          #endif // BL_CONFIG_DSPI
    356          
    357          /*******************************************************************************
    358           * EOF
    359           ******************************************************************************/
    360          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   dspi_slave_init
        40   -> __aeabi_memclr4
        40   -> dspi_hal_configure_interrupt
        40   -> dspi_hal_flush_fifos
        40   -> dspi_hal_reset
        40   -> dspi_hal_slave_init
        40   -> dspi_set_system_IRQ_gate
      32   dspi_slave_irq_handler
        32   -- Indirect call
      16   dspi_slave_shutdown
        16   -> dspi_hal_reset
        16   -> dspi_set_system_IRQ_gate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       8  ?Subroutine0
     204  dspi_slave_init
     198  dspi_slave_irq_handler
      80  dspi_slave_shutdown
       8  g_dspiBaseAddr

 
 506 bytes in section .text
 
 506 bytes of CODE memory

Errors: none
Warnings: none
