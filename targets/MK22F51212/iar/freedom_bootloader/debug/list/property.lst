###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\property\src\property.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\property\src\property.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\property.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\property.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\property\src\property.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "property/property.h"
     33          #include "memory/memory.h"
     34          #include "packet/command_packet.h"
     35          #include "packet/serial_packet.h"
     36          #include "bootloader/peripheral.h"
     37          #include "bootloader/context.h"
     38          #include "bootloader/bl_version.h"
     39          #include "utilities/fsl_assert.h"
     40          #include <string.h>
     41          #if !defined(BOOTLOADER_HOST)
     42          #include "flash/flash.h"
     43          #include "device/fsl_device_registers.h"
     44          #if BL_HAS_QSPI_MODULE
     45          #include "qspi/qspi.h"
     46          #endif // BL_HAS_QSPI_MODULE
     47          #if BL_ENABLE_CRC_CHECK
     48          #include "bootloader/app_crc_check.h"
     49          #endif // BL_ENABLE_CRC_CHECK
     50          #endif //!BOOTLOADER_HOST
     51          
     52          ////////////////////////////////////////////////////////////////////////////////
     53          // Declarations
     54          ////////////////////////////////////////////////////////////////////////////////
     55          
     56          #if (defined(__ICCARM__))
     57          #pragma section = ".intvec"
     58          #pragma section = "ApplicationFlash"
     59          #pragma section = "ApplicationRam"
     60          #endif // __ICCARM__
     61          
     62          ////////////////////////////////////////////////////////////////////////////////
     63          // Variables
     64          ////////////////////////////////////////////////////////////////////////////////
     65          
     66          //! @brief Storage for property values.

   \                                 In section .bss, align 4
     67          property_store_t g_propertyStore;
   \                     g_propertyStore:
   \   00000000                      DS8 184
     68          //! @brief Map for external memory property interface.
     69          extern const external_memory_property_interface_t g_externalMemPropertyInterfaceMap[];
     70          
     71          // See property.h for documentation on this data structure.

   \                                 In section .rodata, align 4, keep-with-next
     72          const property_interface_t g_propertyInterface = {
   \                     g_propertyInterface:
   \   00000000   0x........         DC32 bootloader_property_load_user_config, bootloader_property_init
   \              0x........   
   \   00000008   0x........         DC32 bootloader_property_get, bootloader_property_set_uint32
   \              0x........   
   \   00000010   0x........         DC32 g_propertyStore
     73              bootloader_property_load_user_config,
     74              bootloader_property_init,
     75              bootloader_property_get,
     76              bootloader_property_set_uint32,
     77              &g_propertyStore
     78          };
     79          
     80          //! @brief Storage for property values computed every time they are read.

   \                                 In section .bss, align 4
     81          static uint32_t s_propertyReturnValue;
   \                     s_propertyReturnValue:
   \   00000000                      DS8 4
     82          
     83          ////////////////////////////////////////////////////////////////////////////////
     84          // Prototypes
     85          ////////////////////////////////////////////////////////////////////////////////
     86          // !@brief Get external memoery proporties
     87          status_t bootloader_get_external_memory_properties(uint8_t memoryId, external_memory_property_store_t *store);
     88          
     89          ////////////////////////////////////////////////////////////////////////////////
     90          // Code
     91          ////////////////////////////////////////////////////////////////////////////////
     92          
     93          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
     94          status_t bootloader_property_load_user_config(void)
     95          {
   \                     bootloader_property_load_user_config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     96          #if !defined(BOOTLOADER_HOST)
     97          
     98              bootloader_configuration_data_t * config = &g_bootloaderContext.propertyInterface->store->configurationData;
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0xF100 0x0470      ADD      R4,R0,#+112
     99          
    100              // Copy bootloader configuration data from the flash into the property store.
    101              memcpy(config,
    102                  (const void *)kBootloaderConfigAreaAddress,
    103                  sizeof(bootloader_configuration_data_t));
   \   0000000C   0x2230             MOVS     R2,#+48
   \   0000000E   0xF24A 0x31C0      MOVW     R1,#+41920
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy4
    104          
    105              // Verify tag. If it is invalid, wipe the config data to all 0xff.
    106              if (kPropertyStoreTag != config->tag)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable4_1  ;; 0x6766636b
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD004             BEQ.N    ??bootloader_property_load_user_config_0
    107              {
    108                  memset(config, 0xff, sizeof(bootloader_configuration_data_t));
   \   00000020   0x22FF             MOVS     R2,#+255
   \   00000022   0x2130             MOVS     R1,#+48
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       __aeabi_memset4
    109              }
    110          
    111              // Update available peripherals based on specific chips
    112              update_available_peripherals();
   \                     ??bootloader_property_load_user_config_0: (+1)
   \   0000002A   0x.... 0x....      BL       update_available_peripherals
    113          
    114          #endif // BOOTLOADER_HOST
    115          
    116              return kStatus_Success;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    117          }
    118          
    119          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    120          status_t bootloader_property_init(void)
    121          {
   \                     bootloader_property_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    122              property_store_t * propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000002   0x....             LDR.N    R5,??DataTable4
   \   00000004   0x68A8             LDR      R0,[R5, #+8]
   \   00000006   0x6904             LDR      R4,[R0, #+16]
    123          
    124              // Fill in default values.
    125              propertyStore->bootloaderVersion.name = kBootloader_Version_Name;
   \   00000008   0x204B             MOVS     R0,#+75
   \   0000000A   0x70E0             STRB     R0,[R4, #+3]
    126              propertyStore->bootloaderVersion.major = kBootloader_Version_Major;
    127              propertyStore->bootloaderVersion.minor = kBootloader_Version_Minor;
    128              propertyStore->bootloaderVersion.bugfix = kBootloader_Version_Bugfix;
    129          
    130              propertyStore->serialProtocolVersion.name = kSerialProtocol_Version_Name;
    131              propertyStore->serialProtocolVersion.major = kSerialProtocol_Version_Major;
    132              propertyStore->serialProtocolVersion.minor = kSerialProtocol_Version_Minor;
    133              propertyStore->serialProtocolVersion.bugfix = kSerialProtocol_Version_Bugfix;
    134          
    135          #if defined(BOOTLOADER_HOST)
    136              propertyStore->targetVersion.name = 'H';
    137              propertyStore->targetVersion.major = 1;
    138              propertyStore->targetVersion.minor = 0;
    139              propertyStore->targetVersion.bugfix = 0;
    140          #else
    141              propertyStore->targetVersion.name = kTarget_Version_Name;
    142              propertyStore->targetVersion.major = kTarget_Version_Major;
    143              propertyStore->targetVersion.minor = kTarget_Version_Minor;
    144              propertyStore->targetVersion.bugfix = kTarget_Version_Bugfix;
    145          #endif
    146              propertyStore->verifyWrites = true;
    147              propertyStore->validateRegions = true;
    148          
    149              propertyStore->availableCommands = kAvailableCommands;
    150          
    151          #if !defined(BOOTLOADER_HOST)
    152          
    153              /// Initialize flash properties.
    154              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_FlashBlockBaseAddr, &propertyStore->flashStartAddress);
   \   0000000C   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x70A0             STRB     R0,[R4, #+2]
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0x7060             STRB     R0,[R4, #+1]
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   \   0000001E   0x2050             MOVS     R0,#+80
   \   00000020   0x71E0             STRB     R0,[R4, #+7]
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x71A0             STRB     R0,[R4, #+6]
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x7160             STRB     R0,[R4, #+5]
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7120             STRB     R0,[R4, #+4]
   \   0000002E   0x2054             MOVS     R0,#+84
   \   00000030   0x72E0             STRB     R0,[R4, #+11]
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x72A0             STRB     R0,[R4, #+10]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7260             STRB     R0,[R4, #+9]
   \   0000003A   0x7220             STRB     R0,[R4, #+8]
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x6320             STR      R0,[R4, #+48]
   \   00000040   0x6360             STR      R0,[R4, #+52]
   \   00000042   0xF64E 0x70FF      MOVW     R0,#+61439
   \   00000046   0x63A0             STR      R0,[R4, #+56]
   \   00000048   0x.... 0x....      BL       ?Subroutine0
    155              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_TotalFlashSize, &propertyStore->flashSizeInBytes);
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000004C   0xF104 0x0214      ADD      R2,R4,#+20
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x.... 0x....      BL       ?Subroutine0
    156              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_SectorSize, &propertyStore->flashSectorSize);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000056   0xF104 0x0218      ADD      R2,R4,#+24
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x.... 0x....      BL       ?Subroutine0
    157              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_BlockSize, &propertyStore->flashBlockSize);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000060   0xF104 0x021C      ADD      R2,R4,#+28
   \   00000064   0x2102             MOVS     R1,#+2
   \   00000066   0x.... 0x....      BL       ?Subroutine0
    158              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_BlockCount, &propertyStore->flashBlockCount);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000006A   0xF104 0x0220      ADD      R2,R4,#+32
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0x.... 0x....      BL       ?Subroutine0
    159              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_FlashFacSupport, &propertyStore->flashFacSupport);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000074   0xF104 0x024C      ADD      R2,R4,#+76
   \   00000078   0x2105             MOVS     R1,#+5
   \   0000007A   0x.... 0x....      BL       ?Subroutine0
    160              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_FlashAccessSegmentSize, &propertyStore->flashAccessSegmentSize);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000007E   0xF104 0x0250      ADD      R2,R4,#+80
   \   00000082   0x2106             MOVS     R1,#+6
   \   00000084   0x.... 0x....      BL       ?Subroutine0
    161              flash_get_property(&g_bootloaderContext.flashState, kFlashProperty_FlashAccessSegmentCount, &propertyStore->flashAccessSegmentCount);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000088   0xF104 0x0254      ADD      R2,R4,#+84
   \   0000008C   0x2107             MOVS     R1,#+7
   \   0000008E   0x.... 0x....      BL       ?Subroutine0
    162          
    163              // Fill in reserved regions.
    164              //! @todo Support other tool chain
    165          
    166              uint32_t flashStart = 0;
    167              uint32_t flashEnd = 0;
    168              uint32_t ramStart = 0;
    169              uint32_t ramEnd = 0;
    170          
    171          #if (defined(__ICCARM__))
    172          
    173          #if !BL_TARGET_FLASH
    174              flashStart = 0;
    175              flashEnd = 0;
    176          #else
    177              flashStart = (uint32_t)__section_begin(".intvec");
    178              flashEnd = (uint32_t)__section_end("ApplicationFlash");
    179              assert(flashEnd);
    180          
    181              // Force flash erase size alignment.
    182              flashStart = ALIGN_DOWN(flashStart, propertyStore->flashSectorSize);
    183              flashEnd = ALIGN_UP(flashEnd, propertyStore->flashSectorSize) - 1;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000092   0x69A0             LDR      R0,[R4, #+24]
   \   00000094   0x....             LDR.N    R2,??DataTable4_2
   \   00000096   0x4240             RSBS     R0,R0,#+0
   \   00000098   0x4252             RSBS     R2,R2,#+0
   \   0000009A   0xF04F 0x31FF      MOV      R1,#-1
   \   0000009E   0x4002             ANDS     R2,R0,R2
   \   000000A0   0x1A89             SUBS     R1,R1,R2
    184          #endif
    185          
    186          #if defined(BL_TARGET_RAM)
    187              // Include all of text and data in RAM reserved region
    188              ramStart = (uint32_t)__section_begin(".intvec");
    189          #else
    190              ramStart = (uint32_t)__section_begin("ApplicationRam");
    191          #endif // BL_TARGET_RAM
    192              ramEnd = (uint32_t)__section_end("ApplicationRam") - 1;
    193              assert(ramEnd);
    194          
    195          #elif (defined(__GNUC__))
    196              extern uint32_t __VECTOR_RAM[];
    197              extern uint32_t __VECTOR_TABLE[];
    198              extern char __DATA_END[];;
    199              extern uint32_t __STACK_TOP[];
    200          #if !BL_TARGET_FLASH
    201              flashStart = 0;
    202              flashEnd = 0;
    203          #else
    204              flashStart = (uint32_t)__VECTOR_TABLE;
    205              flashEnd = (uint32_t)__DATA_END;
    206              assert(flashEnd);
    207          
    208              // Force flash erase size alignment.
    209              flashStart = ALIGN_DOWN(flashStart, propertyStore->flashSectorSize);
    210              flashEnd = ALIGN_UP(flashEnd, propertyStore->flashSectorSize) - 1;
    211          #endif
    212          
    213          #if defined(BL_TARGET_RAM)
    214              // Include all of text and data in RAM reserved region
    215              ramStart = (uint32_t)__VECTOR_TABLE;
    216          #else
    217              ramStart = (uint32_t)__VECTOR_RAM;
    218          #endif // BL_TARGET_RAM
    219              ramEnd = (uint32_t)__STACK_TOP;
    220              assert(ramEnd);
    221          
    222          #endif // __ICCARM__
    223          
    224              propertyStore->reservedRegions[kProperty_FlashReservedRegionIndex].startAddress = flashStart;
   \   000000A2   0x....             LDR.N    R2,??DataTable4_3
    225              propertyStore->reservedRegions[kProperty_FlashReservedRegionIndex].endAddress = flashEnd;
   \   000000A4   0x6661             STR      R1,[R4, #+100]
   \   000000A6   0x4010             ANDS     R0,R0,R2
   \   000000A8   0x6620             STR      R0,[R4, #+96]
    226              propertyStore->reservedRegions[kProperty_RamReservedRegionIndex].startAddress = ramStart;
    227              propertyStore->reservedRegions[kProperty_RamReservedRegionIndex].endAddress = ramEnd;
    228          
    229              // Fill in available peripherals array.
    230              const peripheral_descriptor_t * peripherals = g_bootloaderContext.allPeripherals;
    231              propertyStore->availablePeripherals = 0;
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x....             LDR.N    R0,??DataTable4_4
   \   000000AE   0x66A0             STR      R0,[R4, #+104]
   \   000000B0   0x....             LDR.N    R0,??DataTable4_5
   \   000000B2   0x66E0             STR      R0,[R4, #+108]
   \   000000B4   0x6968             LDR      R0,[R5, #+20]
   \   000000B6   0x60E1             STR      R1,[R4, #+12]
    232              for (uint32_t i = 0; peripherals[i].typeMask != 0; ++i)
   \   000000B8   0xE007             B.N      ??bootloader_property_init_0
    233              {
    234                  // Check that the peripheral is enabled in the user configuration data.
    235                  if (propertyStore->configurationData.enabledPeripherals & peripherals[i].typeMask)
   \                     ??bootloader_property_init_1: (+1)
   \   000000BA   0xF894 0x3080      LDRB     R3,[R4, #+128]
   \   000000BE   0x4213             TST      R3,R2
   \   000000C0   0xD002             BEQ.N    ??bootloader_property_init_2
    236                  {
    237                      propertyStore->availablePeripherals |= peripherals[i].typeMask;
   \   000000C2   0x68E3             LDR      R3,[R4, #+12]
   \   000000C4   0x431A             ORRS     R2,R2,R3
   \   000000C6   0x60E2             STR      R2,[R4, #+12]
    238                  }
    239              }
   \                     ??bootloader_property_init_2: (+1)
   \   000000C8   0x1C49             ADDS     R1,R1,#+1
   \                     ??bootloader_property_init_0: (+1)
   \   000000CA   0x2218             MOVS     R2,#+24
   \   000000CC   0xFB02 0x0201      MLA      R2,R2,R1,R0
   \   000000D0   0x6812             LDR      R2,[R2, #+0]
   \   000000D2   0x2A00             CMP      R2,#+0
   \   000000D4   0xD1F1             BNE.N    ??bootloader_property_init_1
    240          
    241              // Fill in unique device id value.
    242              // Different series have different length of UID (K series=128 bits, KL series=80 bits)
    243          #if defined(SIM_UIDH)
    244              propertyStore->UniqueDeviceId.uidh = SIM_RD_UIDH(SIM);
   \   000000D6   0x....             LDR.N    R0,??DataTable4_6  ;; 0x40048054
   \   000000D8   0x6801             LDR      R1,[R0, #+0]
   \   000000DA   0x64A1             STR      R1,[R4, #+72]
    245          #endif
    246              propertyStore->UniqueDeviceId.uidmh = SIM_UIDMH;
   \   000000DC   0x6841             LDR      R1,[R0, #+4]
   \   000000DE   0x6461             STR      R1,[R4, #+68]
    247              propertyStore->UniqueDeviceId.uidml = SIM_UIDML;
   \   000000E0   0x6881             LDR      R1,[R0, #+8]
   \   000000E2   0x6421             STR      R1,[R4, #+64]
    248              propertyStore->UniqueDeviceId.uidl = SIM_UIDL;
   \   000000E4   0x68C0             LDR      R0,[R0, #+12]
   \   000000E6   0x63E0             STR      R0,[R4, #+60]
    249          
    250              // Set address range of RAM in property interface
    251              const memory_map_entry_t * map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexSRAM];
   \   000000E8   0x6868             LDR      R0,[R5, #+4]
    252              propertyStore->ramStartAddress = map->startAddress;
   \   000000EA   0xF850 0x1F0C      LDR      R1,[R0, #+12]!
   \   000000EE   0x6261             STR      R1,[R4, #+36]
    253              propertyStore->ramSizeInBytes = map->endAddress - map->startAddress + 1;
   \   000000F0   0x6841             LDR      R1,[R0, #+4]
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x1A08             SUBS     R0,R1,R0
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0x62A0             STR      R0,[R4, #+40]
    254          
    255          #if BL_ENABLE_CRC_CHECK
    256              // Initialize crc check status property based on BCA related fields.
    257              init_crc_check_status(propertyStore);
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       init_crc_check_status
    258          #endif
    259          
    260              // Fill in default margin level.
    261              propertyStore->flashReadMargin = (uint32_t)kFlashMargin_User;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0x65A0             STR      R0,[R4, #+88]
    262          
    263          #if BL_HAS_QSPI_MODULE
    264              propertyStore->qspiInitStatus = get_qspi_otfad_init_status();
    265          #endif // BL_HAS_QSPI_MODULE
    266          
    267          #else
    268          
    269              const memory_map_entry_t * entry;
    270          
    271              // Initialize simulated flash properties.
    272              entry = &g_bootloaderContext.memoryMap[kIndexFlashArray];
    273          
    274              propertyStore->flashStartAddress = entry->startAddress;
    275              propertyStore->flashSizeInBytes = entry->endAddress - entry->startAddress + 1;
    276              propertyStore->flashSectorSize = 1024;
    277              propertyStore->flashBlockSize = propertyStore->flashSizeInBytes;
    278              propertyStore->flashBlockCount = 1;
    279          
    280              // Initialize simulated RAM properties.
    281              entry = &g_bootloaderContext.memoryMap[kIndexSRAM];
    282          
    283              propertyStore->ramStartAddress = entry->startAddress;
    284              propertyStore->ramSizeInBytes = entry->endAddress - entry->startAddress + 1;
    285          
    286          #endif // !BOOTLOADER_HOST
    287          
    288              return kStatus_Success;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    289          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000004   0x.... 0x....      B.W      flash_get_property
    290          
    291          // See property.h for documentation on this function.

   \                                 In section .text, align 4, keep-with-next
    292          status_t bootloader_property_get(uint8_t tag, uint8_t id, const void ** value, uint32_t * valueSize)
    293          {
   \                     bootloader_property_get: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4614             MOV      R4,R2
    294              property_store_t * propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000004   0x....             LDR.N    R2,??DataTable4
    295          
    296              // Set default value size, may be modified below.
    297              uint32_t returnSize = sizeof(uint32_t);
    298              const void * returnValue;
    299              switch (tag)
   \   00000006   0x....             LDR.N    R7,??DataTable4_7
   \   00000008   0x6891             LDR      R1,[R2, #+8]
   \   0000000A   0x2604             MOVS     R6,#+4
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x6909             LDR      R1,[R1, #+16]
   \   00000010   0x2817             CMP      R0,#+23
   \   00000012   0x461D             MOV      R5,R3
   \   00000014   0xD84E             BHI.N    ??bootloader_property_get_1
   \   00000016   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??bootloader_property_get_0:
   \   0000001A   0x0C 0x12          DC8      0xC,0x12,0x14,0x16
   \              0x14 0x16    
   \   0000001E   0x18 0x1A          DC8      0x18,0x1A,0x20,0x22
   \              0x20 0x22    
   \   00000022   0x4D 0x24          DC8      0x4D,0x24,0x28,0x2F
   \              0x28 0x2F    
   \   00000026   0x26 0x1C          DC8      0x26,0x1C,0x1E,0x32
   \              0x1E 0x32    
   \   0000002A   0x35 0x40          DC8      0x35,0x40,0x43,0x45
   \              0x43 0x45    
   \   0000002E   0x47 0x49          DC8      0x47,0x49,0x4D,0x4B
   \              0x4D 0x4B    
    300              {
    301                  case kPropertyTag_BootloaderVersion:
    302                      returnValue = &propertyStore->bootloaderVersion.version;
    303                      break;
    304          
    305                  case kPropertyTag_AvailablePeripherals:
    306                      returnValue = &propertyStore->availablePeripherals;
    307                      break;
    308          
    309                  case kPropertyTag_FlashStartAddress:
    310                      returnValue = &propertyStore->flashStartAddress;
    311                      break;
    312          
    313                  case kPropertyTag_FlashSizeInBytes:
    314                      returnValue = &propertyStore->flashSizeInBytes;
    315                      break;
    316          
    317                  case kPropertyTag_FlashSectorSize:
    318                      returnValue = &propertyStore->flashSectorSize;
    319                      break;
    320          
    321                  case kPropertyTag_FlashBlockCount:
    322                      returnValue = &propertyStore->flashBlockCount;
    323                      break;
    324          
    325                  case kPropertyTag_RAMStartAddress:
    326                      returnValue = &propertyStore->ramStartAddress;
    327                      break;
    328          
    329                  case kPropertyTag_RAMSizeInBytes:
    330                      returnValue = &propertyStore->ramSizeInBytes;
    331                      break;
    332          
    333                  case kPropertyTag_AvailableCommands:
    334                      returnValue = &propertyStore->availableCommands;
    335                      break;
    336          
    337          #if BL_ENABLE_CRC_CHECK
    338                  case kPropertyTag_CrcCheckStatus:
    339                      returnValue = &propertyStore->crcCheckStatus;
    340                      break;
    341          #endif //else falls through to unknown
    342          
    343                  case kPropertyTag_VerifyWrites:
    344                      returnValue = &propertyStore->verifyWrites;
    345                      break;
    346          
    347                  case kPropertyTag_ValidateRegions:
    348                      returnValue = &propertyStore->validateRegions;
    349                      break;
    350          
    351                  case kPropertyTag_MaxPacketSize:
    352                      // Read the max packet size from the active peripheral.
    353                      s_propertyReturnValue = g_bootloaderContext.activePeripheral->packetInterface->getMaxPacketSize(g_bootloaderContext.activePeripheral);
    354                      returnValue = &s_propertyReturnValue;
    355                      break;
    356          
    357                  case kPropertyTag_ReservedRegions:
    358                      returnSize = sizeof(propertyStore->reservedRegions);
    359                      returnValue = propertyStore->reservedRegions;
    360                      break;
    361          
    362                  case kPropertyTag_SystemDeviceId:
    363                      // Get system device identification
    364          #if BOOTLOADER_HOST
    365                      s_propertyReturnValue = 0;
    366          #else
    367                      s_propertyReturnValue = SIM_SDID;
    368          #endif // BOOTLOADER_HOST
    369                      returnValue = &s_propertyReturnValue;
    370                      break;
    371          
    372                  case kPropertyTag_FlashSecurityState:
    373                  {
    374          #if BOOTLOADER_HOST
    375                      s_propertyReturnValue = 0;
    376          #else
    377                      flash_security_state_t securityState;
    378                      flash_get_security_state(&g_bootloaderContext.flashState, &securityState);
    379                      s_propertyReturnValue = (securityState != kFlashNotSecure);
    380          #endif // BOOTLOADER_HOST
    381                      returnValue = &s_propertyReturnValue;
    382                      break;
    383                  }
    384          
    385                  case kPropertyTag_UniqueDeviceId:
    386                      returnSize = sizeof(propertyStore->UniqueDeviceId);
    387                      returnValue = &propertyStore->UniqueDeviceId;
    388                      break;
    389          
    390                  case kPropertyTag_FacSupport:
    391                      returnSize = sizeof(propertyStore->flashFacSupport);
    392                      returnValue = &propertyStore->flashFacSupport;
    393                      break;
    394          
    395                  case kPropertyTag_FlashAccessSegmentSize:
    396                      returnSize = sizeof(propertyStore->flashAccessSegmentSize);
    397                      returnValue = &propertyStore->flashAccessSegmentSize;
    398                      break;
    399          
    400                  case kPropertyTag_FlashAccessSegmentCount:
    401                      returnSize = sizeof(propertyStore->flashAccessSegmentCount);
    402                      returnValue = &propertyStore->flashAccessSegmentCount;
    403                      break;
    404          
    405                  case kPropertyTag_FlashReadMargin:
    406                      returnSize = sizeof(propertyStore->flashReadMargin);
    407                      returnValue = &propertyStore->flashReadMargin;
    408                      break;
    409          
    410          #if BL_HAS_QSPI_MODULE
    411                  case kPropertyTag_QspiInitStatus:
    412                      returnValue = &propertyStore->qspiInitStatus;
    413                      break;
    414          #endif //else falls through to unknown
    415          
    416                  case kPropertyTag_TargetVersion:
    417                      returnValue = &propertyStore->targetVersion.version;
    418                      break;
    419          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    420              case kPropertyTag_ExternalMemoryAttributes:
    421                  {
    422                      status_t status = bootloader_get_external_memory_properties(id, &propertyStore->externalMemoryPropertyStore);
    423                      if (status != kStatus_Success)
    424                      {
    425                          return status;
    426                      }
    427                  }
    428                  returnSize = sizeof(propertyStore->externalMemoryPropertyStore);
    429                  returnValue = &propertyStore->externalMemoryPropertyStore;
    430                  break;
    431          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    432          
    433                  default:
    434                      return kStatus_UnknownProperty;
    435              }
    436          
    437              // Set the return size.
    438              if (valueSize)
   \                     ??bootloader_property_get_2: (+1)
   \   00000032   0xB105             CBZ.N    R5,??bootloader_property_get_3
    439              {
    440                  *valueSize = returnSize;
   \   00000034   0x602E             STR      R6,[R5, #+0]
    441              }
    442          
    443              // Set the return value
    444              if (value)
   \                     ??bootloader_property_get_3: (+1)
   \   00000036   0xB104             CBZ.N    R4,??bootloader_property_get_4
    445              {
    446                  *value = returnValue;
   \   00000038   0x6021             STR      R1,[R4, #+0]
    447              }
    448          
    449              return kStatus_Success;
   \                     ??bootloader_property_get_4: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??bootloader_property_get_5: (+1)
   \   0000003E   0x310C             ADDS     R1,R1,#+12
   \   00000040   0xE7F7             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_6: (+1)
   \   00000042   0x3110             ADDS     R1,R1,#+16
   \   00000044   0xE7F5             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_7: (+1)
   \   00000046   0x3114             ADDS     R1,R1,#+20
   \   00000048   0xE7F3             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_8: (+1)
   \   0000004A   0x3118             ADDS     R1,R1,#+24
   \   0000004C   0xE7F1             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_9: (+1)
   \   0000004E   0x3120             ADDS     R1,R1,#+32
   \   00000050   0xE7EF             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_10: (+1)
   \   00000052   0x3124             ADDS     R1,R1,#+36
   \   00000054   0xE7ED             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_11: (+1)
   \   00000056   0x3128             ADDS     R1,R1,#+40
   \   00000058   0xE7EB             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_12: (+1)
   \   0000005A   0x3138             ADDS     R1,R1,#+56
   \   0000005C   0xE7E9             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_13: (+1)
   \   0000005E   0x312C             ADDS     R1,R1,#+44
   \   00000060   0xE7E7             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_14: (+1)
   \   00000062   0x3130             ADDS     R1,R1,#+48
   \   00000064   0xE7E5             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_15: (+1)
   \   00000066   0x3134             ADDS     R1,R1,#+52
   \   00000068   0xE7E3             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_16: (+1)
   \   0000006A   0x69D0             LDR      R0,[R2, #+28]
   \   0000006C   0x6941             LDR      R1,[R0, #+20]
   \   0000006E   0x6949             LDR      R1,[R1, #+20]
   \   00000070   0x4788             BLX      R1
   \                     ??bootloader_property_get_17: (+1)
   \   00000072   0x6038             STR      R0,[R7, #+0]
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0xE7DC             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_18: (+1)
   \   00000078   0x2610             MOVS     R6,#+16
   \   0000007A   0x3160             ADDS     R1,R1,#+96
   \   0000007C   0xE7D9             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_19: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable4_8  ;; 0x40048024
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0xE7F6             B.N      ??bootloader_property_get_17
   \                     ??bootloader_property_get_20: (+1)
   \   00000084   0x4669             MOV      R1,SP
   \   00000086   0xF102 0x0020      ADD      R0,R2,#+32
   \   0000008A   0x.... 0x....      BL       flash_get_security_state
   \   0000008E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD0ED             BEQ.N    ??bootloader_property_get_17
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xE7EB             B.N      ??bootloader_property_get_17
   \                     ??bootloader_property_get_21: (+1)
   \   0000009A   0x2610             MOVS     R6,#+16
   \   0000009C   0x313C             ADDS     R1,R1,#+60
   \   0000009E   0xE7C8             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_22: (+1)
   \   000000A0   0x314C             ADDS     R1,R1,#+76
   \   000000A2   0xE7C6             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_23: (+1)
   \   000000A4   0x3150             ADDS     R1,R1,#+80
   \   000000A6   0xE7C4             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_24: (+1)
   \   000000A8   0x3154             ADDS     R1,R1,#+84
   \   000000AA   0xE7C2             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_25: (+1)
   \   000000AC   0x3158             ADDS     R1,R1,#+88
   \   000000AE   0xE7C0             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_26: (+1)
   \   000000B0   0x3108             ADDS     R1,R1,#+8
   \   000000B2   0xE7BE             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_1: (+1)
   \   000000B4   0xF642 0x003C      MOVW     R0,#+10300
   \   000000B8   0xBDF2             POP      {R1,R4-R7,PC}
    450          }
    451          
    452          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    453          status_t bootloader_property_set_uint32(uint8_t tag, uint32_t value)
    454          {
    455              property_store_t * propertyStore = g_bootloaderContext.propertyInterface->store;
   \                     bootloader_property_set_uint32: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable4
   \   00000002   0x6892             LDR      R2,[R2, #+8]
   \   00000004   0x6913             LDR      R3,[R2, #+16]
    456          
    457              switch (tag)
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x2807             CMP      R0,#+7
   \   0000000A   0xF642 0x023E      MOVW     R2,#+10302
   \   0000000E   0xD920             BLS.N    ??bootloader_property_set_uint32_0
   \   00000010   0x3809             SUBS     R0,R0,#+9
   \   00000012   0xD00C             BEQ.N    ??bootloader_property_set_uint32_1
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD91B             BLS.N    ??bootloader_property_set_uint32_0
   \   0000001A   0x1E80             SUBS     R0,R0,#+2
   \   0000001C   0xD00D             BEQ.N    ??bootloader_property_set_uint32_2
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD916             BLS.N    ??bootloader_property_set_uint32_0
   \   00000024   0x3808             SUBS     R0,R0,#+8
   \   00000026   0xD00E             BEQ.N    ??bootloader_property_set_uint32_3
   \   00000028   0x1E80             SUBS     R0,R0,#+2
   \   0000002A   0xD012             BEQ.N    ??bootloader_property_set_uint32_0
   \   0000002C   0xE014             B.N      ??bootloader_property_set_uint32_4
    458              {
    459                  case kPropertyTag_VerifyWrites:
    460                      if (value != 0 && value != 1)
   \                     ??bootloader_property_set_uint32_1: (+1)
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xBF18             IT       NE 
   \   00000032   0x2901             CMPNE    R1,#+1
   \   00000034   0xD109             BNE.N    ??bootloader_property_set_uint32_5
    461                      {
    462                          return kStatus_InvalidPropertyValue;
    463                      }
    464                      propertyStore->verifyWrites = value;
   \   00000036   0x6319             STR      R1,[R3, #+48]
    465                      return kStatus_Success;
   \   00000038   0x4770             BX       LR
    466          
    467                  case kPropertyTag_ValidateRegions:
    468                      if (value != 0 && value != 1)
   \                     ??bootloader_property_set_uint32_2: (+1)
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x2901             CMPNE    R1,#+1
   \   00000040   0xD103             BNE.N    ??bootloader_property_set_uint32_5
    469                      {
    470                          return kStatus_InvalidPropertyValue;
    471                      }
    472                      propertyStore->validateRegions = value;
   \   00000042   0x6359             STR      R1,[R3, #+52]
    473                      return kStatus_Success;
   \   00000044   0x4770             BX       LR
    474          
    475                  case kPropertyTag_FlashReadMargin:
    476          #if !defined(BOOTLOADER_HOST)
    477                      if (value >= kFlashMargin_Invalid)
   \                     ??bootloader_property_set_uint32_3: (+1)
   \   00000046   0x2903             CMP      R1,#+3
   \   00000048   0xD301             BCC.N    ??bootloader_property_set_uint32_6
    478                      {
    479                          return kStatus_InvalidPropertyValue;
   \                     ??bootloader_property_set_uint32_5: (+1)
   \   0000004A   0x4610             MOV      R0,R2
   \   0000004C   0x4770             BX       LR
    480                      }
    481                      propertyStore->flashReadMargin = value;
   \                     ??bootloader_property_set_uint32_6: (+1)
   \   0000004E   0x6599             STR      R1,[R3, #+88]
    482          #endif // !BOOTLOADER_HOST
    483                      return kStatus_Success;
   \   00000050   0x4770             BX       LR
    484          
    485                  case kPropertyTag_BootloaderVersion:
    486                  case kPropertyTag_AvailablePeripherals:
    487                  case kPropertyTag_FlashStartAddress:
    488                  case kPropertyTag_FlashSizeInBytes:
    489                  case kPropertyTag_FlashSectorSize:
    490                  case kPropertyTag_FlashBlockCount:
    491                  case kPropertyTag_RAMStartAddress:
    492                  case kPropertyTag_RAMSizeInBytes:
    493                  case kPropertyTag_AvailableCommands:
    494          #if BL_ENABLE_CRC_CHECK
    495                  case kPropertyTag_CrcCheckStatus:
    496          #endif
    497          #if BL_HAS_QSPI_MODULE
    498                  case kPropertyTag_QspiInitStatus:
    499          #endif
    500          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    501              case kPropertyTag_ExternalMemoryAttributes:
    502          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    503                  case kPropertyTag_MaxPacketSize:
    504                  case kPropertyTag_ReservedRegions:
    505                  case kPropertyTag_SystemDeviceId:
    506                  case kPropertyTag_FlashSecurityState:
    507                  case kPropertyTag_TargetVersion:
    508                      return kStatus_ReadOnlyProperty;
   \                     ??bootloader_property_set_uint32_0: (+1)
   \   00000052   0xF642 0x003D      MOVW     R0,#+10301
   \   00000056   0x4770             BX       LR
    509                  default:
    510                      return kStatus_UnknownProperty;
   \                     ??bootloader_property_set_uint32_4: (+1)
   \   00000058   0xF642 0x003C      MOVW     R0,#+10300
   \   0000005C   0x4770             BX       LR               ;; return
    511              }
    512          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x6766636B         DC32     0x6766636b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     SFE(ApplicationFlash)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     SFB(`.intvec`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     SFB(ApplicationRam)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     SFE(ApplicationRam)+0xFFFFFFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40048054         DC32     0x40048054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     s_propertyReturnValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x40048024         DC32     0x40048024
    513          
    514          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    515          status_t bootloader_get_external_memory_properties(uint8_t memoryId, external_memory_property_store_t *store)
    516          {
    517              extern const external_memory_property_interface_t g_externalMemPropertyInterfaceMap[];
    518          
    519              // Find external memory property interface map.
    520              const external_memory_property_interface_t *map = &g_externalMemPropertyInterfaceMap[0];
    521              while(map && map->get)
    522              {
    523                  if (map->memoryId == memoryId)
    524                  {
    525                      break;
    526                  }
    527                  map++;
    528              }
    529          
    530              if (map->get == NULL)
    531              {
    532                  return kStatus_InvalidArgument;
    533              }
    534          
    535              external_memory_property_store_t propertyStore;
    536              uint32_t memoryInitStatus;
    537              map->get(kExternalMemoryPropertyTag_InitStatus, &memoryInitStatus);
    538              if (memoryInitStatus != kStatus_Success)
    539              {
    540                  return memoryInitStatus;
    541              }
    542          
    543              uint32_t *property = (uint32_t*)&propertyStore.startAddress;
    544              propertyStore.availableAttributesFlag = 0;
    545              for(uint32_t tag = kExternalMemoryPropertyTag_Start; tag <= kExternalMemoryPropertyTag_End; tag++)
    546              {
    547                  uint32_t tmp = 0;
    548                  status_t status = map->get(tag, &tmp);
    549                  if(status == kStatus_Success)
    550                  {
    551                      *property = tmp;
    552                      propertyStore.availableAttributesFlag |= 1<<(tag-1);
    553                  }
    554                  else
    555                  {
    556                      *property = 0;
    557                  }
    558          
    559                  property++;
    560              }
    561          
    562              memcpy(store, &propertyStore, sizeof(propertyStore));
    563          
    564              return kStatus_Success;
    565          }
    566          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    567          
    568          ////////////////////////////////////////////////////////////////////////////////
    569          // EOF
    570          ////////////////////////////////////////////////////////////////////////////////
    571          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   bootloader_property_get
        24   -- Indirect call
        24   -> flash_get_security_state
      16   bootloader_property_init
        16   -> flash_get_property
        16   -> init_crc_check_status
       8   bootloader_property_load_user_config
         8   -> __aeabi_memcpy4
         8   -> __aeabi_memset4
         8   -> update_available_peripherals
       0   bootloader_property_set_uint32


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       8  ?Subroutine0
     186  bootloader_property_get
     264  bootloader_property_init
      50  bootloader_property_load_user_config
      94  bootloader_property_set_uint32
      20  g_propertyInterface
     184  g_propertyStore
       4  s_propertyReturnValue

 
 188 bytes in section .bss
  20 bytes in section .rodata
 638 bytes in section .text
 
 638 bytes of CODE  memory
  20 bytes of CONST memory
 188 bytes of DATA  memory

Errors: none
Warnings: none
