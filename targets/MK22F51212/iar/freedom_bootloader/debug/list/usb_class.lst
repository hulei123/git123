###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:47:42
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\classes\common\usb_class.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\classes\common\usb_class.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_class.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_class.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\usb_stack\usb_core\device\sources\classes\common\usb_class.c
      1          /**HEADER********************************************************************
      2          * 
      3          * Copyright (c) 2008, 2013 - 2014 Freescale Semiconductor;
      4          * All Rights Reserved
      5          *
      6          * Copyright (c) 1989-2008 ARC International;
      7          * All Rights Reserved
      8          *
      9          *************************************************************************** 
     10          *
     11          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
     12          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     13          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     14          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     15          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     16          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     17          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     18          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     19          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     20          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     21          * THE POSSIBILITY OF SUCH DAMAGE.
     22          *
     23          **************************************************************************
     24          *
     25          * $FileName: usb_class.c$
     26          * $Version : 
     27          * $Date    : 
     28          *
     29          * Comments:
     30          *
     31          * @brief The file contains USB stack Class module implementation.
     32          *
     33          *****************************************************************************/
     34          
     35          /******************************************************************************
     36           * Includes
     37           *****************************************************************************/
     38          #include "usb_device_config.h"
     39          #include "usb.h"
     40          
     41          #include "usb_device_stack_interface.h"
     42          
     43          #if USBCFG_DEV_HID || USBCFG_DEV_PHDC || USBCFG_DEV_AUDIO || USBCFG_DEV_CDC || USBCFG_DEV_MSC
     44          
     45          #include "usb_class_internal.h"
     46          #include "usb_framework.h"
     47          
     48          /*****************************************************************************
     49           * Constant and Macro's
     50           *****************************************************************************/
     51          
     52          /****************************************************************************
     53           * Global Variables
     54           ****************************************************************************/

   \                                 In section .bss, align 4
     55          static usb_class_object_struct_t usb_class_object[USBCFG_DEV_MAX_CLASS_OBJECT];
   \                     usb_class_object:
   \   00000000                      DS8 16
     56          #if USBCFG_DEV_COMPOSITE
     57          static class_handle_t s_class_handle = USB_UNINITIALIZED_VAL_32;
     58          #endif
     59          /*****************************************************************************
     60           * Local Types - None
     61           *****************************************************************************/
     62          
     63          /*****************************************************************************
     64           * Local Functions Prototypes 
     65           *****************************************************************************/
     66          
     67          /*****************************************************************************
     68           * Local Variables 
     69           *****************************************************************************/ 
     70           
     71           /*****************************************************************************
     72           * Local Functions - None
     73           *****************************************************************************/
     74          
     75          /*****************************************************************************
     76           * Global Functions
     77           *****************************************************************************/
     78          
     79           /*************************************************************************//*!
     80           *
     81           * @name  USB_Class_Allocate_Handle
     82           *
     83           * @brief The function reserves entry in device array and returns the index.
     84           *
     85           * @param none.
     86           * @return returns the reserved handle or if no entry found device busy.      
     87           *
     88           *****************************************************************************/
     89          static usb_status USB_Class_Allocate_Handle(usb_class_object_struct_t** pclassobj)
     90          {
     91              int32_t cnt = 0;
     92              for (;cnt< USBCFG_DEV_MAX_CLASS_OBJECT;cnt++)
     93              {
     94                 if (usb_class_object[cnt].controller_handle == NULL)
     95                 {
     96                     *pclassobj = &usb_class_object[cnt];
     97                     return USB_OK;
     98                 }
     99              }
    100              return USBERR_DEVICE_BUSY;
    101          }
    102          
    103           /*************************************************************************//*!
    104           *
    105           * @name  USB_Class_Free_Handle
    106           *
    107           * @brief The function releases entry in device array .
    108           *
    109           * @param handle  index in device array to be released..
    110           * @return returns and error code or USB_OK.      
    111           *
    112           *****************************************************************************/
    113          static usb_status USB_Class_Free_Handle(usb_class_object_struct_t* handle)
    114          {
    115              int32_t cnt = 0;
    116              for (;cnt< USBCFG_DEV_MAX_CLASS_OBJECT;cnt++)
    117              {
    118                  if (&usb_class_object[cnt] == handle)
    119                  {
    120                      usb_class_object[cnt].controller_handle = NULL;
    121                      usb_class_object[cnt].usb_fw_handle     = 0;
    122                      usb_class_object[cnt].arg               = NULL;
    123                      usb_class_object[cnt].class_callback    = NULL;
    124                      return USB_OK;
    125                  }
    126              }
    127          
    128              return USBERR_INVALID_PARAM;    
    129          }
    130          
    131          
    132          /**************************************************************************//*!
    133           *
    134           * @name  USB_Class_Init
    135           *
    136           * @brief The function initializes the Class Module
    137           *
    138           * @param handle             :handle to Identify the controller
    139           * @param class_callback     :event callback      
    140           * @param other_req_callback :call back for class/vendor specific requests on 
    141           *                            CONTROL ENDPOINT
    142           *
    143           * @return status       
    144           *         USB_OK           : When Successfully
    145           *         Others           : Errors
    146           *
    147           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          class_handle_t USB_Class_Init
    149          (
    150              usb_device_handle handle, /* [IN] the USB device controller to initialize */                  
    151              usb_device_notify_t  class_callback,/*[IN]*/
    152              usb_request_notify_t other_req_callback,/*[IN]*/
    153              void* user_arg,/*[IN]*/
    154              usb_desc_request_notify_struct_t*  desc_callback_ptr/*[IN]*/
    155           ) 
    156          {
   \                     USB_Class_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x461E             MOV      R6,R3
    157              usb_class_object_struct_t* class_object_ptr = NULL;
    158              usb_status ret;
    159              
    160              ret = USB_Class_Allocate_Handle(&class_object_ptr);
   \   00000008   0x2000             MOVS     R0,#+0
   \                     ??USB_Class_Init_0: (+1)
   \   0000000A   0x....             LDR.N    R2,??DataTable1
   \   0000000C   0xEB02 0x1700      ADD      R7,R2,R0, LSL #+4
   \   00000010   0x687A             LDR      R2,[R7, #+4]
   \   00000012   0xB122             CBZ.N    R2,??USB_Class_Init_1
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xDBF7             BLT.N    ??USB_Class_Init_0
    161              if (USBERR_DEVICE_BUSY == ret) 
    162              {
    163                  return USBERR_DEVICE_BUSY;
   \   0000001A   0x20C1             MOVS     R0,#+193
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    164              }
    165                  
    166              class_object_ptr->controller_handle = handle;
    167              class_object_ptr->class_callback = class_callback;
   \                     ??USB_Class_Init_1: (+1)
   \   0000001E   0x60F9             STR      R1,[R7, #+12]
   \   00000020   0x607C             STR      R4,[R7, #+4]
    168              class_object_ptr->arg = user_arg;
   \   00000022   0x60BE             STR      R6,[R7, #+8]
    169          
    170              usb_device_register_application_notify(handle, class_callback, user_arg);
   \   00000024   0x4632             MOV      R2,R6
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       usb_device_register_application_notify
    171              usb_device_register_vendor_class_request_notify(handle, other_req_callback, user_arg);
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       usb_device_register_vendor_class_request_notify
    172              usb_device_register_desc_request_notify(handle, desc_callback_ptr, user_arg);
   \   00000036   0x9906             LDR      R1,[SP, #+24]
   \   00000038   0x4632             MOV      R2,R6
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       usb_device_register_desc_request_notify
    173              
    174          #ifdef USBCFG_OTG
    175             {
    176                  descriptor_union_t desc;
    177                  uint32_t config_size;
    178                  usb_status error;
    179                  uint8_t i;
    180                  uint8_t bm_attributes = 0;
    181                  error = desc_callback_ptr->get_desc(desc_callback_ptr->handle,USB_DESC_TYPE_CFG,0,0,(uint8_t **)&desc,&config_size);
    182                  if(error == USB_OK)
    183                  {
    184                      config_size = USB_SHORT_LE_TO_HOST(*(uint16_t*)desc.cfig->wTotalLength);
    185                      i= desc.cfig->bLength;
    186                      desc.word += desc.cfig->bLength;
    187                      while(i<config_size)
    188                      {
    189                          if (desc.otg->bDescriptorType == USB_DESC_TYPE_OTG) 
    190                          {
    191                              /* Found the OTG descriptor */
    192                              bm_attributes = desc.otg->bmAttributes;
    193                              break;
    194                          } /* Endif */
    195                          i += desc.otg->bLength;
    196                          desc.word += desc.otg->bLength;
    197                      }
    198                  }
    199                  usb_device_otg_init(handle, bm_attributes);
    200              }
    201          #endif    
    202          #if USBCFG_DEV_COMPOSITE
    203              /* Suppose only one class handle can be assigned */
    204              s_class_handle = (class_handle_t)class_object_ptr;
    205          #endif
    206              return (class_handle_t)class_object_ptr;     
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}
    207          }
    208          
    209          /**************************************************************************//*!
    210           *
    211           * @name  USB_Class_Deinit
    212           *
    213           * @brief The function initializes the Class Module
    214           *
    215           * @param handle             :handle to Identify the controller
    216           * @param class_handle       :class handle      
    217           *
    218           * @return status       
    219           *         USB_OK           : When Successfully
    220           *         Others           : Errors
    221           *
    222           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          usb_status USB_Class_Deinit
    224          (
    225              usb_device_handle handle, /* [IN] the USB device controller to initialize */                  
    226              class_handle_t  class_handle
    227           ) 
    228          {
    229              usb_status error = USB_OK;
    230              
    231              error = USB_Class_Free_Handle((usb_class_object_struct_t*)class_handle);
   \                     USB_Class_Deinit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??USB_Class_Deinit_0: (+1)
   \   00000002   0x....             LDR.N    R2,??DataTable1
   \   00000004   0xEB02 0x1200      ADD      R2,R2,R0, LSL #+4
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xD004             BEQ.N    ??USB_Class_Deinit_1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xDBF7             BLT.N    ??USB_Class_Deinit_0
   \   00000012   0x209E             MOVS     R0,#+158
    232          
    233          #if USBCFG_DEV_COMPOSITE
    234              /* Suppose only one class handle can be assigned */
    235              s_class_handle = USB_UNINITIALIZED_VAL_32;
    236          #endif
    237              
    238              return error;     
   \   00000014   0x4770             BX       LR               ;; return
   \                     ??USB_Class_Deinit_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6050             STR      R0,[R2, #+4]
   \   0000001A   0x6010             STR      R0,[R2, #+0]
   \   0000001C   0x6090             STR      R0,[R2, #+8]
   \   0000001E   0x60D0             STR      R0,[R2, #+12]
   \   00000020   0x4770             BX       LR
    239          }
    240          
    241          /**************************************************************************//*!
    242           *
    243           * @name  USB_Class_Send_Data
    244           *
    245           * @brief The function calls the device to send data upon receiving an IN token
    246           *
    247           * @param handle:               handle to Identify the controller
    248           * @param ep_num:               The endpoint number     
    249           * @param buff_ptr:             buffer to send
    250           * @param size:                 length of transfer
    251           * 
    252           * @return status       
    253           *         USB_OK           : When Successfully
    254           *         Others           : Errors
    255           *
    256           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    257          usb_status USB_Class_Send_Data
    258          (
    259              class_handle_t handle, /*[IN]*/
    260              uint8_t ep_num,        /* [IN] the Endpoint number */                  
    261              uint8_t * buff_ptr,      /* [IN] buffer to send */      
    262              uint32_t size           /* [IN] length of the transfer */
    263          ) 
    264          {
    265              usb_status error = USB_OK;
    266              //uint16_t  state;
    267              usb_class_object_struct_t* class_object_ptr = (usb_class_object_struct_t*)handle;   
    268              
    269              if (NULL == class_object_ptr) 
   \                     USB_Class_Send_Data: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF1C             ITT      NE 
    270                  return USBERR_ERROR;
    271          
    272              error = usb_device_send_data(class_object_ptr->controller_handle,
    273                          ep_num,buff_ptr,size);
    274          
    275              return error;      
   \   00000004   0x6840             LDRNE    R0,[R0, #+4]
   \   00000006   0x.... 0x....      BNE.W    usb_device_send_data
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x4770             BX       LR
    276          }
    277           
    278          /**************************************************************************//*!
    279           *
    280           * @name   USB_Class_Periodic_Task
    281           *
    282           * @brief  The function calls for periodic tasks
    283           *
    284           * @param  None
    285           *
    286           * @return None
    287           *
    288           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    289          void USB_Class_Periodic_Task(void) 
    290          {
    291              #ifdef DELAYED_PROCESSING  
    292                  USB_Framework_Periodic_Task();
    293              #endif  
    294          }
   \                     USB_Class_Periodic_Task: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     usb_class_object
    295          
    296          #if USBCFG_DEV_COMPOSITE
    297          /**************************************************************************//*!
    298           *
    299           * @name  USB_Class_Get_Class_Handle
    300           *
    301           * @brief  This function is called to return class handle.
    302           *
    303           * @return value:
    304           *                        class handle
    305           *
    306           *****************************************************************************/
    307          class_handle_t USB_Class_Get_Class_Handle()
    308          {
    309              return s_class_handle;
    310          }
    311          
    312          /**************************************************************************//*!
    313           *
    314           * @name  USB_Class_Get_Ctrler_Handle
    315           *
    316           * @brief  This function is called to return controller handle.
    317           *
    318           * @return value:
    319           *                        controller handle
    320           *
    321           *****************************************************************************/
    322          usb_device_handle USB_Class_Get_Ctrler_Handle(class_handle_t class_handle)
    323          {
    324              usb_device_handle ret;
    325              if(USB_UNINITIALIZED_VAL_32 != class_handle)
    326                  ret = ((usb_class_object_struct_t*)class_handle)->controller_handle;
    327              else
    328                  ret = NULL; 
    329              return ret;
    330          }
    331          #endif
    332          
    333          #endif
    334          /* EOF */
    335          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USB_Class_Deinit
      24   USB_Class_Init
        24   -> usb_device_register_application_notify
        24   -> usb_device_register_desc_request_notify
        24   -> usb_device_register_vendor_class_request_notify
       0   USB_Class_Periodic_Task
       0   USB_Class_Send_Data
         0   -> usb_device_send_data


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      34  USB_Class_Deinit
      68  USB_Class_Init
       2  USB_Class_Periodic_Task
      14  USB_Class_Send_Data
      16  usb_class_object

 
  16 bytes in section .bss
 122 bytes in section .text
 
 122 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
