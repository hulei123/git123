###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       13/Mar/2016  16:46:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\i2c\slave\src\fsl_i2c_slave_driver.c
#    Command line =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\i2c\slave\src\fsl_i2c_slave_driver.c
#        -D NDEBUG -D CPU_MK22FN512VDC12 -D CPU_IS_ARM_CORTEX_M4=1 -D IAR -D
#        FREEDOM -D BL_TARGET_FLASH -lC
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa050 -o
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program Files\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include/device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/uart\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/hid_device\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/adapter/sources/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/os/bm\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/arch/cortex_m\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/soc/MK22F\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/platform/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/include/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/bsp/mk22f\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/common\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/hid\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/classes/include\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/khci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/device/sources/controller/ehci\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/hal\
#        -I
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb_stack/usb_core/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\list\fsl_i2c_slave_driver.lst
#    Object file  =  
#        C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\targets\MK22F51212\iar\freedom_bootloader\debug\obj\fsl_i2c_slave_driver.o
#
###############################################################################

C:\Users\hulei\Desktop\FSL_Kinetis_Bootloader_1_2_1\src\drivers\i2c\slave\src\fsl_i2c_slave_driver.c
      1          /*
      2           * Copyright (c) 2013-2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_platform_common.h" // needed for NULL
     32          #include "bootloader/bl_peripheral_interface.h"
     33          #include "bootloader/bl_irq_common.h"
     34          #include "device/fsl_device_registers.h"
     35          #include "i2c/slave/fsl_i2c_slave_driver.h"
     36          #include "bootloader_common.h"
     37          #include "utilities/fsl_assert.h"
     38          
     39          #if BL_CONFIG_I2C
     40          ////////////////////////////////////////////////////////////////////////////////
     41          // Definitions
     42          ////////////////////////////////////////////////////////////////////////////////
     43          
     44          #define I2C_EMPTY_CHAR    (0x00)        //!< Empty character.
     45          
     46          enum
     47          {
     48              //! Max cycles supported to set glitch filter
     49              kI2CGlitchFilterMaxCycles = 31,
     50          };
     51          
     52          ////////////////////////////////////////////////////////////////////////////////
     53          // Variables
     54          ////////////////////////////////////////////////////////////////////////////////
     55          
     56          //! Place to store application callbacks for each of the I2C modules.

   \                                 In section .bss, align 4
     57          static i2c_slave_info_t s_applicationInfo[2] = {{0}};
   \                     s_applicationInfo:
   \   00000000                      DS8 32
     58          

   \                                 In section .text, align 4, keep-with-next
     59          const static uint32_t g_i2cBaseAddr[] = I2C_BASE_ADDRS;
   \                     g_i2cBaseAddr:
   \   00000000   0x40066000         DC32 1074159616, 1074163712
   \              0x40067000   
     60          
     61          ////////////////////////////////////////////////////////////////////////////////
     62          // Private Prototypes
     63          ////////////////////////////////////////////////////////////////////////////////
     64          
     65          void I2C0_IRQHandler(void);
     66          void I2C1_IRQHandler(void);
     67          static void i2c_slave_irqhandler(int instance);
     68          ////////////////////////////////////////////////////////////////////////////////
     69          // Code
     70          ////////////////////////////////////////////////////////////////////////////////
     71          
     72          #if !defined(BL_I2C_SIZE_OPTIMIZE) || USE_ONLY_I2C(0)
     73          //! @brief Implementation of I2C0 handler named in startup code.
     74          //!
     75          //! Passes instance to generic I2C IRQ handler.

   \                                 In section .text, align 2, keep-with-next
     76          void I2C0_IRQHandler(void)
     77          {
     78              i2c_slave_irqhandler(I2C0_IDX);
   \                     I2C0_IRQHandler: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      i2c_slave_irqhandler
     79          }
     80          #endif // !defined(BL_I2C_SIZE_OPTIMIZE) || USE_ONLY_I2C(0)
     81          
     82          #if (!defined(BL_I2C_SIZE_OPTIMIZE) || USE_ONLY_I2C(1)) && (I2C_INSTANCE_COUNT > 1)
     83          //! @brief Implementation of I2C1 handler named in startup code.
     84          //!
     85          //! Passes instance to generic I2C IRQ handler.

   \                                 In section .text, align 2, keep-with-next
     86          void I2C1_IRQHandler(void)
     87          {
     88              i2c_slave_irqhandler(I2C1_IDX);
   \                     I2C1_IRQHandler: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002                      REQUIRE i2c_slave_irqhandler
   \   00000002                      ;; // Fall through to label i2c_slave_irqhandler
     89          }
     90          #endif // (!defined(BL_I2C_SIZE_OPTIMIZE) || USE_ONLY_I2C(1)) && (I2C_INSTANCE_COUNT > 1)
     91          
     92          //! @brief I2C Slave Generic IRQ handler.
     93          //!
     94          //! Implements the flow chart at the end of the I2C chapter in the Kinetis
     95          //! KL25 Sub-Family Reference Manual. It uses callbacks to get/put data
     96          //! from/to the application as well as alert the application of an error condition.
     97          //!
     98          //! @param instance Instance number of the I2C module.

   \                                 In section .text, align 2, keep-with-next
     99          static void i2c_slave_irqhandler(int instance)
    100          {
   \                     i2c_slave_irqhandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    101          #if USE_ONLY_I2C(0)
    102              instance = 0;
    103          #elif USE_ONLY_I2C(1)
    104              instance = 1;
    105          #endif  //USE_ONLY_I2C(0)
    106          
    107              assert(instance < I2C_INSTANCE_COUNT);
    108          
    109              uint32_t baseAddr = g_i2cBaseAddr[instance];
   \   00000002   0x.... 0x....      ADR.W    R1,g_i2cBaseAddr
   \   00000006   0xF851 0x4020      LDR      R4,[R1, R0, LSL #+2]
    110          
    111              i2c_slave_info_t * appInfo = &s_applicationInfo[instance];
   \   0000000A   0x....             LDR.N    R1,??DataTable5
   \   0000000C   0xEB01 0x1300      ADD      R3,R1,R0, LSL #+4
    112              uint8_t status;
    113          
    114          #if defined(I2C_SMB)
    115          
    116              status = I2C_RD_SMB((I2C_Type *)baseAddr);
    117          
    118              if (status & I2C_SMB_SLTF_MASK)
    119              {
    120                  // Clear SCL Low Timeout flag
    121                  I2C_SET_SMB((I2C_Type *)baseAddr, I2C_SMB_SLTF_MASK);
    122                  // Clear interrupt flag
    123                  I2C_SET_S((I2C_Type *)baseAddr, I2C_S_IICIF_MASK);
    124          
    125                  appInfo->on_error(instance);
    126          
    127                  return;
    128              }
    129          #endif
    130          
    131              status = I2C_RD_S((I2C_Type *)baseAddr);
   \   00000010   0x78E1             LDRB     R1,[R4, #+3]
    132              bool doTransmit = false;
    133          
    134              // Clear interrupt flag(s)
    135              I2C_SET_S((I2C_Type *)baseAddr, (I2C_S_ARBL_MASK | I2C_S_IICIF_MASK) & status);
   \   00000012   0x78E2             LDRB     R2,[R4, #+3]
   \   00000014   0xF001 0x0512      AND      R5,R1,#0x12
   \   00000018   0x432A             ORRS     R2,R5,R2
   \   0000001A   0x70E2             STRB     R2,[R4, #+3]
    136          
    137              if ((status & I2C_S_ARBL_MASK) && (!(status & I2C_S_IAAS_MASK))) // ArbitrationLost and not AddressedAsSlave
   \   0000001C   0xF001 0x0250      AND      R2,R1,#0x50
   \   00000020   0x2A10             CMP      R2,#+16
   \   00000022   0xD010             BEQ.N    ??i2c_slave_irqhandler_0
    138              {
    139                  // I2C_S_ARBL is already cleared by ClearInterruptFlags()
    140          //         error = kStatus_I2C_AribtrationLost;
    141              }
    142              else if (status & I2C_S_IAAS_MASK) // AddressedAsSlave
   \   00000024   0x064A             LSLS     R2,R1,#+25
   \   00000026   0xD514             BPL.N    ??i2c_slave_irqhandler_1
    143              {
    144                  if (status & I2C_S_SRW_MASK) // Master read from Slave. Slave transmit.
   \   00000028   0x0748             LSLS     R0,R1,#+29
   \   0000002A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002C   0xD50C             BPL.N    ??i2c_slave_irqhandler_2
    145                  {
    146                      // Switch to TX mode
    147                      I2C_SET_C1((I2C_Type *)baseAddr, I2C_C1_TX_MASK);
   \   0000002E   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000032   0x70A0             STRB     R0,[R4, #+2]
    148          
    149                      doTransmit = true;
    150                  }
    151                  else // Master write to Slave. Slave receive.
    152                  {
    153                      // Switch to RX mode.
    154                      I2C_CLR_C1((I2C_Type *)baseAddr, I2C_C1_TX_MASK);
    155          
    156                      // Dummy read character.
    157                      char dummy = I2C_RD_D((I2C_Type *)baseAddr);
    158                  }
    159              }
    160              else // not AddressedAsSlave
    161              {
    162                  if (I2C_RD_C1_TX((I2C_Type *)baseAddr)) // Transmit.
    163                  {
    164                      if (status & I2C_S_RXAK_MASK) // No ACK from receiver.
    165                      {
    166                          // Switch to RX mode.
    167                          I2C_CLR_C1((I2C_Type *)baseAddr, I2C_C1_TX_MASK);
    168          
    169                          // Dummy read character.
    170                          char dummy = I2C_RD_D((I2C_Type *)baseAddr);
    171                      }
    172                      else // ACK from receiver.
    173                      {
    174                          // DO TRANSMIT
    175                          doTransmit = true;
    176                      }
    177                  }
    178                  else // Receive.
    179                  {
    180                      // Get byte from data register.
    181                      uint8_t sink_byte = I2C_RD_D((I2C_Type *)baseAddr);
    182          
    183                      appInfo->data_sink(sink_byte, instance);
    184                  }
    185              }
    186          
    187              if (doTransmit)
    188              {
    189                  uint8_t source_byte = I2C_EMPTY_CHAR;
   \                     ??i2c_slave_irqhandler_3: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
    190          
    191                  appInfo->data_source(&source_byte);
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x6819             LDR      R1,[R3, #+0]
   \   0000003E   0x4788             BLX      R1
    192          
    193                  // Store char to transmit register.
    194                  I2C_WR_D((I2C_Type *)baseAddr, source_byte);
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0x7120             STRB     R0,[R4, #+4]
    195              }
    196          }
   \                     ??i2c_slave_irqhandler_0: (+1)
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??i2c_slave_irqhandler_2: (+1)
   \   00000048   0xF000 0x00EF      AND      R0,R0,#0xEF
   \   0000004C   0x70A0             STRB     R0,[R4, #+2]
   \   0000004E   0x7920             LDRB     R0,[R4, #+4]
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??i2c_slave_irqhandler_1: (+1)
   \   00000052   0x78A2             LDRB     R2,[R4, #+2]
   \   00000054   0xF3C2 0x1200      UBFX     R2,R2,#+4,#+1
   \   00000058   0xB11A             CBZ.N    R2,??i2c_slave_irqhandler_4
   \   0000005A   0x07C8             LSLS     R0,R1,#+31
   \   0000005C   0xD5EA             BPL.N    ??i2c_slave_irqhandler_3
   \   0000005E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000060   0xE7F2             B.N      ??i2c_slave_irqhandler_2
   \                     ??i2c_slave_irqhandler_4: (+1)
   \   00000062   0x7922             LDRB     R2,[R4, #+4]
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x4610             MOV      R0,R2
   \   00000068   0x685A             LDR      R2,[R3, #+4]
   \   0000006A   0x4790             BLX      R2
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}
    197          
    198          // See fsl_i2c_slave_driver.h for documentation of this function.

   \                                 In section .text, align 2, keep-with-next
    199          void i2c_slave_reset(int instance)
    200          {
    201              uint32_t baseAddr = g_i2cBaseAddr[instance];
   \                     i2c_slave_reset: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,g_i2cBaseAddr
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
    202          
    203              // Restore those control and configuration registers which are used to
    204              // be operated
    205              I2C_WR_C1((I2C_Type *)baseAddr, 0);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    206              I2C_WR_A1((I2C_Type *)baseAddr, 0);
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    207              I2C_WR_FLT((I2C_Type *)baseAddr, 0);
   \   0000000E   0x7181             STRB     R1,[R0, #+6]
    208          
    209          #if defined(I2C_SMB)
    210              // Clear SCL Low Timeout Flag
    211              I2C_WR_SMB((I2C_Type *)baseAddr, I2C_SMB_SLTF_MASK);
    212              // Disable SCL Low Timout check, configure with 0.
    213              I2C_WR_SLTH((I2C_Type *)baseAddr, 0);
    214              I2C_WR_SLTL((I2C_Type *)baseAddr, 0);
    215          #endif // I2C_SMB
    216          
    217          }
   \   00000010   0x4770             BX       LR               ;; return
    218          
    219          // See i2c_slave.h for documentation of this function.

   \                                 In section .text, align 2, keep-with-next
    220          void i2c_slave_init(int instance, i2c_slave_info_t * appInfo)
    221          {
   \                     i2c_slave_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    222          #if USE_ONLY_I2C(0)
    223              instance = 0;
    224          #elif USE_ONLY_I2C(1)
    225              instance = 1;
    226          #endif  //USE_ONLY_I2C(0)
    227          
    228              assert(appInfo);
    229              assert(instance < I2C_INSTANCE_COUNT);
    230          
    231              uint32_t baseAddr = g_i2cBaseAddr[instance];
   \   00000004   0x.... 0x....      ADR.W    R0,g_i2cBaseAddr
   \   00000008   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
    232          
    233              // Save the application info.
    234              s_applicationInfo[instance] = *appInfo;
   \   0000000C   0x....             LDR.N    R0,??DataTable5
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0xEB00 0x1004      ADD      R0,R0,R4, LSL #+4
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy4
    235          
    236              // Enable clock for I2C.
    237          #if USE_ONLY_I2C(0) || (I2C_INSTANCE_COUNT == 1)
    238              SIM_SET_SCGC4(SIM, SIM_SCGC4_I2C0_MASK);
    239          #elif USE_ONLY_I2C(1)
    240              SIM_SET_SCGC4(SIM, SIM_SCGC4_I2C1_MASK);
    241          #else
    242              SIM_SET_SCGC4(SIM, instance == I2C0_IDX ? SIM_SCGC4_I2C0_MASK : SIM_SCGC4_I2C1_MASK);
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40048034
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xBF0C             ITE      EQ 
   \   00000022   0x2240             MOVEQ    R2,#+64
   \   00000024   0x2280             MOVNE    R2,#+128
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    243          #endif // USE_ONLY_I2C(0) || (I2C_INSTANCE_COUNT == 1)
    244          
    245              // Clear control register.
    246              I2C_WR_C1((I2C_Type *)baseAddr, 0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x70B0             STRB     R0,[R6, #+2]
    247          
    248              // Clear bus status interrupt flags.
    249              I2C_WR_FLT((I2C_Type *)baseAddr, I2C_FLT_STOPF_MASK);
    250          
    251              // Clear interrupt flag.
    252              I2C_WR_S((I2C_Type *)baseAddr, I2C_S_IICIF_MASK);
    253          
    254              // Enable I2C IRQ.
    255              i2c_set_system_IRQ_gate(instance, kPeripheralEnableIRQ);
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x71B0             STRB     R0,[R6, #+6]
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x70F0             STRB     R0,[R6, #+3]
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       i2c_set_system_IRQ_gate
    256          
    257              // Set Slave Address.
    258              I2C_BWR_A1_AD((I2C_Type *)baseAddr, appInfo->slaveAddress);
   \   0000003E   0x7830             LDRB     R0,[R6, #+0]
   \   00000040   0x7B29             LDRB     R1,[R5, #+12]
   \   00000042   0x0840             LSRS     R0,R0,#+1
   \   00000044   0x4149             ADCS     R1,R1,R1
   \   00000046   0x7031             STRB     R1,[R6, #+0]
    259              // No extended functions.
    260              I2C_WR_C2((I2C_Type *)baseAddr, 0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7170             STRB     R0,[R6, #+5]
    261              // No glitch filter.
    262              I2C_WR_FLT((I2C_Type *)baseAddr, 0);
   \   0000004C   0x71B0             STRB     R0,[R6, #+6]
    263          #if defined(I2C_SMB)
    264              // Select the source of Timeout Counter, Clear SCL Low Timeout Flag
    265              I2C_WR_SMB((I2C_Type *)baseAddr, I2C_SMB_TCKSEL_MASK | I2C_SMB_SLTF_MASK);
    266              // Enable SCL Low Timout check, configure with max value.
    267              I2C_WR_SLTH((I2C_Type *)baseAddr, I2C_SLTH_SSLT_MASK);
    268              I2C_WR_SLTL((I2C_Type *)baseAddr, I2C_SLTL_SSLT_MASK);
    269          #endif
    270              // Set baud rate.
    271              I2C_WR_F((I2C_Type *)baseAddr, 0);
   \   0000004E   0x7070             STRB     R0,[R6, #+1]
    272              // Enable I2C device.
    273              I2C_SET_C1((I2C_Type *)baseAddr, I2C_C1_IICEN_MASK);
   \   00000050   0x78B0             LDRB     R0,[R6, #+2]
   \   00000052   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000056   0x70B0             STRB     R0,[R6, #+2]
    274              // Enable interrupt.
    275              I2C_SET_C1((I2C_Type *)baseAddr, I2C_C1_IICIE_MASK);
   \   00000058   0x78B0             LDRB     R0,[R6, #+2]
   \   0000005A   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000005E   0x70B0             STRB     R0,[R6, #+2]
    276          }
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    277          
    278          // See i2c_slave.h for documentation of this function.

   \                                 In section .text, align 2, keep-with-next
    279          void i2c_slave_deinit(int instance)
    280          {
   \                     i2c_slave_deinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    281              assert(instance < I2C_INSTANCE_COUNT);
    282          
    283              // Make sure the instance being de-initialized is actually clocked so that
    284              // registers writes won't cause an abort
    285          #if USE_ONLY_I2C(0) || (I2C_INSTANCE_COUNT == 1)
    286              if (SIM_RD_SCGC4(SIM) & SIM_SCGC4_I2C0_MASK)
    287              {
    288                  NVIC_DisableIRQ(I2C0_IRQn);
    289          #if defined (I2C)
    290                  I2C_WR_C1(I2C, 0);
    291                  I2C_BWR_A1_AD(I2C, 0);
    292                  I2C_WR_FLT(I2C, 0);
    293          #else
    294                  // Set the i2c slave address as 0x0
    295                  I2C_WR_C1(I2C0, 0);
    296                  I2C_BWR_A1_AD(I2C0, 0);
    297                  I2C_WR_FLT(I2C0, 0);
    298          #endif  //defined (I2C)
    299          
    300          #if defined(I2C_SMB)
    301          #if defined (I2C)
    302              // Clear SCL Low Timeout Flag
    303              I2C_WR_SMB(I2C, I2C_SMB_SLTF_MASK);
    304              // Disable SCL Low Timout check, configure with 0.
    305              I2C_WR_SLTH(I2C, 0);
    306              I2C_WR_SLTL(I2C, 0);
    307          #else
    308                  // Clear SCL Low Timeout Flag
    309              I2C_WR_SMB(I2C0, I2C_SMB_SLTF_MASK);
    310              // Disable SCL Low Timout check, configure with 0.
    311              I2C_WR_SLTH(I2C0, 0);
    312              I2C_WR_SLTL(I2C0, 0);
    313          #endif // defined (I2C)
    314          #endif // I2C_SMB
    315                  SIM_CLR_SCGC4(SIM, SIM_SCGC4_I2C0_MASK);
    316              }
    317          #elif USE_ONLY_I2C(1)
    318              if (SIM_RD_SCGC4(SIM) & SIM_SCGC4_I2C1_MASK)
    319              {
    320                  NVIC_DisableIRQ(I2C1_IRQn);
    321                  I2C_WR_C1(I2C1, 0);
    322                  // Set the i2c slave address as 0x0
    323                  I2C_WR_A1_AD(I2C1, 0);
    324                  I2C_WR_FLT(I2C1, 0);
    325          #if defined(I2C_SMB)
    326              // Clear SCL Low Timeout Flag
    327              I2C_WR_SMB(I2C1, I2C_SMB_SLTF_MASK);
    328              // Disable SCL Low Timout check, configure with 0.
    329              I2C_WR_SLTH(I2C1, 0);
    330              I2C_WR_SLTL(I2C1, 0);
    331          #endif // I2C_SMB
    332                  SIM_CLR_SCGC4(SIM, SIM_SCGC4_I2C1_MASK);
    333              }
    334          #else
    335          //    uint32_t baseAddr = g_i2cBaseAddr[instance];
    336          
    337              if (((instance == 0) && (SIM_RD_SCGC4(SIM) & SIM_SCGC4_I2C0_MASK)) ||
    338                  ((instance == 1) && (SIM_RD_SCGC4(SIM) & SIM_SCGC4_I2C1_MASK)))
   \   00000004   0x....             LDR.N    R4,??DataTable5_1  ;; 0x40048034
   \   00000006   0xD103             BNE.N    ??i2c_slave_deinit_0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x0640             LSLS     R0,R0,#+25
   \   0000000C   0xD405             BMI.N    ??i2c_slave_deinit_1
   \   0000000E   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??i2c_slave_deinit_0: (+1)
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD110             BNE.N    ??i2c_slave_deinit_2
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x0600             LSLS     R0,R0,#+24
   \   00000018   0xD50D             BPL.N    ??i2c_slave_deinit_2
    339              {
    340                  // Disable I2C interrupt
    341                  // Enable I2C IRQ.
    342              	i2c_set_system_IRQ_gate(instance, kPeripheralDisableIRQ);
   \                     ??i2c_slave_deinit_1: (+1)
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       i2c_set_system_IRQ_gate
    343          
    344                  // Reset I2C registers
    345                  i2c_slave_reset(instance);
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       i2c_slave_reset
    346          
    347                  // Disable clock for I2C.
    348                  SIM_CLR_SCGC4(SIM, instance == I2C0_IDX ? SIM_SCGC4_I2C0_MASK : SIM_SCGC4_I2C1_MASK);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xBF0C             ITE      EQ 
   \   0000002E   0x2140             MOVEQ    R1,#+64
   \   00000030   0x2180             MOVNE    R1,#+128
   \   00000032   0x4388             BICS     R0,R0,R1
   \   00000034   0x6020             STR      R0,[R4, #+0]
    349              }
    350          #endif // USE_ONLY_I2C(0) || (I2C_INSTANCE_COUNT == 1)
    351          }
   \                     ??i2c_slave_deinit_2: (+1)
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    352          
    353          // See i2c_slave.h for documentation of this function.

   \                                 In section .text, align 2, keep-with-next
    354          void i2c_set_glitch_filter_width(int instance, uint32_t busClock_Hz, uint32_t glitchWidth_ns)
    355          {
   \                     i2c_set_glitch_filter_width: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    356          #if USE_ONLY_I2C(0)
    357              instance = 0;
    358          #elif USE_ONLY_I2C(1)
    359              instance = 1;
    360          #endif  //USE_ONLY_I2C(0)
    361          
    362              uint32_t baseAddr = g_i2cBaseAddr[instance];
   \   00000002   0x.... 0x....      ADR.W    R3,g_i2cBaseAddr
   \   00000006   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
    363              uint32_t busCycle_ns = 1000000 / (busClock_Hz / 1000);
   \   0000000A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000000E   0xFBB1 0xF1F3      UDIV     R1,R1,R3
   \   00000012   0x....             LDR.N    R3,??DataTable5_2  ;; 0xf4240
   \   00000014   0xFBB3 0xF1F1      UDIV     R1,R3,R1
    364          
    365              // Search for the cycle count just below the desired glitch width.
    366              uint32_t cycles = 0;
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0xE000             B.N      ??i2c_set_glitch_filter_width_0
    367              while (((cycles + 1) * busCycle_ns) < glitchWidth_ns)
    368              {
    369                  ++cycles;
   \                     ??i2c_set_glitch_filter_width_1: (+1)
   \   0000001C   0x4623             MOV      R3,R4
    370              }
   \                     ??i2c_set_glitch_filter_width_0: (+1)
   \   0000001E   0x1C5C             ADDS     R4,R3,#+1
   \   00000020   0xFB01 0xF504      MUL      R5,R1,R4
   \   00000024   0x4295             CMP      R5,R2
   \   00000026   0xD3F9             BCC.N    ??i2c_set_glitch_filter_width_1
    371          
    372              // If we end up with zero cycles, then set the filter to a single cycle unless the
    373              // bus clock is greater than 10x the desired glitch width.
    374              if ((cycles == 0) && (busCycle_ns <= (glitchWidth_ns * 10)))
   \   00000028   0xB92B             CBNZ.N   R3,??i2c_set_glitch_filter_width_2
   \   0000002A   0x240A             MOVS     R4,#+10
   \   0000002C   0x4362             MULS     R2,R4,R2
   \   0000002E   0x428A             CMP      R2,R1
   \   00000030   0xD304             BCC.N    ??i2c_set_glitch_filter_width_3
    375              {
    376                  cycles = 1;
   \   00000032   0x2301             MOVS     R3,#+1
   \   00000034   0xE002             B.N      ??i2c_set_glitch_filter_width_3
    377              }
    378              // If the cycles is greater the max cycles supported to set glitch filter,
    379              // then cycles should be equal to max cycles
    380              else if (cycles > kI2CGlitchFilterMaxCycles)
   \                     ??i2c_set_glitch_filter_width_2: (+1)
   \   00000036   0x2B20             CMP      R3,#+32
   \   00000038   0xBF28             IT       CS 
   \   0000003A   0x231F             MOVCS    R3,#+31
    381              {
    382                  cycles = kI2CGlitchFilterMaxCycles;
    383              }
    384          
    385              I2C_BWR_FLT_FLT((I2C_Type *)baseAddr, cycles);
   \                     ??i2c_set_glitch_filter_width_3: (+1)
   \   0000003C   0x7981             LDRB     R1,[R0, #+6]
   \   0000003E   0xF001 0x01A0      AND      R1,R1,#0xA0
   \   00000042   0xF003 0x020F      AND      R2,R3,#0xF
   \   00000046   0x4311             ORRS     R1,R2,R1
   \   00000048   0x7181             STRB     R1,[R0, #+6]
    386          }
   \   0000004A   0xBD30             POP      {R4,R5,PC}       ;; return
    387          
    388          // See i2c_slave.h for documentation of this function.

   \                                 In section .text, align 2, keep-with-next
    389          void i2c_slave_set_data_sink_func(uint32_t instance, void (*data_sink)(uint8_t, uint32_t))
    390          {
    391              s_applicationInfo[instance].data_sink = data_sink;
   \                     i2c_slave_set_data_sink_func: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable5
   \   00000002   0xEB02 0x1000      ADD      R0,R2,R0, LSL #+4
   \   00000006   0x6041             STR      R1,[R0, #+4]
    392          }
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     s_applicationInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x000F4240         DC32     0xf4240
    393          #endif // BL_CONFIG_I2C
    394          ////////////////////////////////////////////////////////////////////////////////
    395          // EOF
    396          ////////////////////////////////////////////////////////////////////////////////
    397          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2C0_IRQHandler
         0   -> i2c_slave_irqhandler
       0   I2C1_IRQHandler
         0   -> i2c_slave_irqhandler
      12   i2c_set_glitch_filter_width
      16   i2c_slave_deinit
        16   -> i2c_set_system_IRQ_gate
        16   -> i2c_slave_reset
      16   i2c_slave_init
        16   -> __aeabi_memcpy4
        16   -> i2c_set_system_IRQ_gate
      16   i2c_slave_irqhandler
        16   -- Indirect call
       0   i2c_slave_reset
       0   i2c_slave_set_data_sink_func


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  I2C0_IRQHandler
       2  I2C1_IRQHandler
       8  g_i2cBaseAddr
      76  i2c_set_glitch_filter_width
      56  i2c_slave_deinit
      98  i2c_slave_init
     110  i2c_slave_irqhandler
      18  i2c_slave_reset
      10  i2c_slave_set_data_sink_func
      32  s_applicationInfo

 
  32 bytes in section .bss
 394 bytes in section .text
 
 394 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
